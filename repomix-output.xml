This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  LEAD_DATA_PRESERVATION.md
public/
  file.svg
  globe.svg
  logo.png
  next.svg
  vercel.svg
  window.svg
scripts/
  check-instantly-lead-status.ts
  check-instantly-status-fields.ts
  compare-instantly-positive-replies.ts
  sync-all-leads.ts
  sync-positive-replies.ts
  verify-positive-replies.ts
src/
  app/
    (marketing)/
      features/
        page.tsx
      pricing/
        page.tsx
      layout.tsx
    admin/
      clients/
        [clientId]/
          campaigns/
            [campaignId]/
              page.tsx
            add-campaign-dialog.tsx
            page.tsx
            sync-button.tsx
          settings/
            page.tsx
          page.tsx
        add-client-dialog.tsx
        page.tsx
      infrastructure/
        infrastructure-view.tsx
        page.tsx
      instantly/
        accounts/
          page.tsx
        analytics/
          page.tsx
        campaigns/
          page.tsx
        page.tsx
      lead-database/
        page.tsx
      leads/
        admin-leads-view.tsx
        page.tsx
      settings/
        page.tsx
      subscriptions/
        page.tsx
      layout.tsx
      page.tsx
    api/
      admin/
        analytics/
          sync/
            route.ts
          route.ts
        customers/
          [customerId]/
            route.ts
          route.ts
        infrastructure/
          accounts/
            [accountId]/
              route.ts
            route.ts
          dns/
            route.ts
          history/
            route.ts
          stats/
            route.ts
          sync/
            route.ts
        invitations/
          route.ts
        lead-database/
          sources/
            route.ts
          upload/
            route.ts
        leads/
          export/
            route.ts
        settings/
          logo/
            route.ts
          route.ts
        subscriptions/
          [id]/
            route.ts
          route.ts
      campaigns/
        [campaignId]/
          details/
            route.ts
          leads/
            route.ts
          sequences/
            route.ts
          sync-emails/
            route.ts
          sync-leads/
            route.ts
          route.ts
      clients/
        [clientId]/
          campaigns/
            route.ts
          invitations/
            route.ts
          leads/
            route.ts
          logo/
            route.ts
          sync-positive/
            route.ts
          route.ts
        route.ts
      instantly/
        accounts/
          route.ts
        campaigns/
          [id]/
            route.ts
          analytics/
            daily/
              route.ts
            overview/
              route.ts
            route.ts
          route.ts
        leads/
          route.ts
        refresh-status/
          route.ts
        status/
          route.ts
        sync/
          route.ts
        validate-key/
          route.ts
      leads/
        [leadId]/
          emails/
            route.ts
          workflow/
            route.ts
      providers/
        [provider]/
          campaigns/
            route.ts
          validate/
            route.ts
      webhooks/
        [provider]/
          route.ts
        instantly/
          [campaignId]/
            route.ts
          route.ts
    auth/
      accept-invite/
        route.ts
      callback/
        route.ts
      signout/
        route.ts
    dashboard/
      [clientId]/
        client-info-tooltip.tsx
        client-leads-view.tsx
        page.tsx
      layout.tsx
      page.tsx
    login/
      login-client.tsx
      page.tsx
    globals.css
    icon.svg
    layout.tsx
    page.tsx
  components/
    admin/
      add-customer-dialog.tsx
      delete-customer-dialog.tsx
    layout/
      header.tsx
      sidebar.tsx
      stats-cards.tsx
    leads/
      lead-detail-panel.tsx
      lead-table.tsx
    marketing/
      footer.tsx
      header.tsx
    ui/
      badge.tsx
      button.tsx
      card.tsx
      checkbox.tsx
      dialog.tsx
      dropdown-menu.tsx
      info-tooltip.tsx
      input.tsx
      label.tsx
      select.tsx
      sheet.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
    theme-toggle.tsx
  lib/
    dns/
      checker.ts
      index.ts
    email/
      index.ts
      send.ts
    instantly/
      accounts.ts
      analytics.ts
      campaigns.ts
      client.ts
      emails.ts
      index.ts
      leads.ts
      types.ts
    providers/
      instantly/
        client.ts
        index.ts
      smartlead/
        client.ts
        index.ts
      index.ts
      types.ts
    queries/
      analytics.ts
      campaigns.ts
      clients.ts
      leads.ts
      stats.ts
    smartlead/
      accounts.ts
      client.ts
      index.ts
      types.ts
    supabase/
      client.ts
      middleware.ts
      server.ts
    utils.ts
  types/
    database.ts
  middleware.ts
supabase/
  migrations/
    20241230_add_email_sequences_and_threads.sql
    20241230_add_lead_database.sql
    20250101_add_instantly_lead_fields.sql
    20250103_add_per_campaign_api_keys.sql
    20250103_add_subscriptions.sql
    20260103_add_infrastructure_health.sql
    20260104_add_email_sync_timestamp.sql
    20260104_add_leads_unique_constraint.sql
    20260104_fix_positive_leads_logic.sql
.dockerignore
.gitignore
Caddyfile
check_db.mjs
check-positive.mjs
CLAUDE.md
components.json
CRON_SETUP.md
docker-compose.yml
Dockerfile
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
refresh-status.mjs
supabase-add-icp.sql
supabase-analytics.sql
supabase-preserve-leads.sql
supabase-schema-v2.sql
supabase-schema.sql
supabase-settings.sql
sync-payload.mjs
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/LEAD_DATA_PRESERVATION.md">
# Lead Data Preservation Guide

This document explains how lead data is managed to ensure no data loss during Instantly sync operations.

## Lead Field Categories

### 1. LOCAL-ONLY Fields (Never overwritten by sync)
These fields are managed exclusively in the portal and should NEVER be overwritten by Instantly sync:

| Field | Description |
|-------|-------------|
| `notes` | User-entered notes about the lead |
| `deal_value` | Potential deal value entered by user |
| `next_action` | Next action to take with this lead |
| `next_action_date` | When the next action is scheduled |
| `linkedin_url` | LinkedIn profile URL |
| `phone` | Phone number (can be enriched locally) |

### 2. INSTANTLY-SOURCED Fields (Updated from Instantly API)
These fields come from Instantly and are updated during sync:

| Field | Description | Update Rule |
|-------|-------------|-------------|
| `email` | Lead email address | Never changes (primary identifier) |
| `first_name` | First name | Update if local is empty |
| `last_name` | Last name | Update if local is empty |
| `company_name` | Company name | Update if local is empty |
| `company_domain` | Company domain | Update if local is empty |
| `personalization` | Email personalization text | Update if local is empty |
| `instantly_lead_id` | Instantly's internal ID | Set once, never change |
| `instantly_created_at` | When created in Instantly | Set once, never change |
| `last_contacted_at` | Last email sent timestamp | Always update (newer is better) |
| `last_step_info` | Last email step info | Always update |
| `email_open_count` | Number of email opens | Always update (increment only) |
| `email_click_count` | Number of link clicks | Always update (increment only) |
| `email_reply_count` | Number of replies | Always update (increment only) |
| `metadata` | Additional Instantly payload data | Merge, never overwrite |

### 3. STATUS Fields (Smart Update Logic)
These fields use special logic to prevent downgrading:

| Field | Description | Update Rule |
|-------|-------------|-------------|
| `status` | Lead funnel status | Only upgrade, never downgrade |
| `is_positive_reply` | Positive classification | Only set to true, never reset to false by sync |

## Status Priority (Highest to Lowest)

```
won (8)          - Deal closed won
lost (7)         - Deal closed lost
booked (6)       - Meeting booked
replied (5)      - Lead has replied
clicked (4)      - Link clicked
opened (3)       - Email opened
contacted (2)    - Email sent
not_interested (1) - Marked not interested
```

**Rule**: Sync will only update status if the new status has HIGHER priority than current.

## Sync Behavior Summary

### Full Sync (`/api/instantly/sync`)
1. **New leads**: Creates with all Instantly data
2. **Existing leads**: Updates ONLY Instantly-sourced fields, preserves local-only fields

### Status Refresh (`/api/instantly/refresh-status`)
1. Updates email counts (open, click, reply)
2. Updates status only if higher priority
3. Updates `is_positive_reply` only if becoming positive

### Webhooks (`/api/webhooks/instantly/[campaignId]`)
1. Real-time updates for specific events
2. Sets `is_positive_reply=true` for positive events
3. Sets `is_positive_reply=false` for negative events
4. Updates status to "replied" for reply events

## Data Integrity Guarantees

1. **Notes are NEVER deleted or overwritten** by any sync operation
2. **Deal values are NEVER modified** by sync
3. **Status is NEVER downgraded** by sync (e.g., "replied" won't become "contacted")
4. **Positive reply flag can change** based on Instantly classification, but only via explicit events
5. **Email counts only increase**, never decrease
6. **Metadata is merged**, not replaced

## Implementation Notes

The sync logic uses an "upsert with field protection" pattern:

```typescript
// Fields to ALWAYS preserve (never overwrite)
const preservedFields = ['notes', 'deal_value', 'next_action', 'next_action_date'];

// Fields to only update if local is empty
const fillOnlyFields = ['first_name', 'last_name', 'company_name', 'phone', 'linkedin_url'];

// Fields to always update from Instantly
const alwaysUpdateFields = ['email_open_count', 'email_click_count', 'email_reply_count', 'last_contacted_at'];
```
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="scripts/check-instantly-lead-status.ts">
import { createClient } from "@supabase/supabase-js";

const INSTANTLY_API_KEY = process.env.INSTANTLY_API_KEY;
const BASE_URL = "https://api.instantly.ai";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

async function postToInstantly(endpoint: string, body: Record<string, unknown>) {
  const url = `${BASE_URL}/api/v2${endpoint}`;

  const res = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${INSTANTLY_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    throw new Error(`API error: ${res.status} ${await res.text()}`);
  }

  return res.json();
}

async function checkLeadStatus() {
  console.log("=== CHECKING INSTANTLY LEAD INTEREST_STATUS VALUES ===\n");

  // Get campaigns
  const { data: campaigns } = await supabase
    .from("campaigns")
    .select("id, name, instantly_campaign_id")
    .not("instantly_campaign_id", "is", null);

  if (!campaigns?.length) {
    console.log("No campaigns found");
    return;
  }

  // Check each campaign
  for (const campaign of campaigns) {
    console.log(`\n=== Campaign: ${campaign.name} ===`);
    console.log(`Instantly ID: ${campaign.instantly_campaign_id}\n`);

    try {
      // Get leads using POST with "campaign" param
      const data = await postToInstantly("/leads/list", {
        campaign: campaign.instantly_campaign_id,
        limit: 100,
      });

      const items = data.items || data || [];
      console.log(`Fetched ${items.length} leads\n`);

      // Count by interest_status
      const statusCounts: Record<string, number> = {};
      for (const lead of items) {
        const status = lead.interest_status || "null/empty";
        statusCounts[status] = (statusCounts[status] || 0) + 1;
      }

      console.log("Interest status distribution:");
      for (const [status, count] of Object.entries(statusCounts)) {
        console.log(`  ${status}: ${count}`);
      }

      // Show sample lead structure
      if (items.length > 0) {
        console.log("\nSample lead structure:");
        const sampleLead = items[0];
        console.log(`  email: ${sampleLead.email}`);
        console.log(`  interest_status: ${sampleLead.interest_status}`);
        console.log(`  status: ${sampleLead.status}`);
        console.log(`  lead_status: ${sampleLead.lead_status}`);
        console.log(`  all keys: ${Object.keys(sampleLead).join(", ")}`);
      }

      // Try fetching "interested" leads specifically
      const interestedData = await postToInstantly("/leads/list", {
        campaign: campaign.instantly_campaign_id,
        limit: 100,
        interest_status: "interested",
      });

      const interestedItems = interestedData.items || interestedData || [];
      console.log(`\nLeads with interest_status="interested": ${interestedItems.length}`);

      // Also try "meeting_booked"
      const meetingBookedData = await postToInstantly("/leads/list", {
        campaign: campaign.instantly_campaign_id,
        limit: 100,
        interest_status: "meeting_booked",
      });

      const meetingBookedItems = meetingBookedData.items || meetingBookedData || [];
      console.log(`Leads with interest_status="meeting_booked": ${meetingBookedItems.length}`);

    } catch (e) {
      console.log(`Error: ${e}`);
    }
  }
}

checkLeadStatus().catch(console.error);
</file>

<file path="scripts/check-instantly-status-fields.ts">
import { createClient } from "@supabase/supabase-js";

const INSTANTLY_API_KEY = process.env.INSTANTLY_API_KEY;
const BASE_URL = "https://api.instantly.ai";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

async function postToInstantly(endpoint: string, body: Record<string, unknown>) {
  const url = `${BASE_URL}/api/v2${endpoint}`;

  const res = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${INSTANTLY_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    throw new Error(`API error: ${res.status} ${await res.text()}`);
  }

  return res.json();
}

async function checkStatusFields() {
  console.log("=== ANALYZING INSTANTLY LEAD STATUS FIELDS ===\n");

  // Get one campaign
  const { data: campaigns } = await supabase
    .from("campaigns")
    .select("id, name, instantly_campaign_id")
    .not("instantly_campaign_id", "is", null)
    .limit(2);

  if (!campaigns?.length) {
    console.log("No campaigns found");
    return;
  }

  for (const campaign of campaigns) {
    console.log(`\n=== Campaign: ${campaign.name} ===\n`);

    // Get many leads to analyze patterns
    let allLeads: any[] = [];
    let skip = 0;

    while (allLeads.length < 500) {
      const data = await postToInstantly("/leads/list", {
        campaign: campaign.instantly_campaign_id,
        limit: 100,
        skip,
      });

      const items = data.items || data || [];
      if (items.length === 0) break;

      allLeads.push(...items);
      skip += 100;
    }

    console.log(`Analyzed ${allLeads.length} leads\n`);

    // Count by numeric status
    const statusCounts: Record<number, number> = {};
    const statusSummaryCounts: Record<string, number> = {};

    // Track leads with replies
    const leadsWithReplies: any[] = [];
    const leadsWithOpens: any[] = [];

    for (const lead of allLeads) {
      const status = lead.status;
      statusCounts[status] = (statusCounts[status] || 0) + 1;

      const summary = lead.status_summary || "empty";
      statusSummaryCounts[summary] = (statusSummaryCounts[summary] || 0) + 1;

      if (lead.email_reply_count > 0) {
        leadsWithReplies.push(lead);
      }
      if (lead.email_open_count > 0) {
        leadsWithOpens.push(lead);
      }
    }

    console.log("Distribution by 'status' field:");
    for (const [status, count] of Object.entries(statusCounts)) {
      console.log(`  status=${status}: ${count} leads`);
    }

    console.log("\nDistribution by 'status_summary' field:");
    for (const [summary, count] of Object.entries(statusSummaryCounts)) {
      console.log(`  "${summary}": ${count} leads`);
    }

    console.log(`\nLeads with email_reply_count > 0: ${leadsWithReplies.length}`);
    console.log(`Leads with email_open_count > 0: ${leadsWithOpens.length}`);

    // Show sample lead with replies
    if (leadsWithReplies.length > 0) {
      console.log("\n=== Sample leads WITH REPLIES ===");
      for (const lead of leadsWithReplies.slice(0, 3)) {
        console.log(`\n${lead.email}:`);
        console.log(`  status: ${lead.status}`);
        console.log(`  status_summary: ${lead.status_summary}`);
        console.log(`  email_reply_count: ${lead.email_reply_count}`);
        console.log(`  email_open_count: ${lead.email_open_count}`);
        console.log(`  Full lead data: ${JSON.stringify(lead, null, 2)}`);
      }
    }
  }
}

checkStatusFields().catch(console.error);
</file>

<file path="scripts/compare-instantly-positive-replies.ts">
import { createClient } from "@supabase/supabase-js";

const INSTANTLY_API_KEY = process.env.INSTANTLY_API_KEY;
const BASE_URL = "https://api.instantly.ai";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

async function fetchFromInstantly(endpoint: string, params?: Record<string, string>) {
  const url = new URL(`${BASE_URL}${endpoint}`);
  if (params) {
    Object.entries(params).forEach(([k, v]) => url.searchParams.set(k, v));
  }

  const res = await fetch(url.toString(), {
    headers: { Authorization: `Bearer ${INSTANTLY_API_KEY}` },
  });

  if (!res.ok) {
    throw new Error(`API error: ${res.status} ${await res.text()}`);
  }

  return res.json();
}

async function getPositiveRepliesFromInstantly(campaignId: string): Promise<number> {
  let count = 0;
  let skip = 0;
  const limit = 100;

  while (true) {
    const data = await fetchFromInstantly("/api/v2/leads/list", {
      campaign_id: campaignId,
      limit: String(limit),
      skip: String(skip),
      interest_status: "interested", // This gets positive replies
    });

    const items = data.items || data || [];
    if (items.length === 0) break;

    count += items.length;
    skip += limit;

    if (items.length < limit) break;
  }

  return count;
}

async function comparePositiveReplies() {
  console.log("=== COMPARING POSITIVE REPLIES: INSTANTLY vs DATABASE ===\n");

  // Get campaigns with instantly IDs
  const { data: campaigns } = await supabase
    .from("campaigns")
    .select("id, name, instantly_campaign_id")
    .not("instantly_campaign_id", "is", null);

  for (const campaign of campaigns || []) {
    console.log(`Campaign: ${campaign.name}`);
    console.log(`Instantly ID: ${campaign.instantly_campaign_id}`);

    // Count in our DB
    const { count: dbCount } = await supabase
      .from("leads")
      .select("*", { count: "exact", head: true })
      .eq("campaign_id", campaign.id)
      .eq("is_positive_reply", true);

    console.log(`  DB positive replies: ${dbCount}`);

    // Get analytics from Instantly (which shows interested count)
    try {
      const analytics = await fetchFromInstantly("/api/v2/campaigns/analytics", {
        campaign_id: campaign.instantly_campaign_id!,
      });

      const data = analytics[0] || analytics;
      console.log(`  Instantly analytics:`);
      console.log(`    - total_interested: ${data.total_interested || 0}`);
      console.log(`    - reply_count_unique: ${data.reply_count_unique || 0}`);
      console.log(`    - total_meeting_booked: ${data.total_meeting_booked || 0}`);
      console.log(`    - total_opportunities: ${data.total_opportunities || 0}`);
    } catch (e) {
      console.log(`  Error fetching analytics: ${e}`);
    }

    console.log("");
  }
}

comparePositiveReplies().catch(console.error);
</file>

<file path="scripts/sync-all-leads.ts">
import { createClient } from "@supabase/supabase-js";
import { fetchAllLeadsForCampaign } from "../src/lib/instantly/leads";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

async function syncAllLeads() {
  console.log("Starting full lead sync...\n");

  // Get all clients
  const { data: clients, error: clientsError } = await supabase
    .from("clients")
    .select("id, name");

  if (clientsError) {
    console.error("Failed to fetch clients:", clientsError);
    return;
  }

  console.log(`Found ${clients.length} clients\n`);

  let totalUpdated = 0;
  let totalPositive = 0;

  for (const client of clients) {
    console.log(`\nProcessing client: ${client.name}`);

    // Get all campaigns for this client
    const { data: campaigns, error: campaignsError } = await supabase
      .from("campaigns")
      .select("id, name, instantly_campaign_id")
      .eq("client_id", client.id);

    if (campaignsError || !campaigns) {
      console.error(`  Failed to fetch campaigns:`, campaignsError);
      continue;
    }

    console.log(`  Found ${campaigns.length} campaigns`);

    for (const campaign of campaigns) {
      if (!campaign.instantly_campaign_id) {
        console.log(`  Skipping ${campaign.name} - no Instantly ID`);
        continue;
      }

      console.log(`  Syncing: ${campaign.name}`);

      try {
        const leads = await fetchAllLeadsForCampaign(campaign.instantly_campaign_id);
        console.log(`    Fetched ${leads.length} leads from Instantly`);

        let campaignUpdated = 0;
        let campaignPositive = 0;

        for (const lead of leads) {
          const isPositiveReply = lead.interest_status === "interested";
          if (isPositiveReply) campaignPositive++;

          // Map status
          let status = "contacted";
          if (lead.interest_status === "interested") {
            status = "replied";
          } else if (lead.interest_status === "not_interested") {
            status = "not_interested";
          }

          // Update or insert lead
          const { data: existingLead } = await supabase
            .from("leads")
            .select("id")
            .eq("campaign_id", campaign.id)
            .eq("email", lead.email)
            .single();

          if (existingLead) {
            const { error } = await supabase
              .from("leads")
              .update({
                first_name: lead.first_name || undefined,
                last_name: lead.last_name || undefined,
                company_name: lead.company_name || undefined,
                phone: lead.phone || undefined,
                instantly_lead_id: lead.id,
                is_positive_reply: isPositiveReply,
                status: status,
                client_id: client.id,
                client_name: client.name,
                campaign_name: campaign.name,
                updated_at: new Date().toISOString(),
              })
              .eq("id", existingLead.id);

            if (!error) campaignUpdated++;
          } else {
            const { error } = await supabase.from("leads").insert({
              campaign_id: campaign.id,
              client_id: client.id,
              client_name: client.name,
              campaign_name: campaign.name,
              email: lead.email,
              first_name: lead.first_name || null,
              last_name: lead.last_name || null,
              company_name: lead.company_name || null,
              phone: lead.phone || null,
              status: status,
              is_positive_reply: isPositiveReply,
              instantly_lead_id: lead.id,
            });

            if (!error) campaignUpdated++;
          }
        }

        console.log(`    Updated: ${campaignUpdated}, Positive: ${campaignPositive}`);
        totalUpdated += campaignUpdated;
        totalPositive += campaignPositive;
      } catch (error) {
        console.error(`    Error syncing:`, error);
      }
    }
  }

  console.log(`\n${"=".repeat(50)}`);
  console.log(`SYNC COMPLETE`);
  console.log(`Total leads updated: ${totalUpdated}`);
  console.log(`Total positive replies: ${totalPositive}`);
}

syncAllLeads().catch(console.error);
</file>

<file path="scripts/sync-positive-replies.ts">
import { createClient } from "@supabase/supabase-js";

const INSTANTLY_API_KEY = process.env.INSTANTLY_API_KEY;
const BASE_URL = "https://api.instantly.ai";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

async function postToInstantly(endpoint: string, body: Record<string, unknown>) {
  const url = `${BASE_URL}/api/v2${endpoint}`;

  const res = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${INSTANTLY_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    throw new Error(`API error: ${res.status} ${await res.text()}`);
  }

  return res.json();
}

async function syncPositiveReplies() {
  console.log("=== SYNCING POSITIVE REPLIES FROM INSTANTLY ===\n");
  console.log("Using lt_interest_status field: 1 = positive, 0 = neutral, -1/-2 = negative\n");

  // Get campaigns with instantly IDs
  const { data: campaigns, error: campError } = await supabase
    .from("campaigns")
    .select("id, name, instantly_campaign_id")
    .not("instantly_campaign_id", "is", null);

  if (campError || !campaigns?.length) {
    console.error("Failed to fetch campaigns:", campError);
    return;
  }

  // First, reset ALL leads to is_positive_reply=false
  console.log("Step 1: Resetting all leads to is_positive_reply=false...");
  const { error: resetError } = await supabase
    .from("leads")
    .update({ is_positive_reply: false })
    .eq("is_positive_reply", true);

  if (resetError) {
    console.error("Error resetting leads:", resetError);
  } else {
    console.log("All leads reset to is_positive_reply=false\n");
  }

  let totalPositive = 0;
  let totalUpdated = 0;
  let totalNotFound = 0;

  for (const campaign of campaigns) {
    console.log(`\n=== Processing: ${campaign.name} ===`);
    console.log(`Instantly ID: ${campaign.instantly_campaign_id}`);

    // Fetch ALL leads from Instantly for this campaign
    let allInstantlyLeads: any[] = [];
    let skip = 0;
    const limit = 100;

    while (true) {
      try {
        const data = await postToInstantly("/leads/list", {
          campaign: campaign.instantly_campaign_id,
          limit,
          skip,
        });

        const items = data.items || data || [];
        if (items.length === 0) break;

        allInstantlyLeads.push(...items);
        skip += limit;

        if (skip % 1000 === 0) {
          console.log(`  Fetched ${allInstantlyLeads.length} leads from Instantly...`);
        }

        if (items.length < limit) break;
      } catch (e) {
        console.error(`  Error fetching leads at skip=${skip}:`, e);
        break;
      }
    }

    console.log(`  Total leads from Instantly: ${allInstantlyLeads.length}`);

    // Find leads with lt_interest_status === 1 (positive)
    const positiveLeads = allInstantlyLeads.filter(lead => lead.lt_interest_status === 1);
    console.log(`  Positive leads (lt_interest_status=1): ${positiveLeads.length}`);

    totalPositive += positiveLeads.length;

    if (positiveLeads.length === 0) {
      console.log("  No positive leads to update for this campaign.");
      continue;
    }

    // Get positive lead emails
    const positiveEmails = positiveLeads.map(lead => lead.email);

    // Update in batches of 100
    const batchSize = 100;
    let campaignUpdated = 0;

    for (let i = 0; i < positiveEmails.length; i += batchSize) {
      const batch = positiveEmails.slice(i, i + batchSize);

      const { data: updated, error } = await supabase
        .from("leads")
        .update({ is_positive_reply: true })
        .eq("campaign_id", campaign.id)
        .in("email", batch)
        .select("id");

      if (error) {
        console.error(`  Error updating batch:`, error.message);
      } else if (updated) {
        campaignUpdated += updated.length;
      }
    }

    const notFoundCount = positiveLeads.length - campaignUpdated;
    console.log(`  Updated to positive: ${campaignUpdated}`);
    console.log(`  Not found in DB: ${notFoundCount}`);

    totalUpdated += campaignUpdated;
    totalNotFound += notFoundCount;
  }

  console.log("\n=== SYNC COMPLETE ===");
  console.log(`Total positive leads in Instantly: ${totalPositive}`);
  console.log(`Total updated in DB: ${totalUpdated}`);
  console.log(`Total not found in DB: ${totalNotFound}`);

  // Final verification
  const { count: dbPositiveCount } = await supabase
    .from("leads")
    .select("*", { count: "exact", head: true })
    .eq("is_positive_reply", true);

  console.log(`\nFinal DB count of is_positive_reply=true: ${dbPositiveCount}`);

  // Show breakdown by campaign
  console.log("\n=== BREAKDOWN BY CAMPAIGN ===");
  for (const campaign of campaigns) {
    const { count } = await supabase
      .from("leads")
      .select("*", { count: "exact", head: true })
      .eq("campaign_id", campaign.id)
      .eq("is_positive_reply", true);

    console.log(`${campaign.name}: ${count} positive leads`);
  }
}

syncPositiveReplies().catch(console.error);
</file>

<file path="scripts/verify-positive-replies.ts">
import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

async function verify() {
  console.log("=== POSITIVE REPLY VERIFICATION ===\n");

  // 1. Get total positive replies in DB
  const { count: totalPositive } = await supabase
    .from("leads")
    .select("*", { count: "exact", head: true })
    .eq("is_positive_reply", true);

  console.log("Total leads with is_positive_reply=true:", totalPositive);

  // 2. Get total leads in DB
  const { count: totalLeads } = await supabase
    .from("leads")
    .select("*", { count: "exact", head: true });

  console.log("Total leads in database:", totalLeads);

  // 3. Get breakdown by campaign
  const { data: campaigns } = await supabase
    .from("campaigns")
    .select("id, name, instantly_campaign_id")
    .not("instantly_campaign_id", "is", null);

  console.log("\n=== POSITIVE REPLIES BY CAMPAIGN ===\n");

  for (const campaign of campaigns || []) {
    const { count: positiveCount } = await supabase
      .from("leads")
      .select("*", { count: "exact", head: true })
      .eq("campaign_id", campaign.id)
      .eq("is_positive_reply", true);

    const { count: totalCampaignLeads } = await supabase
      .from("leads")
      .select("*", { count: "exact", head: true })
      .eq("campaign_id", campaign.id);

    console.log(campaign.name + ":");
    console.log("  Total leads:", totalCampaignLeads);
    console.log("  Positive replies:", positiveCount);
    console.log("");
  }

  // 4. Sample positive reply leads
  console.log("=== SAMPLE POSITIVE REPLY LEADS ===\n");
  const { data: sampleLeads } = await supabase
    .from("leads")
    .select("email, status, is_positive_reply")
    .eq("is_positive_reply", true)
    .limit(10);

  for (const lead of sampleLeads || []) {
    console.log(lead.email, "- status:", lead.status);
  }
}

verify().catch(console.error);
</file>

<file path="src/app/(marketing)/features/page.tsx">
import Link from "next/link";

export default function FeaturesPage() {
  return (
    <>
      {/* Hero Section */}
      <section className="relative overflow-hidden py-20 lg:py-28">
        {/* Background */}
        <div className="absolute inset-0 bg-gradient-to-br from-[#050508] via-[#0a1628] to-[#050508]" />
        <div className="absolute top-0 right-0 w-[500px] h-[500px] bg-blue-600/15 rounded-full blur-[150px]" />

        <div className="relative max-w-7xl mx-auto px-6 lg:px-8">
          <div className="max-w-3xl">
            <div className="inline-flex items-center gap-2 px-4 py-2 bg-blue-500/10 border border-blue-500/20 rounded-full mb-6">
              <span className="text-sm text-blue-300 font-medium">Features</span>
            </div>
            <h1 className="text-4xl lg:text-5xl font-bold leading-tight mb-6">
              Everything your agency needs to{" "}
              <span className="text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-cyan-400">
                scale
              </span>
            </h1>
            <p className="text-xl text-zinc-400 leading-relaxed">
              From client portals to analytics, Blue Reach gives you the tools to manage more clients with less effort.
            </p>
          </div>
        </div>
      </section>

      {/* Client Portals Feature */}
      <section className="py-20 lg:py-28 border-b border-white/5">
        <div className="max-w-7xl mx-auto px-6 lg:px-8">
          <div className="grid lg:grid-cols-2 gap-12 lg:gap-20 items-center">
            <div>
              <div className="inline-flex items-center gap-2 px-3 py-1.5 bg-blue-500/10 border border-blue-500/20 rounded-full mb-4">
                <div className="w-2 h-2 bg-blue-400 rounded-full" />
                <span className="text-xs text-blue-300 font-medium uppercase tracking-wider">Client Portals</span>
              </div>
              <h2 className="text-3xl lg:text-4xl font-bold mb-6">
                Give each client their own dashboard
              </h2>
              <p className="text-lg text-zinc-400 mb-8 leading-relaxed">
                Stop sending weekly reports. Give your clients 24/7 access to their campaign data with branded dashboards that make you look professional.
              </p>
              <ul className="space-y-4">
                {[
                  "White-label with your logo and colors",
                  "Custom domain support (reports.youragency.com)",
                  "Role-based access for client teams",
                  "Manage unlimited clients from one account",
                ].map((item, i) => (
                  <li key={i} className="flex items-start gap-3">
                    <svg className="w-5 h-5 text-emerald-400 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                    </svg>
                    <span className="text-zinc-300">{item}</span>
                  </li>
                ))}
              </ul>
            </div>
            <div className="relative">
              <div className="aspect-[4/3] rounded-2xl bg-gradient-to-br from-zinc-800/50 to-zinc-900/50 border border-white/5 p-6 overflow-hidden">
                {/* Mock dashboard UI */}
                <div className="space-y-4">
                  <div className="flex items-center gap-3 mb-6">
                    <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-cyan-400 rounded-xl" />
                    <div>
                      <div className="h-3 w-24 bg-white/10 rounded" />
                      <div className="h-2 w-16 bg-white/5 rounded mt-1.5" />
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-3">
                    {[
                      { label: "Sent", value: "12,847" },
                      { label: "Opened", value: "4,291" },
                      { label: "Replied", value: "342" },
                    ].map((stat, i) => (
                      <div key={i} className="p-3 rounded-xl bg-white/5">
                        <div className="text-xs text-zinc-500 mb-1">{stat.label}</div>
                        <div className="text-lg font-semibold text-white">{stat.value}</div>
                      </div>
                    ))}
                  </div>
                  <div className="h-24 rounded-xl bg-white/5 flex items-end gap-1 p-3">
                    {[40, 65, 45, 80, 55, 90, 70, 85, 60, 95, 75, 88].map((h, i) => (
                      <div
                        key={i}
                        className="flex-1 bg-gradient-to-t from-blue-500 to-cyan-400 rounded-t opacity-60"
                        style={{ height: `${h}%` }}
                      />
                    ))}
                  </div>
                </div>
              </div>
              {/* Decorative glow */}
              <div className="absolute -inset-4 bg-blue-500/10 rounded-3xl blur-2xl -z-10" />
            </div>
          </div>
        </div>
      </section>

      {/* Analytics Feature */}
      <section className="py-20 lg:py-28 border-b border-white/5 bg-zinc-900/20">
        <div className="max-w-7xl mx-auto px-6 lg:px-8">
          <div className="grid lg:grid-cols-2 gap-12 lg:gap-20 items-center">
            <div className="order-2 lg:order-1 relative">
              <div className="aspect-[4/3] rounded-2xl bg-gradient-to-br from-zinc-800/50 to-zinc-900/50 border border-white/5 p-6 overflow-hidden">
                {/* Mock analytics UI */}
                <div className="space-y-4">
                  <div className="flex items-center justify-between mb-4">
                    <div className="h-3 w-32 bg-white/10 rounded" />
                    <div className="flex gap-2">
                      {["7D", "30D", "90D"].map((period, i) => (
                        <div
                          key={period}
                          className={`px-2 py-1 text-xs rounded ${i === 1 ? "bg-blue-500/20 text-blue-300" : "text-zinc-500"}`}
                        >
                          {period}
                        </div>
                      ))}
                    </div>
                  </div>
                  <div className="grid grid-cols-2 gap-3">
                    {[
                      { label: "Open Rate", value: "33.4%", trend: "+2.1%" },
                      { label: "Reply Rate", value: "2.66%", trend: "+0.3%" },
                      { label: "Meetings", value: "47", trend: "+12" },
                      { label: "Pipeline", value: "$124k", trend: "+$18k" },
                    ].map((metric, i) => (
                      <div key={i} className="p-3 rounded-xl bg-white/5">
                        <div className="text-xs text-zinc-500 mb-1">{metric.label}</div>
                        <div className="flex items-baseline gap-2">
                          <span className="text-lg font-semibold text-white">{metric.value}</span>
                          <span className="text-xs text-emerald-400">{metric.trend}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                  <div className="flex gap-2 mt-4">
                    {["Instantly", "Smartlead"].map((provider, i) => (
                      <div key={i} className="flex-1 p-2 rounded-lg bg-white/5 flex items-center gap-2">
                        <div className={`w-2 h-2 rounded-full ${i === 0 ? "bg-blue-400" : "bg-emerald-400"}`} />
                        <span className="text-xs text-zinc-400">{provider}</span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
              <div className="absolute -inset-4 bg-cyan-500/10 rounded-3xl blur-2xl -z-10" />
            </div>
            <div className="order-1 lg:order-2">
              <div className="inline-flex items-center gap-2 px-3 py-1.5 bg-cyan-500/10 border border-cyan-500/20 rounded-full mb-4">
                <div className="w-2 h-2 bg-cyan-400 rounded-full" />
                <span className="text-xs text-cyan-300 font-medium uppercase tracking-wider">Analytics</span>
              </div>
              <h2 className="text-3xl lg:text-4xl font-bold mb-6">
                Real-time campaign insights
              </h2>
              <p className="text-lg text-zinc-400 mb-8 leading-relaxed">
                See exactly how campaigns are performing with real-time analytics. Track opens, replies, meetings booked, and revenue generated.
              </p>
              <ul className="space-y-4">
                {[
                  "Live data synced from Instantly & Smartlead",
                  "Open rates, reply rates, and conversion tracking",
                  "Meeting and pipeline attribution",
                  "Historical trends and comparison reports",
                ].map((item, i) => (
                  <li key={i} className="flex items-start gap-3">
                    <svg className="w-5 h-5 text-emerald-400 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                    </svg>
                    <span className="text-zinc-300">{item}</span>
                  </li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      </section>

      {/* Lead Management Feature */}
      <section className="py-20 lg:py-28 border-b border-white/5">
        <div className="max-w-7xl mx-auto px-6 lg:px-8">
          <div className="grid lg:grid-cols-2 gap-12 lg:gap-20 items-center">
            <div>
              <div className="inline-flex items-center gap-2 px-3 py-1.5 bg-emerald-500/10 border border-emerald-500/20 rounded-full mb-4">
                <div className="w-2 h-2 bg-emerald-400 rounded-full" />
                <span className="text-xs text-emerald-300 font-medium uppercase tracking-wider">Lead Management</span>
              </div>
              <h2 className="text-3xl lg:text-4xl font-bold mb-6">
                Move leads through your pipeline
              </h2>
              <p className="text-lg text-zinc-400 mb-8 leading-relaxed">
                Track every lead from first contact to closed deal. Our visual pipeline makes it easy to see where every opportunity stands.
              </p>
              <ul className="space-y-4">
                {[
                  "Visual Kanban-style lead workflow",
                  "Custom status stages that match your process",
                  "Meeting scheduling and outcome tracking",
                  "Notes, activities, and full email history",
                ].map((item, i) => (
                  <li key={i} className="flex items-start gap-3">
                    <svg className="w-5 h-5 text-emerald-400 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                    </svg>
                    <span className="text-zinc-300">{item}</span>
                  </li>
                ))}
              </ul>
            </div>
            <div className="relative">
              <div className="aspect-[4/3] rounded-2xl bg-gradient-to-br from-zinc-800/50 to-zinc-900/50 border border-white/5 p-6 overflow-hidden">
                {/* Mock pipeline UI */}
                <div className="flex gap-3 h-full">
                  {[
                    { status: "Replied", color: "blue", count: 24 },
                    { status: "Meeting", color: "amber", count: 8 },
                    { status: "Won", color: "emerald", count: 12 },
                  ].map((column, i) => (
                    <div key={i} className="flex-1 flex flex-col">
                      <div className="flex items-center justify-between mb-3">
                        <div className="flex items-center gap-2">
                          <div className={`w-2 h-2 rounded-full bg-${column.color}-400`} />
                          <span className="text-xs text-zinc-400">{column.status}</span>
                        </div>
                        <span className="text-xs text-zinc-500">{column.count}</span>
                      </div>
                      <div className="flex-1 space-y-2">
                        {[...Array(3)].map((_, j) => (
                          <div key={j} className="p-2 rounded-lg bg-white/5">
                            <div className="h-2 w-16 bg-white/10 rounded mb-1.5" />
                            <div className="h-1.5 w-12 bg-white/5 rounded" />
                          </div>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
              <div className="absolute -inset-4 bg-emerald-500/10 rounded-3xl blur-2xl -z-10" />
            </div>
          </div>
        </div>
      </section>

      {/* Additional Features Grid */}
      <section className="py-20 lg:py-28 bg-zinc-900/20">
        <div className="max-w-7xl mx-auto px-6 lg:px-8">
          <div className="text-center mb-16">
            <h2 className="text-3xl lg:text-4xl font-bold mb-4">
              And so much more
            </h2>
            <p className="text-lg text-zinc-400 max-w-2xl mx-auto">
              Blue Reach is packed with features to help you run a more efficient agency.
            </p>
          </div>

          <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-6">
            {[
              {
                icon: "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z",
                title: "Email Provider Sync",
                description: "Connect Instantly, Smartlead, Apollo, and more. All your data in one unified dashboard.",
              },
              {
                icon: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z",
                title: "Secure & Private",
                description: "Your data stays yours. Row-level security ensures clients only see their own campaigns.",
              },
              {
                icon: "M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9",
                title: "Smart Notifications",
                description: "Get instant alerts when leads reply or book meetings. Never miss an opportunity.",
              },
              {
                icon: "M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z",
                title: "Custom Workflows",
                description: "Define your own lead stages that match your exact process. Flexibility built in.",
              },
              {
                icon: "M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z",
                title: "Export & Reports",
                description: "Download data as CSV for custom analysis. Generate reports for client reviews.",
              },
              {
                icon: "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0z",
                title: "Team Collaboration",
                description: "Invite your team members with role-based permissions. Scale without chaos.",
              },
            ].map((feature, i) => (
              <div
                key={i}
                className="p-6 rounded-2xl bg-white/[0.02] border border-white/5 hover:border-white/10 hover:bg-white/[0.04] transition-all group"
              >
                <div className="w-11 h-11 rounded-xl bg-gradient-to-br from-blue-500/20 to-cyan-500/10 flex items-center justify-center mb-4 group-hover:scale-110 transition-transform">
                  <svg className="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d={feature.icon} />
                  </svg>
                </div>
                <h3 className="text-lg font-semibold mb-2">{feature.title}</h3>
                <p className="text-sm text-zinc-400 leading-relaxed">{feature.description}</p>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="py-20 lg:py-28 relative overflow-hidden">
        <div className="absolute inset-0 bg-gradient-to-br from-blue-600/20 via-transparent to-cyan-600/20" />

        <div className="relative max-w-4xl mx-auto px-6 lg:px-8 text-center">
          <h2 className="text-3xl lg:text-4xl font-bold mb-6">
            Ready to see Blue Reach in action?
          </h2>
          <p className="text-xl text-zinc-400 mb-10 max-w-2xl mx-auto">
            Start your free 14-day trial. No credit card required.
          </p>
          <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
            <Link
              href="/login"
              className="w-full sm:w-auto px-8 py-4 bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white font-semibold rounded-xl transition-all shadow-xl shadow-blue-500/25 hover:shadow-blue-500/40 hover:-translate-y-0.5 text-center"
            >
              Start Free Trial
            </Link>
            <Link
              href="/pricing"
              className="w-full sm:w-auto px-8 py-4 bg-white/5 hover:bg-white/10 border border-white/10 text-white font-semibold rounded-xl transition-all text-center"
            >
              View Pricing
            </Link>
          </div>
        </div>
      </section>
    </>
  );
}
</file>

<file path="src/app/(marketing)/pricing/page.tsx">
import Link from "next/link";

export default function PricingPage() {
  const plans = [
    {
      name: "Starter",
      description: "Perfect for small agencies getting started",
      price: 49,
      period: "/month",
      features: [
        "Up to 3 clients",
        "Instantly integration",
        "Client portal access",
        "Basic analytics",
        "Email support",
      ],
      cta: "Start Free Trial",
      popular: false,
    },
    {
      name: "Growth",
      description: "For growing agencies with more clients",
      price: 99,
      period: "/month",
      features: [
        "Up to 10 clients",
        "Instantly + Smartlead integration",
        "White-label client portals",
        "Advanced analytics & reports",
        "Custom domain support",
        "Priority email support",
        "Team collaboration (3 seats)",
      ],
      cta: "Start Free Trial",
      popular: true,
    },
    {
      name: "Agency",
      description: "For established agencies at scale",
      price: 249,
      period: "/month",
      features: [
        "Unlimited clients",
        "All provider integrations",
        "White-label everything",
        "Advanced analytics & API access",
        "Custom domain + SSL",
        "Dedicated support",
        "Unlimited team seats",
        "Custom onboarding",
      ],
      cta: "Start Free Trial",
      popular: false,
    },
  ];

  const faqs = [
    {
      question: "What happens after my 14-day trial?",
      answer: "After your trial ends, you can choose a plan that fits your needs. If you don't upgrade, your account will be paused but your data will be saved for 30 days.",
    },
    {
      question: "Can I change plans later?",
      answer: "Yes, you can upgrade or downgrade your plan at any time. Changes take effect on your next billing cycle, and we'll prorate any differences.",
    },
    {
      question: "What integrations are supported?",
      answer: "We currently support Instantly, Smartlead, and Apollo. More integrations are coming soon. All plans include at least one integration.",
    },
    {
      question: "Is there a setup fee?",
      answer: "No setup fees. Just sign up, connect your email tools, and you're ready to go. Our Agency plan includes complimentary onboarding support.",
    },
    {
      question: "Do you offer annual billing?",
      answer: "Yes! Pay annually and get 2 months free. That's a 17% discount on all plans. Contact us after signing up to switch to annual billing.",
    },
    {
      question: "What if I need more than what's listed?",
      answer: "We offer custom Enterprise plans for large agencies with specific requirements. Contact us to discuss your needs.",
    },
  ];

  return (
    <>
      {/* Hero Section */}
      <section className="relative overflow-hidden py-20 lg:py-28">
        <div className="absolute inset-0 bg-gradient-to-br from-[#050508] via-[#0a1628] to-[#050508]" />
        <div className="absolute top-20 left-1/2 -translate-x-1/2 w-[800px] h-[400px] bg-blue-600/15 rounded-full blur-[150px]" />

        <div className="relative max-w-7xl mx-auto px-6 lg:px-8 text-center">
          <div className="inline-flex items-center gap-2 px-4 py-2 bg-blue-500/10 border border-blue-500/20 rounded-full mb-6">
            <span className="text-sm text-blue-300 font-medium">Simple, transparent pricing</span>
          </div>
          <h1 className="text-4xl lg:text-5xl font-bold leading-tight mb-6">
            Plans that scale with your agency
          </h1>
          <p className="text-xl text-zinc-400 max-w-2xl mx-auto">
            Start free for 14 days. No credit card required. Upgrade when you&apos;re ready.
          </p>
        </div>
      </section>

      {/* Pricing Cards */}
      <section className="py-8 lg:py-12">
        <div className="max-w-7xl mx-auto px-6 lg:px-8">
          <div className="grid md:grid-cols-3 gap-8 lg:gap-6">
            {plans.map((plan, i) => (
              <div
                key={i}
                className={`relative rounded-2xl p-8 ${
                  plan.popular
                    ? "bg-gradient-to-b from-blue-500/10 to-transparent border-2 border-blue-500/30"
                    : "bg-white/[0.02] border border-white/5"
                }`}
              >
                {plan.popular && (
                  <div className="absolute -top-4 left-1/2 -translate-x-1/2">
                    <div className="px-4 py-1.5 bg-gradient-to-r from-blue-500 to-cyan-500 rounded-full text-xs font-semibold text-white shadow-lg shadow-blue-500/30">
                      Most Popular
                    </div>
                  </div>
                )}

                <div className="mb-6">
                  <h3 className="text-xl font-bold mb-2">{plan.name}</h3>
                  <p className="text-sm text-zinc-400">{plan.description}</p>
                </div>

                <div className="mb-8">
                  <div className="flex items-baseline gap-1">
                    <span className="text-4xl font-bold">${plan.price}</span>
                    <span className="text-zinc-500">{plan.period}</span>
                  </div>
                </div>

                <ul className="space-y-4 mb-8">
                  {plan.features.map((feature, j) => (
                    <li key={j} className="flex items-start gap-3">
                      <svg
                        className={`w-5 h-5 mt-0.5 flex-shrink-0 ${
                          plan.popular ? "text-blue-400" : "text-emerald-400"
                        }`}
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                      >
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                      </svg>
                      <span className="text-sm text-zinc-300">{feature}</span>
                    </li>
                  ))}
                </ul>

                <Link
                  href="/login"
                  className={`block w-full py-3 rounded-xl font-semibold text-center transition-all ${
                    plan.popular
                      ? "bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white shadow-lg shadow-blue-500/25 hover:shadow-blue-500/40 hover:-translate-y-0.5"
                      : "bg-white/5 hover:bg-white/10 border border-white/10 text-white"
                  }`}
                >
                  {plan.cta}
                </Link>
              </div>
            ))}
          </div>

          {/* Enterprise callout */}
          <div className="mt-12 p-8 rounded-2xl bg-gradient-to-r from-zinc-900/50 to-zinc-800/30 border border-white/5">
            <div className="flex flex-col lg:flex-row items-center justify-between gap-6">
              <div>
                <h3 className="text-xl font-bold mb-2">Need something custom?</h3>
                <p className="text-zinc-400">
                  Enterprise plans with custom integrations, SLA guarantees, and dedicated support.
                </p>
              </div>
              <a
                href="mailto:hello@blue-reach.com"
                className="flex-shrink-0 px-6 py-3 bg-white/5 hover:bg-white/10 border border-white/10 rounded-xl font-semibold text-white transition-all"
              >
                Contact Sales
              </a>
            </div>
          </div>
        </div>
      </section>

      {/* Feature Comparison */}
      <section className="py-20 lg:py-28 bg-zinc-900/20">
        <div className="max-w-7xl mx-auto px-6 lg:px-8">
          <div className="text-center mb-12">
            <h2 className="text-2xl lg:text-3xl font-bold mb-4">Compare plans</h2>
            <p className="text-zinc-400">See what&apos;s included in each plan</p>
          </div>

          <div className="overflow-x-auto">
            <table className="w-full min-w-[600px]">
              <thead>
                <tr className="border-b border-white/10">
                  <th className="text-left py-4 px-4 text-sm font-medium text-zinc-400">Feature</th>
                  <th className="text-center py-4 px-4 text-sm font-medium text-zinc-400">Starter</th>
                  <th className="text-center py-4 px-4 text-sm font-medium text-blue-400">Growth</th>
                  <th className="text-center py-4 px-4 text-sm font-medium text-zinc-400">Agency</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-white/5">
                {[
                  { feature: "Clients", starter: "3", growth: "10", agency: "Unlimited" },
                  { feature: "Team seats", starter: "1", growth: "3", agency: "Unlimited" },
                  { feature: "Instantly integration", starter: true, growth: true, agency: true },
                  { feature: "Smartlead integration", starter: false, growth: true, agency: true },
                  { feature: "Apollo integration", starter: false, growth: false, agency: true },
                  { feature: "Client portals", starter: true, growth: true, agency: true },
                  { feature: "White-label branding", starter: false, growth: true, agency: true },
                  { feature: "Custom domain", starter: false, growth: true, agency: true },
                  { feature: "Advanced analytics", starter: false, growth: true, agency: true },
                  { feature: "API access", starter: false, growth: false, agency: true },
                  { feature: "Priority support", starter: false, growth: true, agency: true },
                  { feature: "Custom onboarding", starter: false, growth: false, agency: true },
                ].map((row, i) => (
                  <tr key={i}>
                    <td className="py-4 px-4 text-sm text-zinc-300">{row.feature}</td>
                    {[row.starter, row.growth, row.agency].map((value, j) => (
                      <td key={j} className="py-4 px-4 text-center">
                        {typeof value === "boolean" ? (
                          value ? (
                            <svg className="w-5 h-5 text-emerald-400 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                            </svg>
                          ) : (
                            <svg className="w-5 h-5 text-zinc-600 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                            </svg>
                          )
                        ) : (
                          <span className="text-sm text-zinc-300">{value}</span>
                        )}
                      </td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      </section>

      {/* FAQ Section */}
      <section className="py-20 lg:py-28">
        <div className="max-w-3xl mx-auto px-6 lg:px-8">
          <div className="text-center mb-12">
            <h2 className="text-2xl lg:text-3xl font-bold mb-4">Frequently asked questions</h2>
            <p className="text-zinc-400">Everything you need to know about pricing</p>
          </div>

          <div className="space-y-4">
            {faqs.map((faq, i) => (
              <div
                key={i}
                className="p-6 rounded-2xl bg-white/[0.02] border border-white/5"
              >
                <h3 className="font-semibold mb-2">{faq.question}</h3>
                <p className="text-sm text-zinc-400 leading-relaxed">{faq.answer}</p>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="py-20 lg:py-28 relative overflow-hidden bg-zinc-900/30">
        <div className="absolute inset-0 bg-gradient-to-br from-blue-600/10 via-transparent to-cyan-600/10" />

        <div className="relative max-w-4xl mx-auto px-6 lg:px-8 text-center">
          <h2 className="text-3xl lg:text-4xl font-bold mb-6">
            Start your free trial today
          </h2>
          <p className="text-xl text-zinc-400 mb-10 max-w-2xl mx-auto">
            14 days free. No credit card required. Cancel anytime.
          </p>
          <Link
            href="/login"
            className="inline-flex px-8 py-4 bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white font-semibold rounded-xl transition-all shadow-xl shadow-blue-500/25 hover:shadow-blue-500/40 hover:-translate-y-0.5"
          >
            Get Started Free
          </Link>
        </div>
      </section>
    </>
  );
}
</file>

<file path="src/app/(marketing)/layout.tsx">
import { MarketingHeader } from "@/components/marketing/header";
import { MarketingFooter } from "@/components/marketing/footer";

export default function MarketingLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen bg-[#050508] text-white">
      <MarketingHeader />
      <main className="pt-16 lg:pt-20">
        {children}
      </main>
      <MarketingFooter />
    </div>
  );
}
</file>

<file path="src/app/admin/clients/page.tsx">
import { createClient } from "@/lib/supabase/server";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import Link from "next/link";
import { AddClientDialog } from "./add-client-dialog";

export default async function ClientsPage() {
  const supabase = await createClient();

  const { data: clients } = await supabase
    .from("clients")
    .select("*, campaigns(count)")
    .order("created_at", { ascending: false });

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Clients</h1>
        <AddClientDialog />
      </div>

      {!clients || clients.length === 0 ? (
        <Card>
          <CardContent className="py-8 text-center text-gray-500">
            <p>No clients yet. Add your first client to get started.</p>
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {clients.map((client) => (
            <Link key={client.id} href={`/admin/clients/${client.id}`}>
              <Card className="hover:shadow-md transition-shadow cursor-pointer">
                <CardHeader>
                  <CardTitle>{client.name}</CardTitle>
                </CardHeader>
                <CardContent>
                  <p className="text-sm text-gray-500">
                    {(client.campaigns as unknown as { count: number }[])?.[0]?.count || 0} campaigns
                  </p>
                  <p className="text-xs text-gray-400 mt-1">
                    Created {new Date(client.created_at).toLocaleDateString()}
                  </p>
                </CardContent>
              </Card>
            </Link>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/infrastructure/infrastructure-view.tsx">
"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Server,
  RefreshCw,
  CheckCircle,
  AlertCircle,
  XCircle,
  Mail,
  Globe,
  Shield,
  Zap,
} from "lucide-react";
import type { EmailAccountWithHealth, DomainSummary, Client } from "@/types/database";

interface InfrastructureStats {
  total_accounts: number;
  by_provider: Record<string, number>;
  by_status: Record<string, number>;
  assigned_accounts: number;
  unassigned_accounts: number;
  avg_warmup_reputation: number;
  domains_count: number;
  domains_checked: number;
  domains_healthy: number;
  domains_issues: number;
}

interface InfrastructureViewProps {
  initialAccounts: EmailAccountWithHealth[];
  initialClients: Client[];
  initialStats: InfrastructureStats;
  initialDomains: DomainSummary[];
  totalAccounts: number;
  currentPage: number;
}

export function InfrastructureView({
  initialAccounts,
  initialClients,
  initialStats,
  initialDomains,
  totalAccounts,
  currentPage,
}: InfrastructureViewProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const hasFetched = useRef(false);

  const [accounts, setAccounts] = useState<EmailAccountWithHealth[]>(initialAccounts);
  const [clients] = useState<Client[]>(initialClients);
  const [stats, setStats] = useState<InfrastructureStats>(initialStats);
  const [domains, setDomains] = useState<DomainSummary[]>(initialDomains);
  const [loading, setLoading] = useState(false);
  const [syncing, setSyncing] = useState(false);
  const [checkingDns, setCheckingDns] = useState(false);

  // Filters
  const [selectedClient, setSelectedClient] = useState(searchParams.get("client") || "all");
  const [selectedProvider, setSelectedProvider] = useState(searchParams.get("provider") || "all");
  const [selectedStatus, setSelectedStatus] = useState(searchParams.get("status") || "all");

  // Dialog state
  const [assignDialogOpen, setAssignDialogOpen] = useState(false);
  const [selectedAccount, setSelectedAccount] = useState<EmailAccountWithHealth | null>(null);
  const [assignClientId, setAssignClientId] = useState<string>("");

  // Last updated
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);

  // Update URL with filters
  const updateFilters = useCallback(
    (updates: { client?: string; provider?: string; status?: string; page?: number }) => {
      const params = new URLSearchParams();

      const newClient = updates.client !== undefined ? updates.client : selectedClient;
      const newProvider = updates.provider !== undefined ? updates.provider : selectedProvider;
      const newStatus = updates.status !== undefined ? updates.status : selectedStatus;
      const newPage = updates.page !== undefined ? updates.page : currentPage;

      if (newClient && newClient !== "all") params.set("client", newClient);
      if (newProvider && newProvider !== "all") params.set("provider", newProvider);
      if (newStatus && newStatus !== "all") params.set("status", newStatus);
      if (newPage > 1) params.set("page", String(newPage));

      const queryString = params.toString();
      router.push(`/admin/infrastructure${queryString ? `?${queryString}` : ""}`);
    },
    [selectedClient, selectedProvider, selectedStatus, currentPage, router]
  );

  // Fetch data
  const fetchData = useCallback(async (force = false) => {
    if (hasFetched.current && !force) return;
    hasFetched.current = true;
    setLoading(true);

    try {
      const [statsRes, domainsRes] = await Promise.all([
        fetch("/api/admin/infrastructure/stats"),
        fetch("/api/admin/infrastructure/dns"),
      ]);

      if (statsRes.ok) {
        const statsData = await statsRes.json();
        setStats(statsData);
      }

      if (domainsRes.ok) {
        const domainsData = await domainsRes.json();
        setDomains(domainsData.domains || []);
      }

      setLastUpdated(new Date());
    } catch (error) {
      console.error("Error fetching data:", error);
    } finally {
      setLoading(false);
    }
  }, []);

  // Sync from providers
  const handleSync = async () => {
    setSyncing(true);
    try {
      const res = await fetch("/api/admin/infrastructure/sync", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ providers: ["instantly", "smartlead"] }),
      });

      if (res.ok) {
        // Refresh page to get new data
        router.refresh();
        hasFetched.current = false;
        await fetchData(true);
      }
    } catch (error) {
      console.error("Sync failed:", error);
    } finally {
      setSyncing(false);
    }
  };

  // Check DNS health
  const handleCheckDns = async () => {
    setCheckingDns(true);
    try {
      const res = await fetch("/api/admin/infrastructure/dns", {
        method: "PATCH",
      });

      if (res.ok) {
        // Refresh domains
        const domainsRes = await fetch("/api/admin/infrastructure/dns");
        if (domainsRes.ok) {
          const data = await domainsRes.json();
          setDomains(data.domains || []);
        }
      }
    } catch (error) {
      console.error("DNS check failed:", error);
    } finally {
      setCheckingDns(false);
    }
  };

  // Assign account to client
  const handleAssignClient = async () => {
    if (!selectedAccount) return;

    try {
      const res = await fetch(`/api/admin/infrastructure/accounts/${selectedAccount.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          client_id: assignClientId === "none" ? null : assignClientId,
        }),
      });

      if (res.ok) {
        // Update local state
        setAccounts((prev) =>
          prev.map((a) =>
            a.id === selectedAccount.id
              ? {
                  ...a,
                  client_id: assignClientId === "none" ? null : assignClientId,
                  client_name:
                    assignClientId === "none"
                      ? null
                      : clients.find((c) => c.id === assignClientId)?.name || null,
                }
              : a
          )
        );
        setAssignDialogOpen(false);
        setSelectedAccount(null);
        setAssignClientId("");
      }
    } catch (error) {
      console.error("Failed to assign client:", error);
    }
  };

  // Auto-refresh every 30 seconds
  useEffect(() => {
    const interval = setInterval(() => {
      hasFetched.current = false;
      fetchData(true);
    }, 30000);

    return () => clearInterval(interval);
  }, [fetchData]);

  // Initial fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Status badge helper
  const getStatusBadge = (status: string) => {
    switch (status) {
      case "active":
        return (
          <Badge variant="default" className="bg-green-500/10 text-green-500 border-green-500/20">
            <CheckCircle className="h-3 w-3 mr-1" />
            Active
          </Badge>
        );
      case "error":
        return (
          <Badge variant="destructive">
            <XCircle className="h-3 w-3 mr-1" />
            Error
          </Badge>
        );
      case "disconnected":
        return (
          <Badge variant="outline" className="text-yellow-500 border-yellow-500/50">
            <AlertCircle className="h-3 w-3 mr-1" />
            Disconnected
          </Badge>
        );
      default:
        return <Badge variant="outline">{status}</Badge>;
    }
  };

  // Reputation badge helper
  const getReputationBadge = (reputation: number | null) => {
    if (reputation === null) return <span className="text-muted-foreground">-</span>;

    if (reputation >= 80) {
      return <Badge className="bg-green-500/10 text-green-500 border-green-500/20">{reputation}%</Badge>;
    } else if (reputation >= 50) {
      return <Badge className="bg-yellow-500/10 text-yellow-500 border-yellow-500/20">{reputation}%</Badge>;
    } else {
      return <Badge className="bg-red-500/10 text-red-500 border-red-500/20">{reputation}%</Badge>;
    }
  };

  // DNS health badge helper
  const getDnsHealthBadge = (score: number | null) => {
    if (score === null) return <span className="text-muted-foreground">Not checked</span>;

    if (score >= 85) {
      return (
        <Badge className="bg-green-500/10 text-green-500 border-green-500/20">
          <Shield className="h-3 w-3 mr-1" />
          {score}
        </Badge>
      );
    } else if (score >= 50) {
      return (
        <Badge className="bg-yellow-500/10 text-yellow-500 border-yellow-500/20">
          <Shield className="h-3 w-3 mr-1" />
          {score}
        </Badge>
      );
    } else {
      return (
        <Badge className="bg-red-500/10 text-red-500 border-red-500/20">
          <Shield className="h-3 w-3 mr-1" />
          {score}
        </Badge>
      );
    }
  };

  return (
    <div className="space-y-6">
      {/* Stats Cards */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Total Accounts</p>
                <p className="text-2xl font-bold">{stats.total_accounts}</p>
              </div>
              <Mail className="h-8 w-8 text-muted-foreground/50" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Active / Healthy</p>
                <p className="text-2xl font-bold text-green-500">
                  {stats.by_status?.active || 0}
                </p>
              </div>
              <CheckCircle className="h-8 w-8 text-green-500/50" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Avg Reputation</p>
                <p className="text-2xl font-bold">{stats.avg_warmup_reputation}%</p>
              </div>
              <Zap className="h-8 w-8 text-muted-foreground/50" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Domains</p>
                <p className="text-2xl font-bold">{stats.domains_count}</p>
                <p className="text-xs text-muted-foreground">
                  {stats.domains_healthy} healthy / {stats.domains_issues} issues
                </p>
              </div>
              <Globe className="h-8 w-8 text-muted-foreground/50" />
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Filters and Actions */}
      <div className="flex flex-wrap items-center gap-4">
        <Select
          value={selectedClient}
          onValueChange={(value) => {
            setSelectedClient(value);
            updateFilters({ client: value });
          }}
        >
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="All Clients" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Clients</SelectItem>
            <SelectItem value="unassigned">Unassigned</SelectItem>
            {clients.map((client) => (
              <SelectItem key={client.id} value={client.id}>
                {client.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>

        <Select
          value={selectedProvider}
          onValueChange={(value) => {
            setSelectedProvider(value);
            updateFilters({ provider: value });
          }}
        >
          <SelectTrigger className="w-[150px]">
            <SelectValue placeholder="All Providers" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Providers</SelectItem>
            <SelectItem value="instantly">Instantly</SelectItem>
            <SelectItem value="smartlead">Smartlead</SelectItem>
          </SelectContent>
        </Select>

        <Select
          value={selectedStatus}
          onValueChange={(value) => {
            setSelectedStatus(value);
            updateFilters({ status: value });
          }}
        >
          <SelectTrigger className="w-[140px]">
            <SelectValue placeholder="All Status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Status</SelectItem>
            <SelectItem value="active">Active</SelectItem>
            <SelectItem value="error">Error</SelectItem>
            <SelectItem value="disconnected">Disconnected</SelectItem>
          </SelectContent>
        </Select>

        <div className="flex-1" />

        <Button variant="outline" onClick={handleCheckDns} disabled={checkingDns}>
          <Shield className={`h-4 w-4 mr-2 ${checkingDns ? "animate-spin" : ""}`} />
          {checkingDns ? "Checking..." : "Check DNS"}
        </Button>

        <Button onClick={handleSync} disabled={syncing}>
          <RefreshCw className={`h-4 w-4 mr-2 ${syncing ? "animate-spin" : ""}`} />
          {syncing ? "Syncing..." : "Sync Accounts"}
        </Button>
      </div>

      {/* Last Updated */}
      {lastUpdated && (
        <p className="text-xs text-muted-foreground">
          Last updated: {lastUpdated.toLocaleTimeString()}
        </p>
      )}

      {/* Email Accounts Table */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Server className="h-5 w-5" />
            Email Accounts ({accounts.length} of {totalAccounts})
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Email</TableHead>
                <TableHead>Client</TableHead>
                <TableHead>Provider</TableHead>
                <TableHead>Status</TableHead>
                <TableHead>Warmup</TableHead>
                <TableHead>Reputation</TableHead>
                <TableHead>DNS</TableHead>
                <TableHead>Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {accounts.map((account) => (
                <TableRow key={account.id}>
                  <TableCell className="font-medium">{account.email}</TableCell>
                  <TableCell>
                    {account.client_name || (
                      <span className="text-muted-foreground italic">Unassigned</span>
                    )}
                  </TableCell>
                  <TableCell>
                    <Badge variant="outline" className="capitalize">
                      {account.provider_type}
                    </Badge>
                  </TableCell>
                  <TableCell>{getStatusBadge(account.status)}</TableCell>
                  <TableCell>
                    {account.warmup_enabled ? (
                      <Badge className="bg-green-500/10 text-green-500 border-green-500/20">
                        On
                      </Badge>
                    ) : (
                      <Badge variant="outline">Off</Badge>
                    )}
                  </TableCell>
                  <TableCell>{getReputationBadge(account.warmup_reputation)}</TableCell>
                  <TableCell>{getDnsHealthBadge(account.domain_health_score)}</TableCell>
                  <TableCell>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => {
                        setSelectedAccount(account);
                        setAssignClientId(account.client_id || "none");
                        setAssignDialogOpen(true);
                      }}
                    >
                      Assign
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
              {accounts.length === 0 && (
                <TableRow>
                  <TableCell colSpan={8} className="text-center text-muted-foreground py-8">
                    No accounts found. Click &quot;Sync Accounts&quot; to import from Instantly/Smartlead.
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>

      {/* Domain Health Section */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Globe className="h-5 w-5" />
            Domain Health ({domains.length} domains)
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Domain</TableHead>
                <TableHead>Accounts</TableHead>
                <TableHead>SPF</TableHead>
                <TableHead>DKIM</TableHead>
                <TableHead>DMARC</TableHead>
                <TableHead>Score</TableHead>
                <TableHead>Last Checked</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {domains.map((domain) => (
                <TableRow key={domain.id}>
                  <TableCell className="font-medium">{domain.domain}</TableCell>
                  <TableCell>{domain.account_count}</TableCell>
                  <TableCell>
                    {domain.spf_valid ? (
                      <CheckCircle className="h-4 w-4 text-green-500" />
                    ) : domain.has_spf ? (
                      <AlertCircle className="h-4 w-4 text-yellow-500" />
                    ) : (
                      <XCircle className="h-4 w-4 text-red-500" />
                    )}
                  </TableCell>
                  <TableCell>
                    {domain.dkim_valid ? (
                      <CheckCircle className="h-4 w-4 text-green-500" />
                    ) : domain.has_dkim ? (
                      <AlertCircle className="h-4 w-4 text-yellow-500" />
                    ) : (
                      <XCircle className="h-4 w-4 text-red-500" />
                    )}
                  </TableCell>
                  <TableCell>
                    {domain.dmarc_valid ? (
                      <div className="flex items-center gap-1">
                        <CheckCircle className="h-4 w-4 text-green-500" />
                        {domain.dmarc_policy && (
                          <span className="text-xs text-muted-foreground">
                            ({domain.dmarc_policy})
                          </span>
                        )}
                      </div>
                    ) : domain.has_dmarc ? (
                      <AlertCircle className="h-4 w-4 text-yellow-500" />
                    ) : (
                      <XCircle className="h-4 w-4 text-red-500" />
                    )}
                  </TableCell>
                  <TableCell>{getDnsHealthBadge(domain.health_score)}</TableCell>
                  <TableCell>
                    {domain.last_checked_at ? (
                      <span className="text-sm text-muted-foreground">
                        {new Date(domain.last_checked_at).toLocaleDateString()}
                      </span>
                    ) : (
                      <span className="text-muted-foreground">Never</span>
                    )}
                  </TableCell>
                </TableRow>
              ))}
              {domains.length === 0 && (
                <TableRow>
                  <TableCell colSpan={7} className="text-center text-muted-foreground py-8">
                    No domains checked yet. Click &quot;Check DNS&quot; to validate domain health.
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>

      {/* Assign Client Dialog */}
      <Dialog open={assignDialogOpen} onOpenChange={setAssignDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Assign Account to Client</DialogTitle>
          </DialogHeader>
          <div className="py-4">
            <p className="text-sm text-muted-foreground mb-4">
              Assign <strong>{selectedAccount?.email}</strong> to a client:
            </p>
            <Select value={assignClientId} onValueChange={setAssignClientId}>
              <SelectTrigger>
                <SelectValue placeholder="Select a client" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="none">No Client (Unassigned)</SelectItem>
                {clients.map((client) => (
                  <SelectItem key={client.id} value={client.id}>
                    {client.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setAssignDialogOpen(false)}>
              Cancel
            </Button>
            <Button onClick={handleAssignClient}>Save</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
</file>

<file path="src/app/admin/instantly/accounts/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import Link from "next/link";
import { RefreshCw, ArrowLeft, Flame, FlameKindling, AlertCircle } from "lucide-react";

interface Account {
  email: string;
  first_name?: string;
  last_name?: string;
  provider?: string;
  warmup_status?: string;
  daily_limit?: number;
  status?: string;
  error_message?: string;
  warmup?: {
    reputation: number;
    warmup_emails_sent: number;
    warmup_emails_received: number;
  };
}

export default function InstantlyAccountsPage() {
  const [accounts, setAccounts] = useState<Account[]>([]);
  const [loading, setLoading] = useState(true);
  const [actionLoading, setActionLoading] = useState<string | null>(null);

  const fetchAccounts = async () => {
    setLoading(true);
    try {
      const response = await fetch("/api/instantly/accounts");
      const data = await response.json();
      setAccounts(data.accounts || []);
    } catch (error) {
      console.error("Error fetching accounts:", error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchAccounts();
  }, []);

  const handleWarmupToggle = async (email: string, enable: boolean) => {
    setActionLoading(email);
    try {
      const response = await fetch("/api/instantly/accounts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          action: enable ? "enable_warmup" : "disable_warmup",
          emails: [email],
        }),
      });
      const data = await response.json();
      if (data.success) {
        fetchAccounts();
      } else {
        alert(`Failed: ${data.error}`);
      }
    } catch (error) {
      alert(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    } finally {
      setActionLoading(null);
    }
  };

  const getStatusBadge = (account: Account) => {
    if (account.status === "error" || account.error_message) {
      return (
        <Badge variant="destructive" className="flex items-center gap-1">
          <AlertCircle className="h-3 w-3" />
          Error
        </Badge>
      );
    }
    if (account.status === "disconnected") {
      return <Badge variant="secondary">Disconnected</Badge>;
    }
    return <Badge className="bg-green-500">Active</Badge>;
  };

  const getWarmupBadge = (account: Account) => {
    if (account.warmup_status === "enabled") {
      return (
        <Badge className="bg-orange-500 flex items-center gap-1">
          <Flame className="h-3 w-3" />
          Warming
        </Badge>
      );
    }
    return (
      <Badge variant="outline" className="flex items-center gap-1">
        <FlameKindling className="h-3 w-3" />
        Off
      </Badge>
    );
  };

  const getReputationColor = (reputation: number) => {
    if (reputation >= 80) return "text-green-600";
    if (reputation >= 50) return "text-yellow-600";
    return "text-red-600";
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <RefreshCw className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <Link
            href="/admin/instantly"
            className="text-sm text-blue-600 hover:underline flex items-center gap-1"
          >
            <ArrowLeft className="h-4 w-4" />
            Back to Instantly
          </Link>
          <h1 className="text-2xl font-bold mt-2">Email Accounts</h1>
          <p className="text-gray-500">{accounts.length} accounts connected</p>
        </div>
        <Button onClick={fetchAccounts} variant="outline" size="sm">
          <RefreshCw className="h-4 w-4 mr-2" />
          Refresh
        </Button>
      </div>

      {accounts.length === 0 ? (
        <Card>
          <CardContent className="py-8 text-center text-gray-500">
            No email accounts found in Instantly
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {accounts.map((account) => (
            <Card key={account.email}>
              <CardHeader className="pb-2">
                <div className="flex items-start justify-between">
                  <div>
                    <CardTitle className="text-base">{account.email}</CardTitle>
                    {(account.first_name || account.last_name) && (
                      <p className="text-sm text-gray-500">
                        {account.first_name} {account.last_name}
                      </p>
                    )}
                  </div>
                  {getStatusBadge(account)}
                </div>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-gray-500">Warmup</span>
                  {getWarmupBadge(account)}
                </div>

                {account.warmup && (
                  <div className="space-y-2">
                    <div className="flex items-center justify-between">
                      <span className="text-sm text-gray-500">Reputation</span>
                      <span className={`font-bold ${getReputationColor(account.warmup.reputation)}`}>
                        {account.warmup.reputation}%
                      </span>
                    </div>
                    <div className="w-full bg-gray-200 rounded-full h-2">
                      <div
                        className={`h-2 rounded-full ${
                          account.warmup.reputation >= 80
                            ? "bg-green-500"
                            : account.warmup.reputation >= 50
                              ? "bg-yellow-500"
                              : "bg-red-500"
                        }`}
                        style={{ width: `${account.warmup.reputation}%` }}
                      />
                    </div>
                    <div className="flex justify-between text-xs text-gray-500">
                      <span>Sent: {account.warmup.warmup_emails_sent}</span>
                      <span>Received: {account.warmup.warmup_emails_received}</span>
                    </div>
                  </div>
                )}

                {account.daily_limit && (
                  <div className="flex items-center justify-between">
                    <span className="text-sm text-gray-500">Daily Limit</span>
                    <span className="text-sm font-medium">{account.daily_limit}</span>
                  </div>
                )}

                {account.error_message && (
                  <p className="text-sm text-red-600">{account.error_message}</p>
                )}

                <div className="pt-2">
                  <Button
                    size="sm"
                    variant="outline"
                    className="w-full"
                    onClick={() =>
                      handleWarmupToggle(account.email, account.warmup_status !== "enabled")
                    }
                    disabled={actionLoading === account.email}
                  >
                    {actionLoading === account.email ? (
                      <RefreshCw className="h-4 w-4 animate-spin" />
                    ) : account.warmup_status === "enabled" ? (
                      "Disable Warmup"
                    ) : (
                      "Enable Warmup"
                    )}
                  </Button>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/instantly/analytics/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { RefreshCw, ArrowLeft, Mail, Eye, Reply, AlertTriangle } from "lucide-react";

interface CampaignAnalytics {
  campaign_id: string;
  campaign_name: string;
  total_leads: number;
  contacted: number;
  emails_sent: number;
  emails_opened: number;
  emails_replied: number;
  emails_bounced: number;
  open_rate: number;
  reply_rate: number;
  bounce_rate: number;
}

interface OverviewStats {
  totalCampaigns: number;
  totalEmailsSent: number;
  totalOpens: number;
  totalReplies: number;
  totalBounces: number;
  avgOpenRate: number;
  avgReplyRate: number;
}

export default function InstantlyAnalyticsPage() {
  const [analytics, setAnalytics] = useState<CampaignAnalytics[]>([]);
  const [overview, setOverview] = useState<OverviewStats | null>(null);
  const [loading, setLoading] = useState(true);

  const fetchAnalytics = async () => {
    setLoading(true);
    try {
      const response = await fetch("/api/instantly/campaigns?analytics=true");
      const data = await response.json();

      const campaigns = data.campaigns || [];
      const analyticsData: CampaignAnalytics[] = campaigns
        .filter((c: { analytics?: CampaignAnalytics }) => c.analytics)
        .map((c: { analytics: CampaignAnalytics }) => c.analytics);

      setAnalytics(analyticsData);

      // Calculate overview
      const totalEmailsSent = analyticsData.reduce((sum, a) => sum + a.emails_sent, 0);
      const totalOpens = analyticsData.reduce((sum, a) => sum + a.emails_opened, 0);
      const totalReplies = analyticsData.reduce((sum, a) => sum + a.emails_replied, 0);
      const totalBounces = analyticsData.reduce((sum, a) => sum + a.emails_bounced, 0);

      setOverview({
        totalCampaigns: campaigns.length,
        totalEmailsSent,
        totalOpens,
        totalReplies,
        totalBounces,
        avgOpenRate: totalEmailsSent > 0 ? (totalOpens / totalEmailsSent) * 100 : 0,
        avgReplyRate: totalEmailsSent > 0 ? (totalReplies / totalEmailsSent) * 100 : 0,
      });
    } catch (error) {
      console.error("Error fetching analytics:", error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchAnalytics();
  }, []);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <RefreshCw className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <Link
            href="/admin/instantly"
            className="text-sm text-blue-600 hover:underline flex items-center gap-1"
          >
            <ArrowLeft className="h-4 w-4" />
            Back to Instantly
          </Link>
          <h1 className="text-2xl font-bold mt-2">Campaign Analytics</h1>
          <p className="text-gray-500">Performance overview across all campaigns</p>
        </div>
        <Button onClick={fetchAnalytics} variant="outline" size="sm">
          <RefreshCw className="h-4 w-4 mr-2" />
          Refresh
        </Button>
      </div>

      {/* Overview Cards */}
      {overview && (
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium text-gray-500">Emails Sent</CardTitle>
              <Mail className="h-4 w-4 text-gray-400" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{overview.totalEmailsSent.toLocaleString()}</div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium text-gray-500">Open Rate</CardTitle>
              <Eye className="h-4 w-4 text-gray-400" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{overview.avgOpenRate.toFixed(1)}%</div>
              <p className="text-xs text-gray-500">{overview.totalOpens.toLocaleString()} opens</p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium text-gray-500">Reply Rate</CardTitle>
              <Reply className="h-4 w-4 text-gray-400" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{overview.avgReplyRate.toFixed(1)}%</div>
              <p className="text-xs text-gray-500">{overview.totalReplies.toLocaleString()} replies</p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium text-gray-500">Bounces</CardTitle>
              <AlertTriangle className="h-4 w-4 text-gray-400" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{overview.totalBounces.toLocaleString()}</div>
              <p className="text-xs text-gray-500">
                {overview.totalEmailsSent > 0
                  ? ((overview.totalBounces / overview.totalEmailsSent) * 100).toFixed(1)
                  : 0}% bounce rate
              </p>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Campaign Breakdown */}
      <Card>
        <CardHeader>
          <CardTitle>Campaign Performance</CardTitle>
        </CardHeader>
        <CardContent>
          {analytics.length === 0 ? (
            <p className="text-center text-gray-500 py-8">No analytics data available</p>
          ) : (
            <div className="space-y-4">
              {analytics.map((campaign) => (
                <div key={campaign.campaign_id} className="border rounded-lg p-4">
                  <div className="flex justify-between items-start mb-3">
                    <h3 className="font-medium">{campaign.campaign_name}</h3>
                    <span className="text-sm text-gray-500">
                      {campaign.total_leads} leads
                    </span>
                  </div>
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                    <div>
                      <p className="text-gray-500">Sent</p>
                      <p className="font-medium">{campaign.emails_sent}</p>
                    </div>
                    <div>
                      <p className="text-gray-500">Open Rate</p>
                      <p className="font-medium">
                        {(campaign.open_rate * 100).toFixed(1)}%
                      </p>
                    </div>
                    <div>
                      <p className="text-gray-500">Reply Rate</p>
                      <p className="font-medium">
                        {(campaign.reply_rate * 100).toFixed(1)}%
                      </p>
                    </div>
                    <div>
                      <p className="text-gray-500">Bounce Rate</p>
                      <p className="font-medium">
                        {(campaign.bounce_rate * 100).toFixed(1)}%
                      </p>
                    </div>
                  </div>
                  {/* Simple bar chart */}
                  <div className="mt-3 space-y-1">
                    <div className="flex items-center gap-2">
                      <span className="text-xs text-gray-500 w-16">Opens</span>
                      <div className="flex-1 bg-gray-100 rounded-full h-2">
                        <div
                          className="bg-blue-500 h-2 rounded-full"
                          style={{ width: `${campaign.open_rate * 100}%` }}
                        />
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <span className="text-xs text-gray-500 w-16">Replies</span>
                      <div className="flex-1 bg-gray-100 rounded-full h-2">
                        <div
                          className="bg-green-500 h-2 rounded-full"
                          style={{ width: `${campaign.reply_rate * 100}%` }}
                        />
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/admin/instantly/campaigns/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import Link from "next/link";
import { RefreshCw, Play, Pause, ArrowLeft } from "lucide-react";

interface Campaign {
  id: string;
  name: string;
  status: string;
  created_at: string;
  leads_count?: number;
  analytics?: {
    total_leads: number;
    emails_sent: number;
    emails_opened: number;
    emails_replied: number;
    open_rate: number;
    reply_rate: number;
  };
}

export default function InstantlyCampaignsPage() {
  const [campaigns, setCampaigns] = useState<Campaign[]>([]);
  const [loading, setLoading] = useState(true);
  const [actionLoading, setActionLoading] = useState<string | null>(null);

  const fetchCampaigns = async () => {
    setLoading(true);
    try {
      const response = await fetch("/api/instantly/campaigns");
      const data = await response.json();
      setCampaigns(data.campaigns || []);
    } catch (error) {
      console.error("Error fetching campaigns:", error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchCampaigns();
  }, []);

  const handleCampaignAction = async (campaignId: string, action: "activate" | "pause") => {
    setActionLoading(campaignId);
    try {
      const response = await fetch(`/api/instantly/campaigns/${campaignId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action }),
      });
      const data = await response.json();
      if (data.success) {
        fetchCampaigns();
      } else {
        alert(`Failed: ${data.error}`);
      }
    } catch (error) {
      alert(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    } finally {
      setActionLoading(null);
    }
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case "active":
        return <Badge className="bg-green-500">Active</Badge>;
      case "paused":
        return <Badge variant="secondary">Paused</Badge>;
      case "completed":
        return <Badge variant="outline">Completed</Badge>;
      case "draft":
        return <Badge variant="outline">Draft</Badge>;
      default:
        return <Badge variant="secondary">{status}</Badge>;
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <RefreshCw className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <Link
            href="/admin/instantly"
            className="text-sm text-blue-600 hover:underline flex items-center gap-1"
          >
            <ArrowLeft className="h-4 w-4" />
            Back to Instantly
          </Link>
          <h1 className="text-2xl font-bold mt-2">Instantly Campaigns</h1>
          <p className="text-gray-500">{campaigns.length} campaigns found</p>
        </div>
        <Button onClick={fetchCampaigns} variant="outline" size="sm">
          <RefreshCw className="h-4 w-4 mr-2" />
          Refresh
        </Button>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>All Campaigns</CardTitle>
        </CardHeader>
        <CardContent>
          {campaigns.length === 0 ? (
            <p className="text-center text-gray-500 py-8">
              No campaigns found in Instantly
            </p>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Name</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead className="text-right">Leads</TableHead>
                  <TableHead className="text-right">Sent</TableHead>
                  <TableHead className="text-right">Open Rate</TableHead>
                  <TableHead className="text-right">Reply Rate</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {campaigns.map((campaign) => (
                  <TableRow key={campaign.id}>
                    <TableCell className="font-medium">{campaign.name}</TableCell>
                    <TableCell>{getStatusBadge(campaign.status)}</TableCell>
                    <TableCell className="text-right">
                      {campaign.analytics?.total_leads || campaign.leads_count || 0}
                    </TableCell>
                    <TableCell className="text-right">
                      {campaign.analytics?.emails_sent || 0}
                    </TableCell>
                    <TableCell className="text-right">
                      {campaign.analytics?.open_rate
                        ? `${(campaign.analytics.open_rate * 100).toFixed(1)}%`
                        : "-"}
                    </TableCell>
                    <TableCell className="text-right">
                      {campaign.analytics?.reply_rate
                        ? `${(campaign.analytics.reply_rate * 100).toFixed(1)}%`
                        : "-"}
                    </TableCell>
                    <TableCell className="text-right">
                      {campaign.status === "active" ? (
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => handleCampaignAction(campaign.id, "pause")}
                          disabled={actionLoading === campaign.id}
                        >
                          {actionLoading === campaign.id ? (
                            <RefreshCw className="h-4 w-4 animate-spin" />
                          ) : (
                            <Pause className="h-4 w-4" />
                          )}
                        </Button>
                      ) : campaign.status === "paused" ? (
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => handleCampaignAction(campaign.id, "activate")}
                          disabled={actionLoading === campaign.id}
                        >
                          {actionLoading === campaign.id ? (
                            <RefreshCw className="h-4 w-4 animate-spin" />
                          ) : (
                            <Play className="h-4 w-4" />
                          )}
                        </Button>
                      ) : null}
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/admin/lead-database/page.tsx">
"use client";

import { useEffect, useState, useCallback, useRef } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import Link from "next/link";
import {
  ArrowLeft,
  Upload,
  Database,
  FileSpreadsheet,
  RefreshCw,
  Calendar,
  MapPin,
  Building2,
  Users,
  CheckCircle2,
  XCircle,
  AlertCircle,
} from "lucide-react";

interface LeadSource {
  id: string;
  name: string;
  file_name: string | null;
  industry: string | null;
  region: string | null;
  sub_region: string | null;
  source_type: string | null;
  scrape_date: string | null;
  tags: string[] | null;
  notes: string | null;
  total_records: number;
  imported_records: number;
  duplicate_records: number;
  created_at: string;
}

interface UploadResult {
  success: boolean;
  stats: {
    total: number;
    imported: number;
    duplicates: number;
    errors: number;
  };
  detectedColumns: string[];
  mappedColumns: string[];
  unmappedColumns: string[];
  errors?: string[];
}

export default function LeadDatabasePage() {
  const [sources, setSources] = useState<LeadSource[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Upload dialog state
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false);
  const [uploadFile, setUploadFile] = useState<File | null>(null);
  const [uploadName, setUploadName] = useState("");
  const [uploadIndustry, setUploadIndustry] = useState("");
  const [uploadRegion, setUploadRegion] = useState("");
  const [uploadSourceType, setUploadSourceType] = useState("");
  const [uploadScrapeDate, setUploadScrapeDate] = useState("");
  const [isUploading, setIsUploading] = useState(false);
  const [uploadResult, setUploadResult] = useState<UploadResult | null>(null);
  const [uploadError, setUploadError] = useState<string | null>(null);

  const fileInputRef = useRef<HTMLInputElement>(null);

  const fetchSources = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const res = await fetch("/api/admin/lead-database/sources");
      if (!res.ok) throw new Error("Failed to fetch sources");

      const data = await res.json();
      setSources(data.sources || []);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load sources");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchSources();
  }, [fetchSources]);

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setUploadFile(file);
      // Set default name from filename
      if (!uploadName) {
        setUploadName(file.name.replace(/\.[^/.]+$/, ""));
      }
    }
  };

  const resetUploadForm = () => {
    setUploadFile(null);
    setUploadName("");
    setUploadIndustry("");
    setUploadRegion("");
    setUploadSourceType("");
    setUploadScrapeDate("");
    setUploadResult(null);
    setUploadError(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleUpload = async () => {
    if (!uploadFile || !uploadName.trim()) return;

    setIsUploading(true);
    setUploadError(null);
    setUploadResult(null);

    try {
      // Step 1: Create source record
      const createRes = await fetch("/api/admin/lead-database/sources", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: uploadName.trim(),
          file_name: uploadFile.name,
          industry: uploadIndustry || null,
          region: uploadRegion || null,
          source_type: uploadSourceType || null,
          scrape_date: uploadScrapeDate || null,
        }),
      });

      if (!createRes.ok) {
        throw new Error("Failed to create source record");
      }

      const { source } = await createRes.json();

      // Step 2: Upload CSV
      const formData = new FormData();
      formData.append("file", uploadFile);
      formData.append("source_id", source.id);
      if (uploadIndustry) formData.append("industry", uploadIndustry);
      if (uploadRegion) formData.append("region", uploadRegion);

      const uploadRes = await fetch("/api/admin/lead-database/upload", {
        method: "POST",
        body: formData,
      });

      const result = await uploadRes.json();

      if (!uploadRes.ok) {
        throw new Error(result.error || "Failed to upload CSV");
      }

      setUploadResult(result);
      fetchSources(); // Refresh the list
    } catch (err) {
      setUploadError(err instanceof Error ? err.message : "Upload failed");
    } finally {
      setIsUploading(false);
    }
  };

  const formatDate = (dateStr: string) => {
    return new Date(dateStr).toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric",
    });
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <Link
            href="/admin"
            className="text-muted-foreground hover:text-foreground"
          >
            <ArrowLeft className="h-5 w-5" />
          </Link>
          <div>
            <h1 className="text-2xl font-bold text-foreground">Lead Database</h1>
            <p className="text-muted-foreground text-sm">
              Upload and manage your master lead database
            </p>
          </div>
        </div>

        <Dialog
          open={isUploadDialogOpen}
          onOpenChange={(open) => {
            setIsUploadDialogOpen(open);
            if (!open) resetUploadForm();
          }}
        >
          <DialogTrigger asChild>
            <Button>
              <Upload className="h-4 w-4 mr-2" />
              Upload CSV
            </Button>
          </DialogTrigger>
          <DialogContent className="sm:max-w-lg">
            <DialogHeader>
              <DialogTitle>Upload Lead List</DialogTitle>
            </DialogHeader>

            {uploadResult ? (
              <div className="space-y-4 py-4">
                <div className="flex items-center gap-3 text-green-600 dark:text-green-400">
                  <CheckCircle2 className="h-6 w-6" />
                  <span className="font-medium">Upload Complete!</span>
                </div>

                <div className="grid grid-cols-2 gap-4 bg-muted rounded-lg p-4">
                  <div>
                    <p className="text-sm text-muted-foreground">Total Rows</p>
                    <p className="text-2xl font-bold">{uploadResult.stats.total.toLocaleString()}</p>
                  </div>
                  <div>
                    <p className="text-sm text-muted-foreground">Imported</p>
                    <p className="text-2xl font-bold text-green-600">{uploadResult.stats.imported.toLocaleString()}</p>
                  </div>
                  <div>
                    <p className="text-sm text-muted-foreground">Duplicates</p>
                    <p className="text-2xl font-bold text-amber-600">{uploadResult.stats.duplicates.toLocaleString()}</p>
                  </div>
                  <div>
                    <p className="text-sm text-muted-foreground">Errors</p>
                    <p className="text-2xl font-bold text-red-600">{uploadResult.stats.errors}</p>
                  </div>
                </div>

                {uploadResult.unmappedColumns.length > 0 && (
                  <div className="bg-amber-50 dark:bg-amber-950 border border-amber-200 dark:border-amber-800 rounded-lg p-4">
                    <p className="text-sm font-medium text-amber-800 dark:text-amber-200 mb-2">
                      Unmapped columns (stored in extra_data):
                    </p>
                    <div className="flex flex-wrap gap-1">
                      {uploadResult.unmappedColumns.map((col) => (
                        <Badge key={col} variant="outline" className="text-xs">
                          {col}
                        </Badge>
                      ))}
                    </div>
                  </div>
                )}

                {uploadResult.errors && uploadResult.errors.length > 0 && (
                  <div className="bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 rounded-lg p-4">
                    <p className="text-sm font-medium text-red-800 dark:text-red-200 mb-2">
                      Errors:
                    </p>
                    <ul className="text-xs text-red-700 dark:text-red-300 space-y-1">
                      {uploadResult.errors.map((err, i) => (
                        <li key={i}>{err}</li>
                      ))}
                    </ul>
                  </div>
                )}

                <Button onClick={() => setIsUploadDialogOpen(false)} className="w-full">
                  Done
                </Button>
              </div>
            ) : (
              <div className="space-y-4 py-4">
                {uploadError && (
                  <div className="flex items-center gap-2 text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 rounded-lg p-3">
                    <XCircle className="h-5 w-5" />
                    <span className="text-sm">{uploadError}</span>
                  </div>
                )}

                {/* File input */}
                <div className="space-y-2">
                  <Label htmlFor="file">CSV File</Label>
                  <div className="border-2 border-dashed border-border rounded-lg p-6 text-center">
                    {uploadFile ? (
                      <div className="flex items-center justify-center gap-2">
                        <FileSpreadsheet className="h-8 w-8 text-green-600" />
                        <div className="text-left">
                          <p className="font-medium">{uploadFile.name}</p>
                          <p className="text-sm text-muted-foreground">
                            {(uploadFile.size / 1024).toFixed(1)} KB
                          </p>
                        </div>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => {
                            setUploadFile(null);
                            if (fileInputRef.current) fileInputRef.current.value = "";
                          }}
                        >
                          <XCircle className="h-4 w-4" />
                        </Button>
                      </div>
                    ) : (
                      <label className="cursor-pointer">
                        <Upload className="h-8 w-8 mx-auto mb-2 text-muted-foreground" />
                        <p className="text-sm text-muted-foreground">
                          Click to select or drag and drop
                        </p>
                        <input
                          ref={fileInputRef}
                          type="file"
                          accept=".csv"
                          onChange={handleFileSelect}
                          className="hidden"
                        />
                      </label>
                    )}
                  </div>
                </div>

                {/* Batch name */}
                <div className="space-y-2">
                  <Label htmlFor="name">Batch Name *</Label>
                  <Input
                    id="name"
                    placeholder="e.g., German SaaS Companies Dec 2024"
                    value={uploadName}
                    onChange={(e) => setUploadName(e.target.value)}
                  />
                </div>

                {/* Metadata fields */}
                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="industry">Industry</Label>
                    <Input
                      id="industry"
                      placeholder="e.g., SaaS, E-commerce"
                      value={uploadIndustry}
                      onChange={(e) => setUploadIndustry(e.target.value)}
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="region">Region</Label>
                    <Input
                      id="region"
                      placeholder="e.g., DACH, US, UK"
                      value={uploadRegion}
                      onChange={(e) => setUploadRegion(e.target.value)}
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="sourceType">Source Type</Label>
                    <Select value={uploadSourceType} onValueChange={setUploadSourceType}>
                      <SelectTrigger>
                        <SelectValue placeholder="Select source" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="Apollo">Apollo</SelectItem>
                        <SelectItem value="LinkedIn">LinkedIn</SelectItem>
                        <SelectItem value="ZoomInfo">ZoomInfo</SelectItem>
                        <SelectItem value="Manual">Manual</SelectItem>
                        <SelectItem value="Other">Other</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="scrapeDate">Scrape Date</Label>
                    <Input
                      id="scrapeDate"
                      type="date"
                      value={uploadScrapeDate}
                      onChange={(e) => setUploadScrapeDate(e.target.value)}
                    />
                  </div>
                </div>

                <div className="flex justify-end gap-2 pt-4">
                  <Button variant="outline" onClick={() => setIsUploadDialogOpen(false)}>
                    Cancel
                  </Button>
                  <Button
                    onClick={handleUpload}
                    disabled={!uploadFile || !uploadName.trim() || isUploading}
                  >
                    {isUploading ? (
                      <>
                        <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                        Uploading...
                      </>
                    ) : (
                      <>
                        <Upload className="h-4 w-4 mr-2" />
                        Upload
                      </>
                    )}
                  </Button>
                </div>
              </div>
            )}
          </DialogContent>
        </Dialog>
      </div>

      {/* Stats overview */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center gap-3">
              <Database className="h-8 w-8 text-blue-500" />
              <div>
                <p className="text-sm text-muted-foreground">Total Batches</p>
                <p className="text-2xl font-bold">{sources.length}</p>
              </div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center gap-3">
              <Users className="h-8 w-8 text-green-500" />
              <div>
                <p className="text-sm text-muted-foreground">Total Leads</p>
                <p className="text-2xl font-bold">
                  {sources.reduce((sum, s) => sum + s.imported_records, 0).toLocaleString()}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center gap-3">
              <FileSpreadsheet className="h-8 w-8 text-purple-500" />
              <div>
                <p className="text-sm text-muted-foreground">Total Records</p>
                <p className="text-2xl font-bold">
                  {sources.reduce((sum, s) => sum + s.total_records, 0).toLocaleString()}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Error message */}
      {error && (
        <div className="bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-300 px-4 py-3 rounded-lg flex items-center gap-2">
          <AlertCircle className="h-5 w-5" />
          {error}
        </div>
      )}

      {/* Sources list */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <span>Upload Batches</span>
            <Button variant="ghost" size="sm" onClick={fetchSources} disabled={loading}>
              <RefreshCw className={`h-4 w-4 ${loading ? "animate-spin" : ""}`} />
            </Button>
          </CardTitle>
        </CardHeader>
        <CardContent>
          {loading && sources.length === 0 ? (
            <div className="flex items-center justify-center py-12">
              <RefreshCw className="h-6 w-6 animate-spin text-muted-foreground" />
            </div>
          ) : sources.length === 0 ? (
            <div className="text-center py-12">
              <Database className="h-12 w-12 mx-auto mb-4 text-muted-foreground opacity-50" />
              <p className="text-muted-foreground font-medium">No lead batches uploaded yet</p>
              <p className="text-sm text-muted-foreground mt-1">
                Click "Upload CSV" to add your first lead list
              </p>
            </div>
          ) : (
            <div className="space-y-4">
              {sources.map((source) => (
                <div
                  key={source.id}
                  className="border border-border rounded-lg p-4 hover:bg-accent/50 transition-colors"
                >
                  <div className="flex items-start justify-between">
                    <div>
                      <h3 className="font-medium text-foreground">{source.name}</h3>
                      {source.file_name && (
                        <p className="text-sm text-muted-foreground">{source.file_name}</p>
                      )}
                    </div>
                    <div className="text-right">
                      <p className="font-semibold text-foreground">
                        {source.imported_records.toLocaleString()} leads
                      </p>
                      <p className="text-xs text-muted-foreground">
                        of {source.total_records.toLocaleString()} rows
                      </p>
                    </div>
                  </div>

                  <div className="flex flex-wrap gap-2 mt-3">
                    {source.industry && (
                      <Badge variant="outline" className="text-xs">
                        <Building2 className="h-3 w-3 mr-1" />
                        {source.industry}
                      </Badge>
                    )}
                    {source.region && (
                      <Badge variant="outline" className="text-xs">
                        <MapPin className="h-3 w-3 mr-1" />
                        {source.region}
                      </Badge>
                    )}
                    {source.source_type && (
                      <Badge variant="outline" className="text-xs">
                        {source.source_type}
                      </Badge>
                    )}
                    {source.scrape_date && (
                      <Badge variant="outline" className="text-xs">
                        <Calendar className="h-3 w-3 mr-1" />
                        {formatDate(source.scrape_date)}
                      </Badge>
                    )}
                    {source.tags && source.tags.length > 0 && source.tags.map((tag) => (
                      <Badge key={tag} variant="secondary" className="text-xs">
                        {tag}
                      </Badge>
                    ))}
                  </div>

                  <p className="text-xs text-muted-foreground mt-3">
                    Uploaded {formatDate(source.created_at)}
                  </p>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/api/admin/analytics/sync/route.ts">
import { createClient } from "@supabase/supabase-js";
import { NextResponse } from "next/server";
import { getCampaignAnalytics } from "@/lib/instantly";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// POST - Sync analytics from Instantly to Supabase
export async function POST() {
  try {
    const supabase = getSupabase();

    // Fetch all analytics from Instantly
    const analytics = await getCampaignAnalytics();

    if (!analytics || analytics.length === 0) {
      return NextResponse.json({
        success: true,
        message: "No analytics to sync",
        synced: 0,
      });
    }

    // Get campaign mapping (instantly_campaign_id -> local campaign_id)
    const { data: campaigns } = await supabase
      .from("campaigns")
      .select("id, instantly_campaign_id")
      .not("instantly_campaign_id", "is", null);

    const campaignMap = new Map(
      (campaigns || []).map((c) => [c.instantly_campaign_id, c.id])
    );

    let synced = 0;
    let failed = 0;

    for (const a of analytics) {
      const localCampaignId = campaignMap.get(a.campaign_id);

      // Use the upsert function
      const { error } = await supabase.rpc("upsert_analytics_snapshot", {
        p_instantly_campaign_id: a.campaign_id,
        p_campaign_id: localCampaignId || null,
        p_data: a,
      });

      if (error) {
        console.error("Error syncing analytics for", a.campaign_name, error);
        failed++;
      } else {
        synced++;
      }
    }

    return NextResponse.json({
      success: true,
      synced,
      failed,
      total: analytics.length,
    });
  } catch (error) {
    console.error("Error syncing analytics:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Sync failed" },
      { status: 500 }
    );
  }
}

// GET - Get overview from stored analytics
export async function GET() {
  try {
    const supabase = getSupabase();

    // Try to get from analytics_overview view
    const { data: overview, error } = await supabase
      .from("analytics_overview")
      .select("*")
      .single();

    if (error) {
      // If view doesn't exist, fetch from Instantly directly
      const analytics = await getCampaignAnalytics();

      let totalLeads = 0;
      let totalEmailsSent = 0;
      let totalOpened = 0;
      let totalClicked = 0;
      let totalReplies = 0;

      analytics.forEach((a) => {
        totalLeads += a.leads_count || 0;
        totalEmailsSent += a.emails_sent_count || 0;
        totalOpened += a.open_count_unique || 0;
        totalClicked += a.link_click_count_unique || 0;
        totalReplies += a.reply_count_unique || 0;
      });

      return NextResponse.json({
        source: "instantly",
        total_campaigns: analytics.length,
        total_leads: totalLeads,
        total_emails_sent: totalEmailsSent,
        total_opened: totalOpened,
        total_clicked: totalClicked,
        total_replies: totalReplies,
        overall_open_rate: totalEmailsSent > 0 ? (totalOpened / totalEmailsSent * 100).toFixed(2) : 0,
        overall_click_rate: totalEmailsSent > 0 ? (totalClicked / totalEmailsSent * 100).toFixed(2) : 0,
        overall_reply_rate: totalEmailsSent > 0 ? (totalReplies / totalEmailsSent * 100).toFixed(2) : 0,
      });
    }

    return NextResponse.json({
      source: "supabase",
      ...overview,
    });
  } catch (error) {
    console.error("Error fetching analytics:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/infrastructure/accounts/[accountId]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

interface RouteParams {
  params: Promise<{ accountId: string }>;
}

// GET - Get single account details
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { accountId } = await params;
    const supabase = getSupabase();

    const { data: account, error } = await supabase
      .from("email_accounts_with_health")
      .select("*")
      .eq("id", accountId)
      .single();

    if (error) {
      if (error.code === "PGRST116") {
        return NextResponse.json({ error: "Account not found" }, { status: 404 });
      }
      throw error;
    }

    return NextResponse.json({ account });
  } catch (error) {
    console.error("Error fetching account:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch account" },
      { status: 500 }
    );
  }
}

// PATCH - Update account (assign client, etc.)
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  try {
    const { accountId } = await params;
    const body = await request.json();
    const supabase = getSupabase();

    // Only allow updating certain fields
    const allowedFields = ["client_id"];
    const updates: Record<string, unknown> = {};

    for (const field of allowedFields) {
      if (field in body) {
        updates[field] = body[field];
      }
    }

    if (Object.keys(updates).length === 0) {
      return NextResponse.json(
        { error: "No valid fields to update" },
        { status: 400 }
      );
    }

    const { data: account, error } = await supabase
      .from("email_accounts")
      .update(updates)
      .eq("id", accountId)
      .select()
      .single();

    if (error) {
      throw error;
    }

    return NextResponse.json({ account });
  } catch (error) {
    console.error("Error updating account:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to update account" },
      { status: 500 }
    );
  }
}

// DELETE - Remove account from tracking
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { accountId } = await params;
    const supabase = getSupabase();

    const { error } = await supabase
      .from("email_accounts")
      .delete()
      .eq("id", accountId);

    if (error) {
      throw error;
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting account:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to delete account" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/infrastructure/accounts/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - List all email accounts with optional filtering
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const clientId = searchParams.get("client");
    const provider = searchParams.get("provider");
    const status = searchParams.get("status");
    const domain = searchParams.get("domain");
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "50");
    const offset = (page - 1) * limit;

    const supabase = getSupabase();

    // Build query using the view for joined data
    let query = supabase
      .from("email_accounts_with_health")
      .select("*", { count: "exact" });

    // Apply filters
    if (clientId && clientId !== "all") {
      query = query.eq("client_id", clientId);
    }

    if (provider && provider !== "all") {
      query = query.eq("provider_type", provider);
    }

    if (status && status !== "all") {
      query = query.eq("status", status);
    }

    if (domain) {
      query = query.eq("domain", domain);
    }

    // Apply pagination and ordering
    const { data: accounts, count, error } = await query
      .order("email", { ascending: true })
      .range(offset, offset + limit - 1);

    if (error) {
      throw error;
    }

    return NextResponse.json({
      accounts: accounts || [],
      total: count || 0,
      page,
      limit,
    });
  } catch (error) {
    console.error("Error fetching email accounts:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch accounts" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/infrastructure/dns/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { checkDomainHealth, checkDomainsHealth } from "@/lib/dns";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - Get domain health records from database
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const domain = searchParams.get("domain");

    const supabase = getSupabase();

    if (domain) {
      // Get specific domain
      const { data, error } = await supabase
        .from("domain_summary")
        .select("*")
        .eq("domain", domain)
        .single();

      if (error && error.code !== "PGRST116") {
        throw error;
      }

      return NextResponse.json({ domain: data || null });
    }

    // Get all domains
    const { data: domains, error } = await supabase
      .from("domain_summary")
      .select("*")
      .order("account_count", { ascending: false });

    if (error) {
      throw error;
    }

    return NextResponse.json({ domains: domains || [] });
  } catch (error) {
    console.error("Error fetching domain health:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch domain health" },
      { status: 500 }
    );
  }
}

// POST - Check DNS health for domain(s) and store results
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const domains: string[] = body.domains || [];

    if (domains.length === 0) {
      return NextResponse.json(
        { error: "No domains provided" },
        { status: 400 }
      );
    }

    // Limit to 20 domains per request
    if (domains.length > 20) {
      return NextResponse.json(
        { error: "Maximum 20 domains per request" },
        { status: 400 }
      );
    }

    const supabase = getSupabase();

    // Check all domains
    const results = await checkDomainsHealth(domains);

    // Store results in database
    const stored: string[] = [];
    const errors: string[] = [];

    for (const result of results) {
      try {
        const domainData = {
          domain: result.domain,
          has_spf: result.spf.found,
          spf_record: result.spf.record,
          spf_valid: result.spf.valid,
          has_dkim: result.dkim.found,
          dkim_selector: result.dkim.selector,
          dkim_record: result.dkim.record,
          dkim_valid: result.dkim.valid,
          has_dmarc: result.dmarc.found,
          dmarc_record: result.dmarc.record,
          dmarc_policy: result.dmarc.policy,
          dmarc_valid: result.dmarc.valid,
          health_score: result.healthScore,
          last_checked_at: result.checkedAt,
        };

        // Upsert domain health
        const { error } = await supabase
          .from("domain_health")
          .upsert(domainData, { onConflict: "domain" });

        if (error) {
          errors.push(`Failed to store ${result.domain}: ${error.message}`);
        } else {
          stored.push(result.domain);
        }
      } catch (error) {
        errors.push(`Failed to store ${result.domain}: ${error}`);
      }
    }

    return NextResponse.json({
      success: errors.length === 0,
      results,
      stored,
      errors,
    });
  } catch (error) {
    console.error("Error checking DNS health:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "DNS check failed" },
      { status: 500 }
    );
  }
}

// PATCH - Refresh DNS health for domains from email accounts
export async function PATCH() {
  try {
    const supabase = getSupabase();

    // Get unique domains from email accounts
    const { data: accounts, error: accountsError } = await supabase
      .from("email_accounts")
      .select("domain")
      .not("domain", "is", null);

    if (accountsError) {
      throw accountsError;
    }

    // Get unique domains
    const uniqueDomains = [...new Set(accounts?.map((a) => a.domain).filter(Boolean) || [])];

    if (uniqueDomains.length === 0) {
      return NextResponse.json({
        success: true,
        message: "No domains to check",
        checked: 0,
      });
    }

    // Check domains in batches
    const batchSize = 10;
    let checked = 0;
    const errors: string[] = [];

    for (let i = 0; i < uniqueDomains.length; i += batchSize) {
      const batch = uniqueDomains.slice(i, i + batchSize);
      const results = await checkDomainsHealth(batch);

      for (const result of results) {
        try {
          const domainData = {
            domain: result.domain,
            has_spf: result.spf.found,
            spf_record: result.spf.record,
            spf_valid: result.spf.valid,
            has_dkim: result.dkim.found,
            dkim_selector: result.dkim.selector,
            dkim_record: result.dkim.record,
            dkim_valid: result.dkim.valid,
            has_dmarc: result.dmarc.found,
            dmarc_record: result.dmarc.record,
            dmarc_policy: result.dmarc.policy,
            dmarc_valid: result.dmarc.valid,
            health_score: result.healthScore,
            last_checked_at: result.checkedAt,
          };

          await supabase.from("domain_health").upsert(domainData, { onConflict: "domain" });
          checked++;
        } catch (error) {
          errors.push(`Failed to update ${result.domain}: ${error}`);
        }
      }
    }

    return NextResponse.json({
      success: errors.length === 0,
      checked,
      total: uniqueDomains.length,
      errors,
    });
  } catch (error) {
    console.error("Error refreshing DNS health:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "DNS refresh failed" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/infrastructure/history/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - Get health history for account(s)
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const accountId = searchParams.get("account_id");
    const days = parseInt(searchParams.get("days") || "30");

    const supabase = getSupabase();

    // Calculate date range
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    let query = supabase
      .from("email_account_health_history")
      .select("*, email_accounts(email, provider_type)")
      .gte("snapshot_date", startDate.toISOString().split("T")[0])
      .lte("snapshot_date", endDate.toISOString().split("T")[0])
      .order("snapshot_date", { ascending: true });

    if (accountId) {
      query = query.eq("email_account_id", accountId);
    }

    const { data: history, error } = await query;

    if (error) {
      throw error;
    }

    return NextResponse.json({
      history: history || [],
      start_date: startDate.toISOString().split("T")[0],
      end_date: endDate.toISOString().split("T")[0],
    });
  } catch (error) {
    console.error("Error fetching health history:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch history" },
      { status: 500 }
    );
  }
}

// POST - Create daily snapshot for all accounts
export async function POST() {
  try {
    const supabase = getSupabase();
    const today = new Date().toISOString().split("T")[0];

    // Get all current accounts
    const { data: accounts, error: accountsError } = await supabase
      .from("email_accounts")
      .select("id, status, warmup_reputation, warmup_emails_sent, warmup_emails_received, emails_sent_today");

    if (accountsError) {
      throw accountsError;
    }

    if (!accounts || accounts.length === 0) {
      return NextResponse.json({
        success: true,
        message: "No accounts to snapshot",
        created: 0,
      });
    }

    // Create snapshots
    let created = 0;
    let skipped = 0;
    const errors: string[] = [];

    for (const account of accounts) {
      try {
        const snapshot = {
          email_account_id: account.id,
          snapshot_date: today,
          status: account.status,
          warmup_reputation: account.warmup_reputation,
          warmup_emails_sent: account.warmup_emails_sent,
          warmup_emails_received: account.warmup_emails_received,
          emails_sent_today: account.emails_sent_today || 0,
          emails_bounced_today: 0, // Would need to track bounces separately
        };

        // Upsert (one snapshot per account per day)
        const { error } = await supabase
          .from("email_account_health_history")
          .upsert(snapshot, { onConflict: "email_account_id,snapshot_date" });

        if (error) {
          errors.push(`Failed to snapshot ${account.id}: ${error.message}`);
        } else {
          created++;
        }
      } catch (error) {
        errors.push(`Failed to snapshot ${account.id}: ${error}`);
      }
    }

    return NextResponse.json({
      success: errors.length === 0,
      created,
      skipped,
      total: accounts.length,
      errors,
    });
  } catch (error) {
    console.error("Error creating health snapshots:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Snapshot creation failed" },
      { status: 500 }
    );
  }
}

// DELETE - Clean up old history (retention policy)
export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const retentionDays = parseInt(searchParams.get("retention_days") || "90");

    const supabase = getSupabase();

    // Calculate cutoff date
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - retentionDays);

    const { error, count } = await supabase
      .from("email_account_health_history")
      .delete({ count: "exact" })
      .lt("snapshot_date", cutoffDate.toISOString().split("T")[0]);

    if (error) {
      throw error;
    }

    return NextResponse.json({
      success: true,
      deleted: count || 0,
      cutoff_date: cutoffDate.toISOString().split("T")[0],
    });
  } catch (error) {
    console.error("Error cleaning up history:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Cleanup failed" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/infrastructure/stats/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

export async function GET() {
  try {
    const supabase = getSupabase();

    // Get account statistics
    const { data: accounts, error: accountsError } = await supabase
      .from("email_accounts")
      .select("id, provider_type, status, warmup_reputation, client_id, domain");

    if (accountsError) {
      throw accountsError;
    }

    // Get domain health statistics
    const { data: domains, error: domainsError } = await supabase
      .from("domain_health")
      .select("id, domain, health_score");

    if (domainsError) {
      throw domainsError;
    }

    // Calculate stats
    const totalAccounts = accounts?.length || 0;
    const byProvider: Record<string, number> = {};
    const byStatus: Record<string, number> = {};
    let assignedAccounts = 0;
    let unassignedAccounts = 0;
    let totalReputation = 0;
    let reputationCount = 0;
    const uniqueDomains = new Set<string>();

    accounts?.forEach((account) => {
      // By provider
      byProvider[account.provider_type] = (byProvider[account.provider_type] || 0) + 1;

      // By status
      byStatus[account.status] = (byStatus[account.status] || 0) + 1;

      // Assigned vs unassigned
      if (account.client_id) {
        assignedAccounts++;
      } else {
        unassignedAccounts++;
      }

      // Average reputation
      if (account.warmup_reputation !== null) {
        totalReputation += account.warmup_reputation;
        reputationCount++;
      }

      // Unique domains
      if (account.domain) {
        uniqueDomains.add(account.domain);
      }
    });

    const avgReputation = reputationCount > 0 ? Math.round(totalReputation / reputationCount) : 0;

    // Domain health stats
    let domainsHealthy = 0;
    let domainsWithIssues = 0;

    domains?.forEach((domain) => {
      if (domain.health_score >= 70) {
        domainsHealthy++;
      } else {
        domainsWithIssues++;
      }
    });

    return NextResponse.json({
      total_accounts: totalAccounts,
      by_provider: byProvider,
      by_status: byStatus,
      assigned_accounts: assignedAccounts,
      unassigned_accounts: unassignedAccounts,
      avg_warmup_reputation: avgReputation,
      domains_count: uniqueDomains.size,
      domains_checked: domains?.length || 0,
      domains_healthy: domainsHealthy,
      domains_issues: domainsWithIssues,
    });
  } catch (error) {
    console.error("Error fetching infrastructure stats:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch stats" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/infrastructure/sync/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { fetchAllInstantlyAccounts, getWarmupAnalytics, getInstantlyClient } from "@/lib/instantly";
import { fetchSmartleadAccounts, getSmartleadWarmupAnalytics, getSmartleadClient } from "@/lib/smartlead";
import type { EmailAccountProvider } from "@/types/database";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

interface SyncStats {
  added: number;
  updated: number;
  removed: number;
  errors: string[];
}

// Sync accounts from Instantly
async function syncInstantlyAccounts(supabase: ReturnType<typeof getSupabase>): Promise<SyncStats> {
  const stats: SyncStats = { added: 0, updated: 0, removed: 0, errors: [] };

  try {
    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      stats.errors.push("Instantly API not configured");
      return stats;
    }

    // Fetch accounts and warmup analytics
    const [accounts, warmupAnalytics] = await Promise.all([
      fetchAllInstantlyAccounts(),
      getWarmupAnalytics(),
    ]);

    // Create warmup map for quick lookup
    const warmupMap = new Map(warmupAnalytics.map((w) => [w.email, w]));

    // Get existing accounts
    const { data: existingAccounts } = await supabase
      .from("email_accounts")
      .select("id, email")
      .eq("provider_type", "instantly");

    const existingMap = new Map(existingAccounts?.map((a) => [a.email, a.id]) || []);
    const syncedEmails = new Set<string>();

    // Upsert each account
    for (const account of accounts) {
      try {
        syncedEmails.add(account.email);
        const warmup = warmupMap.get(account.email);

        const accountData = {
          provider_type: "instantly" as EmailAccountProvider,
          email: account.email,
          first_name: account.first_name || null,
          last_name: account.last_name || null,
          status: account.status === "active" ? "active" : account.status === "error" ? "error" : "disconnected",
          error_message: account.error_message || null,
          warmup_enabled: account.warmup_status === "enabled",
          warmup_reputation: warmup?.reputation || account.warmup_reputation || null,
          warmup_emails_sent: warmup?.warmup_emails_sent || 0,
          warmup_emails_received: warmup?.warmup_emails_received || 0,
          warmup_saved_from_spam: warmup?.warmup_emails_saved_from_spam || 0,
          daily_limit: account.daily_limit || null,
          last_synced_at: new Date().toISOString(),
        };

        const existingId = existingMap.get(account.email);

        if (existingId) {
          // Update existing
          await supabase.from("email_accounts").update(accountData).eq("id", existingId);
          stats.updated++;
        } else {
          // Insert new
          await supabase.from("email_accounts").insert(accountData);
          stats.added++;
        }
      } catch (error) {
        stats.errors.push(`Failed to sync ${account.email}: ${error}`);
      }
    }

    // Mark accounts that no longer exist (optional - could delete or mark inactive)
    // For now, we'll keep them but could add logic here

  } catch (error) {
    stats.errors.push(`Instantly sync failed: ${error}`);
  }

  return stats;
}

// Sync accounts from Smartlead
async function syncSmartleadAccounts(supabase: ReturnType<typeof getSupabase>): Promise<SyncStats> {
  const stats: SyncStats = { added: 0, updated: 0, removed: 0, errors: [] };

  try {
    const client = getSmartleadClient();
    if (!client.isConfigured()) {
      stats.errors.push("Smartlead API not configured");
      return stats;
    }

    // Fetch accounts
    const accounts = await fetchSmartleadAccounts();

    // Fetch warmup analytics in batches
    const warmupAnalytics = await getSmartleadWarmupAnalytics(accounts);
    const warmupMap = new Map(warmupAnalytics.map((w) => [w.email_account_id, w]));

    // Get existing accounts
    const { data: existingAccounts } = await supabase
      .from("email_accounts")
      .select("id, email, provider_account_id")
      .eq("provider_type", "smartlead");

    const existingMap = new Map(
      existingAccounts?.map((a) => [a.provider_account_id, { id: a.id, email: a.email }]) || []
    );
    const syncedIds = new Set<string>();

    // Upsert each account
    for (const account of accounts) {
      try {
        const accountIdStr = String(account.id);
        syncedIds.add(accountIdStr);
        const warmup = warmupMap.get(account.id);

        // Calculate reputation from warmup stats
        let reputation: number | null = null;
        if (warmup) {
          const total = warmup.total_inbox + warmup.total_spam;
          if (total > 0) {
            reputation = Math.round((warmup.total_inbox / total) * 100);
          }
        }

        const accountData = {
          provider_type: "smartlead" as EmailAccountProvider,
          provider_account_id: accountIdStr,
          email: account.email,
          first_name: account.first_name || account.from_name || null,
          last_name: account.last_name || null,
          status: "active" as const,
          warmup_enabled: account.warmup_enabled || false,
          warmup_reputation: reputation,
          warmup_emails_sent: warmup?.total_sent || 0,
          warmup_emails_received: warmup?.total_inbox || 0,
          daily_limit: account.max_email_per_day || null,
          last_synced_at: new Date().toISOString(),
        };

        const existing = existingMap.get(accountIdStr);

        if (existing) {
          // Update existing
          await supabase.from("email_accounts").update(accountData).eq("id", existing.id);
          stats.updated++;
        } else {
          // Insert new
          await supabase.from("email_accounts").insert(accountData);
          stats.added++;
        }
      } catch (error) {
        stats.errors.push(`Failed to sync ${account.email}: ${error}`);
      }
    }
  } catch (error) {
    stats.errors.push(`Smartlead sync failed: ${error}`);
  }

  return stats;
}

// POST - Trigger sync from providers
export async function POST(request: NextRequest) {
  try {
    const body = await request.json().catch(() => ({}));
    const providers: string[] = body.providers || ["instantly", "smartlead"];

    const supabase = getSupabase();
    const results: Record<string, SyncStats> = {};

    // Sync from requested providers
    if (providers.includes("instantly")) {
      results.instantly = await syncInstantlyAccounts(supabase);
    }

    if (providers.includes("smartlead")) {
      results.smartlead = await syncSmartleadAccounts(supabase);
    }

    // Calculate totals
    const totals = {
      added: Object.values(results).reduce((sum, r) => sum + r.added, 0),
      updated: Object.values(results).reduce((sum, r) => sum + r.updated, 0),
      removed: Object.values(results).reduce((sum, r) => sum + r.removed, 0),
      errors: Object.values(results).flatMap((r) => r.errors),
    };

    return NextResponse.json({
      success: totals.errors.length === 0,
      synced: results,
      totals,
    });
  } catch (error) {
    console.error("Error during sync:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Sync failed" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/lead-database/sources/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET: List all lead sources
export async function GET(request: NextRequest) {
  try {
    const supabase = getSupabase();
    const searchParams = request.nextUrl.searchParams;
    const limit = parseInt(searchParams.get("limit") || "50");
    const offset = parseInt(searchParams.get("offset") || "0");

    const { data: sources, error, count } = await supabase
      .from("lead_sources")
      .select("*", { count: "exact" })
      .order("created_at", { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) {
      console.error("Error fetching sources:", error);
      throw error;
    }

    return NextResponse.json({
      sources: sources || [],
      total: count || 0,
    });
  } catch (error) {
    console.error("Error fetching lead sources:", error);
    return NextResponse.json(
      { error: "Failed to fetch lead sources" },
      { status: 500 }
    );
  }
}

// POST: Create a new lead source (upload batch)
export async function POST(request: NextRequest) {
  try {
    const supabase = getSupabase();
    const body = await request.json();

    const {
      name,
      file_name,
      industry,
      region,
      sub_region,
      source_type,
      scrape_date,
      tags,
      notes,
      custom_fields,
    } = body;

    if (!name) {
      return NextResponse.json(
        { error: "Name is required" },
        { status: 400 }
      );
    }

    const { data: source, error } = await supabase
      .from("lead_sources")
      .insert({
        name,
        file_name,
        industry,
        region,
        sub_region,
        source_type,
        scrape_date,
        tags: tags || [],
        notes,
        custom_fields: custom_fields || {},
      })
      .select()
      .single();

    if (error) {
      console.error("Error creating source:", error);
      throw error;
    }

    return NextResponse.json({ source });
  } catch (error) {
    console.error("Error creating lead source:", error);
    return NextResponse.json(
      { error: "Failed to create lead source" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/lead-database/upload/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// Known column mappings (flexible - maps common CSV headers to our schema)
const COLUMN_MAPPINGS: Record<string, string> = {
  // URL/Domain
  url: "url",
  website: "url",
  company_website: "url",
  "company website": "url",
  domain: "url",
  // Email
  email: "email",
  "email address": "email",
  work_email: "email",
  // Name
  first_name: "first_name",
  "first name": "first_name",
  firstname: "first_name",
  last_name: "last_name",
  "last name": "last_name",
  lastname: "last_name",
  full_name: "full_name",
  "full name": "full_name",
  name: "full_name",
  // Job
  title: "job_title",
  job_title: "job_title",
  "job title": "job_title",
  position: "job_title",
  role: "job_title",
  // Company
  company: "company_name",
  company_name: "company_name",
  "company name": "company_name",
  organization: "company_name",
  company_size: "company_size",
  "company size": "company_size",
  employees: "company_size",
  headcount: "company_size",
  revenue: "company_revenue",
  company_revenue: "company_revenue",
  founded: "company_founded",
  year_founded: "company_founded",
  // Location
  country: "country",
  city: "city",
  state: "state",
  region: "state",
  // LinkedIn
  linkedin: "linkedin_url",
  linkedin_url: "linkedin_url",
  "linkedin url": "linkedin_url",
  linkedin_profile: "linkedin_url",
  company_linkedin: "company_linkedin",
  // Phone
  phone: "phone",
  phone_number: "phone",
  "phone number": "phone",
  mobile: "phone",
  // Industry
  industry: "industry",
  sector: "industry",
  sub_industry: "sub_industry",
};

function parseCSV(csvText: string): { headers: string[]; rows: string[][] } {
  const lines = csvText.split(/\r?\n/).filter((line) => line.trim());
  if (lines.length === 0) {
    return { headers: [], rows: [] };
  }

  // Simple CSV parsing (handles quoted values)
  const parseLine = (line: string): string[] => {
    const result: string[] = [];
    let current = "";
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        if (inQuotes && line[i + 1] === '"') {
          current += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (char === "," && !inQuotes) {
        result.push(current.trim());
        current = "";
      } else {
        current += char;
      }
    }
    result.push(current.trim());
    return result;
  };

  const headers = parseLine(lines[0]).map((h) => h.toLowerCase().trim());
  const rows = lines.slice(1).map(parseLine);

  return { headers, rows };
}

function mapRow(
  headers: string[],
  row: string[],
  sourceId: string,
  batchIndustry?: string,
  batchRegion?: string
): Record<string, unknown> {
  const result: Record<string, unknown> = {
    source_id: sourceId,
    extra_data: {} as Record<string, string>,
  };

  headers.forEach((header, index) => {
    const value = row[index]?.trim();
    if (!value) return;

    const mappedField = COLUMN_MAPPINGS[header];
    if (mappedField) {
      // Handle special cases
      if (mappedField === "company_founded") {
        const year = parseInt(value);
        if (!isNaN(year) && year > 1800 && year < 2100) {
          result[mappedField] = year;
        }
      } else {
        result[mappedField] = value;
      }
    } else {
      // Store unmapped columns in extra_data
      (result.extra_data as Record<string, string>)[header] = value;
    }
  });

  // Apply batch-level metadata if lead doesn't have it
  if (batchIndustry && !result.industry) {
    result.industry = batchIndustry;
  }

  // Extract domain from URL or email if not set
  if (!result.domain) {
    if (result.url) {
      result.domain = extractDomain(result.url as string);
    } else if (result.email) {
      result.domain = (result.email as string).split("@")[1]?.toLowerCase();
    }
  }

  return result;
}

function extractDomain(url: string): string | null {
  if (!url) return null;
  try {
    let domain = url.toLowerCase();
    domain = domain.replace(/^https?:\/\//, "");
    domain = domain.replace(/^www\./, "");
    domain = domain.split("/")[0];
    domain = domain.split(":")[0];
    return domain || null;
  } catch {
    return null;
  }
}

// POST: Upload and process CSV
export async function POST(request: NextRequest) {
  try {
    const supabase = getSupabase();
    const formData = await request.formData();

    const file = formData.get("file") as File;
    const sourceId = formData.get("source_id") as string;
    const batchIndustry = formData.get("industry") as string | null;
    const batchRegion = formData.get("region") as string | null;

    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    if (!sourceId) {
      return NextResponse.json(
        { error: "Source ID is required" },
        { status: 400 }
      );
    }

    // Read and parse CSV
    const csvText = await file.text();
    const { headers, rows } = parseCSV(csvText);

    if (headers.length === 0) {
      return NextResponse.json(
        { error: "CSV file is empty or invalid" },
        { status: 400 }
      );
    }

    // Process rows in batches
    const BATCH_SIZE = 100;
    let imported = 0;
    let duplicates = 0;
    let errors: string[] = [];

    for (let i = 0; i < rows.length; i += BATCH_SIZE) {
      const batch = rows.slice(i, i + BATCH_SIZE);
      const leadsToInsert = batch
        .map((row) => mapRow(headers, row, sourceId, batchIndustry || undefined, batchRegion || undefined))
        .filter((lead) => lead.email || lead.url); // Must have at least email or URL

      if (leadsToInsert.length === 0) continue;

      // Upsert leads (on conflict: domain + email)
      const { data, error } = await supabase
        .from("enriched_leads")
        .upsert(leadsToInsert, {
          onConflict: "domain,email",
          ignoreDuplicates: false,
        })
        .select("id");

      if (error) {
        console.error("Batch insert error:", error);
        errors.push(`Batch ${Math.floor(i / BATCH_SIZE) + 1}: ${error.message}`);
      } else {
        // Count new vs updated (upsert doesn't distinguish, so we count all as imported)
        imported += data?.length || 0;
      }
    }

    // Update source stats
    await supabase
      .from("lead_sources")
      .update({
        total_records: rows.length,
        imported_records: imported,
        duplicate_records: duplicates,
      })
      .eq("id", sourceId);

    return NextResponse.json({
      success: true,
      stats: {
        total: rows.length,
        imported,
        duplicates,
        errors: errors.length,
      },
      detectedColumns: headers,
      mappedColumns: headers.filter((h) => COLUMN_MAPPINGS[h]),
      unmappedColumns: headers.filter((h) => !COLUMN_MAPPINGS[h]),
      errors: errors.length > 0 ? errors.slice(0, 5) : undefined,
    });
  } catch (error) {
    console.error("Error uploading CSV:", error);
    return NextResponse.json(
      { error: "Failed to process CSV upload" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/settings/logo/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

export async function POST(request: Request) {
  try {
    const supabase = getSupabase();

    const formData = await request.formData();
    const file = formData.get("file") as File | null;

    if (!file) {
      return NextResponse.json(
        { error: "No file provided" },
        { status: 400 }
      );
    }

    // Validate file type
    if (!file.type.startsWith("image/")) {
      return NextResponse.json(
        { error: "File must be an image" },
        { status: 400 }
      );
    }

    // Validate file size (max 2MB)
    if (file.size > 2 * 1024 * 1024) {
      return NextResponse.json(
        { error: "File size must be less than 2MB" },
        { status: 400 }
      );
    }

    // Generate unique filename
    const ext = file.name.split(".").pop() || "png";
    const fileName = `agency-logo-${Date.now()}.${ext}`;

    // Convert File to ArrayBuffer then to Buffer
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Upload to Supabase storage
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from("logos")
      .upload(fileName, buffer, {
        contentType: file.type,
        upsert: true,
      });

    if (uploadError) {
      console.error("Upload error:", uploadError);

      // If bucket doesn't exist, try to create it
      if (uploadError.message?.includes("not found")) {
        // Store as base64 in settings instead
        const base64 = buffer.toString("base64");
        const dataUrl = `data:${file.type};base64,${base64}`;

        // Save to settings table
        const { error: settingsError } = await supabase
          .from("settings")
          .upsert({
            key: "agency_logo_url",
            value: dataUrl,
            is_encrypted: false,
            updated_at: new Date().toISOString(),
          }, {
            onConflict: "key",
          });

        if (settingsError) {
          console.error("Settings error:", settingsError);
          return NextResponse.json(
            { error: "Failed to save logo" },
            { status: 500 }
          );
        }

        return NextResponse.json({ url: dataUrl });
      }

      return NextResponse.json(
        { error: uploadError.message || "Failed to upload logo" },
        { status: 500 }
      );
    }

    // Get public URL
    const { data: urlData } = supabase.storage
      .from("logos")
      .getPublicUrl(fileName);

    const logoUrl = urlData.publicUrl;

    // Save URL to settings
    const { error: settingsError } = await supabase
      .from("settings")
      .upsert({
        key: "agency_logo_url",
        value: logoUrl,
        is_encrypted: false,
        updated_at: new Date().toISOString(),
      }, {
        onConflict: "key",
      });

    if (settingsError) {
      console.error("Settings error:", settingsError);
    }

    return NextResponse.json({ url: logoUrl });
  } catch (error) {
    console.error("Error uploading logo:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to upload logo" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/settings/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - Get all settings (values masked for security)
export async function GET() {
  try {
    const supabase = getSupabase();

    const { data: settings, error } = await supabase
      .from("settings")
      .select("key, value, is_encrypted, updated_at")
      .order("key");

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Mask encrypted values (only show if set or not)
    const maskedSettings = settings.map((setting) => ({
      key: setting.key,
      is_set: !!setting.value && setting.value.length > 0,
      is_encrypted: setting.is_encrypted,
      updated_at: setting.updated_at,
      // Only show last 4 chars for encrypted values
      masked_value: setting.is_encrypted && setting.value
        ? "" + setting.value.slice(-4)
        : setting.value,
    }));

    return NextResponse.json({ settings: maskedSettings });
  } catch (error) {
    console.error("Error fetching settings:", error);
    return NextResponse.json(
      { error: "Failed to fetch settings" },
      { status: 500 }
    );
  }
}

// POST - Update a setting
export async function POST(request: Request) {
  try {
    const supabase = getSupabase();
    const body = await request.json();
    const { key, value } = body;

    if (!key) {
      return NextResponse.json({ error: "Key is required" }, { status: 400 });
    }

    // Check if setting exists
    const { data: existing } = await supabase
      .from("settings")
      .select("id")
      .eq("key", key)
      .single();

    if (existing) {
      // Update existing setting
      const { error } = await supabase
        .from("settings")
        .update({
          value: value || "",
          updated_at: new Date().toISOString(),
        })
        .eq("key", key);

      if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 });
      }
    } else {
      // Insert new setting
      const { error } = await supabase.from("settings").insert({
        key,
        value: value || "",
        is_encrypted: key.includes("key") || key.includes("secret"),
      });

      if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 });
      }
    }

    return NextResponse.json({ success: true, message: "Setting updated" });
  } catch (error) {
    console.error("Error updating setting:", error);
    return NextResponse.json(
      { error: "Failed to update setting" },
      { status: 500 }
    );
  }
}

// DELETE - Clear a setting value
export async function DELETE(request: Request) {
  try {
    const supabase = getSupabase();
    const { searchParams } = new URL(request.url);
    const key = searchParams.get("key");

    if (!key) {
      return NextResponse.json({ error: "Key is required" }, { status: 400 });
    }

    const { error } = await supabase
      .from("settings")
      .update({
        value: "",
        updated_at: new Date().toISOString(),
      })
      .eq("key", key);

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ success: true, message: "Setting cleared" });
  } catch (error) {
    console.error("Error clearing setting:", error);
    return NextResponse.json(
      { error: "Failed to clear setting" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/subscriptions/[id]/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import type { Subscription, BillingCycle } from "@/types/database";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - Get a single subscription
export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const supabase = getSupabase();

    const { data: subscription, error } = await supabase
      .from("subscriptions")
      .select("*")
      .eq("id", id)
      .single();

    if (error) {
      console.error("Error fetching subscription:", error);
      return NextResponse.json(
        { error: error.message },
        { status: error.code === "PGRST116" ? 404 : 500 }
      );
    }

    return NextResponse.json({ subscription });
  } catch (error) {
    console.error("Error fetching subscription:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch subscription" },
      { status: 500 }
    );
  }
}

// PUT - Update a subscription
export async function PUT(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const body = await request.json();
    const {
      name,
      url,
      username,
      password,
      cost,
      billing_cycle,
      renewal_date,
      credits_balance,
      credits_limit,
      category,
      notes,
      is_active,
    } = body;

    const supabase = getSupabase();

    const updateData: Partial<Subscription> = {};

    if (name !== undefined) updateData.name = name.trim();
    if (url !== undefined) updateData.url = url?.trim() || null;
    if (username !== undefined) updateData.username = username?.trim() || null;
    if (password !== undefined) updateData.password = password || null;
    if (cost !== undefined) updateData.cost = parseFloat(cost) || 0;
    if (billing_cycle !== undefined) updateData.billing_cycle = billing_cycle as BillingCycle;
    if (renewal_date !== undefined) updateData.renewal_date = renewal_date || null;
    if (credits_balance !== undefined) updateData.credits_balance = parseInt(credits_balance) || 0;
    if (credits_limit !== undefined) updateData.credits_limit = parseInt(credits_limit) || 0;
    if (category !== undefined) updateData.category = category?.trim() || null;
    if (notes !== undefined) updateData.notes = notes?.trim() || null;
    if (is_active !== undefined) updateData.is_active = is_active;

    const { data: subscription, error } = await supabase
      .from("subscriptions")
      .update(updateData)
      .eq("id", id)
      .select()
      .single();

    if (error) {
      console.error("Error updating subscription:", error);
      return NextResponse.json(
        { error: error.message },
        { status: error.code === "PGRST116" ? 404 : 500 }
      );
    }

    return NextResponse.json({ subscription });
  } catch (error) {
    console.error("Error updating subscription:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to update subscription" },
      { status: 500 }
    );
  }
}

// DELETE - Delete a subscription
export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const supabase = getSupabase();

    const { error } = await supabase
      .from("subscriptions")
      .delete()
      .eq("id", id);

    if (error) {
      console.error("Error deleting subscription:", error);
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting subscription:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to delete subscription" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/subscriptions/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import type { Subscription, BillingCycle } from "@/types/database";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - List all subscriptions
export async function GET() {
  try {
    const supabase = getSupabase();

    const { data: subscriptions, error } = await supabase
      .from("subscriptions")
      .select("*")
      .order("name");

    if (error) {
      console.error("Error fetching subscriptions:", error);
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json({ subscriptions: subscriptions || [] });
  } catch (error) {
    console.error("Error fetching subscriptions:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch subscriptions" },
      { status: 500 }
    );
  }
}

// POST - Create a new subscription
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const {
      name,
      url,
      username,
      password,
      cost,
      billing_cycle,
      renewal_date,
      credits_balance,
      credits_limit,
      category,
      notes,
    } = body;

    if (!name || typeof name !== "string" || name.trim().length === 0) {
      return NextResponse.json(
        { error: "Subscription name is required" },
        { status: 400 }
      );
    }

    const supabase = getSupabase();

    const insertData: Partial<Subscription> = {
      name: name.trim(),
      url: url?.trim() || null,
      username: username?.trim() || null,
      password: password || null,
      cost: parseFloat(cost) || 0,
      billing_cycle: (billing_cycle as BillingCycle) || "monthly",
      renewal_date: renewal_date || null,
      credits_balance: parseInt(credits_balance) || 0,
      credits_limit: parseInt(credits_limit) || 0,
      category: category?.trim() || null,
      notes: notes?.trim() || null,
      is_active: true,
    };

    const { data: subscription, error } = await supabase
      .from("subscriptions")
      .insert(insertData)
      .select()
      .single();

    if (error) {
      console.error("Error creating subscription:", error);
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json({ subscription });
  } catch (error) {
    console.error("Error creating subscription:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to create subscription" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/campaigns/[campaignId]/leads/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

interface RouteParams {
  params: Promise<{ campaignId: string }>;
}

// GET - Get leads for a campaign
export async function GET(request: Request, { params }: RouteParams) {
  try {
    const { campaignId } = await params;
    const supabase = getSupabase();

    // Get leads for this campaign
    const { data: leads, error } = await supabase
      .from("leads")
      .select("*")
      .eq("campaign_id", campaignId)
      .order("updated_at", { ascending: false })
      .limit(100);

    if (error) {
      return NextResponse.json(
        { error: "Failed to fetch leads" },
        { status: 500 }
      );
    }

    return NextResponse.json({ leads: leads || [] });
  } catch (error) {
    console.error("Error fetching campaign leads:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch leads" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/campaigns/[campaignId]/sync-emails/route.ts">
// Historical Email Sync Endpoint
// Fetches all email threads for leads in a campaign from Instantly API
// and stores them in the lead_emails table

import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { getProviderForCampaign } from "@/lib/providers";

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ campaignId: string }> }
) {
  const { campaignId } = await params;

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseServiceKey) {
    return NextResponse.json(
      { error: "Server configuration error" },
      { status: 500 }
    );
  }

  const supabase = createClient(supabaseUrl, supabaseServiceKey);

  try {
    // Fetch campaign details
    const { data: campaign, error: campaignError } = await supabase
      .from("campaigns")
      .select("id, client_id, name, provider_type, provider_campaign_id, instantly_campaign_id")
      .eq("id", campaignId)
      .single();

    if (campaignError || !campaign) {
      return NextResponse.json(
        { error: "Campaign not found" },
        { status: 404 }
      );
    }

    const providerCampaignId = campaign.provider_campaign_id || campaign.instantly_campaign_id;
    if (!providerCampaignId) {
      return NextResponse.json(
        { error: "Campaign not linked to provider" },
        { status: 400 }
      );
    }

    // Get provider instance
    const provider = await getProviderForCampaign(campaignId);

    console.log(`[SyncEmails] Starting email sync for campaign ${campaignId}`);

    // Get all leads for this campaign that have replied or are positive
    const { data: leads, error: leadsError } = await supabase
      .from("leads")
      .select("id, email, provider_lead_id, instantly_lead_id")
      .eq("campaign_id", campaignId)
      .or("has_replied.eq.true,is_positive_reply.eq.true,email_reply_count.gt.0");

    if (leadsError) {
      return NextResponse.json(
        { error: "Failed to fetch leads" },
        { status: 500 }
      );
    }

    if (!leads || leads.length === 0) {
      return NextResponse.json({
        success: true,
        message: "No leads with replies found",
        synced: 0,
      });
    }

    console.log(`[SyncEmails] Found ${leads.length} leads with replies to sync`);

    let totalEmailsSynced = 0;
    let leadsProcessed = 0;
    const errors: string[] = [];

    // Check if provider supports email fetching
    if (!('fetchEmailsForLead' in provider) || typeof provider.fetchEmailsForLead !== 'function') {
      return NextResponse.json(
        { error: "Provider does not support email fetching" },
        { status: 400 }
      );
    }

    // Process leads in batches to avoid rate limits
    const batchSize = 5;
    for (let i = 0; i < leads.length; i += batchSize) {
      const batch = leads.slice(i, i + batchSize);

      await Promise.all(
        batch.map(async (lead) => {
          try {
            // Fetch emails for this lead from provider
            const emails = await provider.fetchEmailsForLead(providerCampaignId, lead.email);

            if (!emails || emails.length === 0) {
              return;
            }

            // Get existing email IDs to avoid duplicates
            const { data: existingEmails } = await supabase
              .from("lead_emails")
              .select("provider_email_id")
              .eq("lead_id", lead.id);

            const existingIds = new Set(
              (existingEmails || []).map((e) => e.provider_email_id).filter(Boolean)
            );

            // Insert new emails
            const newEmails = emails.filter(
              (email) => !email.id || !existingIds.has(email.id)
            );

            if (newEmails.length === 0) {
              return;
            }

            const emailRecords = newEmails.map((email) => ({
              lead_id: lead.id,
              campaign_id: campaignId,
              provider_email_id: email.id,
              provider_thread_id: email.threadId,
              direction: email.isReply ? "inbound" : "outbound",
              from_email: email.fromEmail,
              to_email: email.toEmail || lead.email,
              subject: email.subject,
              body_text: email.bodyText,
              body_html: email.bodyHtml,
              sent_at: email.sentAt,
              created_at: new Date().toISOString(),
            }));

            const { error: insertError } = await supabase
              .from("lead_emails")
              .insert(emailRecords);

            if (insertError) {
              console.error(`[SyncEmails] Error inserting emails for ${lead.email}:`, insertError);
              errors.push(`${lead.email}: ${insertError.message}`);
            } else {
              totalEmailsSynced += newEmails.length;
            }

            leadsProcessed++;
          } catch (err) {
            const errorMsg = err instanceof Error ? err.message : "Unknown error";
            console.error(`[SyncEmails] Error syncing emails for ${lead.email}:`, err);
            errors.push(`${lead.email}: ${errorMsg}`);
          }
        })
      );

      // Small delay between batches to respect rate limits
      if (i + batchSize < leads.length) {
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }

    // Update last sync timestamp
    await supabase
      .from("campaigns")
      .update({ last_email_sync_at: new Date().toISOString() })
      .eq("id", campaignId);

    console.log(`[SyncEmails] Completed: ${totalEmailsSynced} emails synced for ${leadsProcessed} leads`);

    return NextResponse.json({
      success: true,
      totalLeads: leads.length,
      leadsProcessed,
      emailsSynced: totalEmailsSynced,
      errors: errors.length > 0 ? errors.slice(0, 10) : undefined, // Limit errors in response
    });
  } catch (error) {
    console.error("[SyncEmails] Error:", error);
    return NextResponse.json(
      {
        error: error instanceof Error ? error.message : "Failed to sync emails",
      },
      { status: 500 }
    );
  }
}

// GET endpoint to check email sync status
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ campaignId: string }> }
) {
  const { campaignId } = await params;

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseServiceKey) {
    return NextResponse.json(
      { error: "Server configuration error" },
      { status: 500 }
    );
  }

  const supabase = createClient(supabaseUrl, supabaseServiceKey);

  // Get campaign with last sync time
  const { data: campaign } = await supabase
    .from("campaigns")
    .select("last_email_sync_at")
    .eq("id", campaignId)
    .single();

  // Count emails for this campaign
  const { count: emailCount } = await supabase
    .from("lead_emails")
    .select("*", { count: "exact", head: true })
    .eq("campaign_id", campaignId);

  // Count leads with emails
  const { data: leadsWithEmails } = await supabase
    .from("lead_emails")
    .select("lead_id")
    .eq("campaign_id", campaignId);

  const uniqueLeadsWithEmails = new Set(leadsWithEmails?.map((e) => e.lead_id) || []).size;

  return NextResponse.json({
    lastSyncAt: campaign?.last_email_sync_at,
    emailCount: emailCount || 0,
    leadsWithEmails: uniqueLeadsWithEmails,
  });
}
</file>

<file path="src/app/api/clients/[clientId]/leads/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - Fetch leads for a client with optional filters
export async function GET(
  request: Request,
  { params }: { params: Promise<{ clientId: string }> }
) {
  try {
    const { clientId } = await params;
    const { searchParams } = new URL(request.url);

    const positiveOnly = searchParams.get("positive") === "true";
    const status = searchParams.get("status");
    const limit = parseInt(searchParams.get("limit") || "100", 10);

    const supabase = getSupabase();

    let query = supabase
      .from("leads")
      .select("*")
      .eq("client_id", clientId)
      .order("created_at", { ascending: false })
      .limit(limit);

    if (positiveOnly) {
      query = query.eq("is_positive_reply", true);
    }

    if (status) {
      query = query.eq("status", status);
    }

    const { data: leads, error } = await query;

    if (error) {
      console.error("Error fetching leads:", error);
      return NextResponse.json(
        { error: "Failed to fetch leads" },
        { status: 500 }
      );
    }

    return NextResponse.json({ leads });
  } catch (error) {
    console.error("Error in leads fetch:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch leads" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/clients/[clientId]/logo/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ clientId: string }> }
) {
  try {
    const { clientId } = await params;
    const supabase = getSupabase();

    const formData = await request.formData();
    const file = formData.get("file") as File | null;

    if (!file) {
      return NextResponse.json(
        { error: "No file provided" },
        { status: 400 }
      );
    }

    // Validate file type
    if (!file.type.startsWith("image/")) {
      return NextResponse.json(
        { error: "File must be an image" },
        { status: 400 }
      );
    }

    // Validate file size (max 2MB)
    if (file.size > 2 * 1024 * 1024) {
      return NextResponse.json(
        { error: "File size must be less than 2MB" },
        { status: 400 }
      );
    }

    // Generate unique filename
    const ext = file.name.split(".").pop() || "png";
    const fileName = `client-${clientId}-logo-${Date.now()}.${ext}`;

    // Convert File to ArrayBuffer then to Buffer
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Upload to Supabase storage
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from("logos")
      .upload(fileName, buffer, {
        contentType: file.type,
        upsert: true,
      });

    if (uploadError) {
      console.error("Upload error:", uploadError);

      // If bucket doesn't exist, store as base64 in the database
      if (uploadError.message?.includes("not found")) {
        const base64 = buffer.toString("base64");
        const dataUrl = `data:${file.type};base64,${base64}`;

        // Save directly to client record
        const { error: updateError } = await supabase
          .from("clients")
          .update({ logo_url: dataUrl })
          .eq("id", clientId);

        if (updateError) {
          console.error("Update error:", updateError);
          return NextResponse.json(
            { error: "Failed to save logo" },
            { status: 500 }
          );
        }

        return NextResponse.json({ url: dataUrl });
      }

      return NextResponse.json(
        { error: uploadError.message || "Failed to upload logo" },
        { status: 500 }
      );
    }

    // Get public URL
    const { data: urlData } = supabase.storage
      .from("logos")
      .getPublicUrl(fileName);

    const logoUrl = urlData.publicUrl;

    // Update client with logo URL
    const { error: updateError } = await supabase
      .from("clients")
      .update({ logo_url: logoUrl })
      .eq("id", clientId);

    if (updateError) {
      console.error("Update error:", updateError);
    }

    return NextResponse.json({ url: logoUrl });
  } catch (error) {
    console.error("Error uploading logo:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to upload logo" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/instantly/accounts/route.ts">
import { NextResponse } from "next/server";
import {
  fetchAllInstantlyAccounts,
  getWarmupAnalytics,
  enableWarmup,
  disableWarmup,
  testAccountVitals,
  getInstantlyClient,
} from "@/lib/instantly";

// GET - List all accounts with warmup status
export async function GET() {
  try {
    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    const accounts = await fetchAllInstantlyAccounts();

    // Get warmup analytics for all accounts
    const emails = accounts.map(a => a.email);
    let warmupAnalytics: Awaited<ReturnType<typeof getWarmupAnalytics>> = [];

    if (emails.length > 0) {
      try {
        warmupAnalytics = await getWarmupAnalytics(emails);
      } catch {
        // Warmup analytics might fail if not available
        console.log("Warmup analytics not available");
      }
    }

    // Merge warmup analytics into accounts
    const warmupMap = new Map(warmupAnalytics.map(w => [w.email, w]));
    const accountsWithWarmup = accounts.map(account => ({
      ...account,
      warmup: warmupMap.get(account.email) || null,
    }));

    return NextResponse.json({ accounts: accountsWithWarmup });
  } catch (error) {
    console.error("Error fetching accounts:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch accounts" },
      { status: 500 }
    );
  }
}

// POST - Enable/disable warmup or test vitals
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { action, emails } = body as {
      action: "enable_warmup" | "disable_warmup" | "test_vitals";
      emails: string[];
    };

    if (!action || !emails || emails.length === 0) {
      return NextResponse.json(
        { error: "action and emails array are required" },
        { status: 400 }
      );
    }

    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    let result;
    switch (action) {
      case "enable_warmup":
        result = await enableWarmup(emails);
        break;
      case "disable_warmup":
        result = await disableWarmup(emails);
        break;
      case "test_vitals":
        result = await testAccountVitals(emails);
        break;
      default:
        return NextResponse.json(
          { error: "Invalid action. Use 'enable_warmup', 'disable_warmup', or 'test_vitals'" },
          { status: 400 }
        );
    }

    return NextResponse.json({ success: true, action, ...result });
  } catch (error) {
    console.error("Error processing account action:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to process action" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/instantly/campaigns/analytics/daily/route.ts">
import { NextResponse } from "next/server";
import {
  getCampaignDailyAnalytics,
  getInstantlyClient,
} from "@/lib/instantly";

// GET - Get daily analytics breakdown
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const campaignId = searchParams.get("campaign_id");
    const startDate = searchParams.get("start_date");
    const endDate = searchParams.get("end_date");

    const client = getInstantlyClient();
    if (!(await client.isConfiguredAsync())) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    const params: { campaign_id?: string; start_date?: string; end_date?: string } = {};
    if (campaignId) params.campaign_id = campaignId;
    if (startDate) params.start_date = startDate;
    if (endDate) params.end_date = endDate;

    const daily = await getCampaignDailyAnalytics(params);
    return NextResponse.json({ daily });
  } catch (error) {
    console.error("Error fetching daily analytics:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch daily analytics" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/instantly/campaigns/analytics/overview/route.ts">
import { NextResponse } from "next/server";
import {
  getCampaignOverviewAnalytics,
  getInstantlyClient,
} from "@/lib/instantly";

// GET - Get campaign overview analytics
export async function GET() {
  try {
    const client = getInstantlyClient();
    if (!(await client.isConfiguredAsync())) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    const overview = await getCampaignOverviewAnalytics();
    return NextResponse.json({ overview });
  } catch (error) {
    console.error("Error fetching overview analytics:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch overview" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/instantly/campaigns/analytics/route.ts">
import { NextResponse } from "next/server";
import {
  getCampaignAnalytics,
  getCampaignOverviewAnalytics,
  getCampaignDailyAnalytics,
  getInstantlyClient,
} from "@/lib/instantly";

// GET - Get campaign analytics
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const campaignId = searchParams.get("campaign_id");
    const type = searchParams.get("type") || "all"; // "all", "overview", "daily"
    const startDate = searchParams.get("start_date");
    const endDate = searchParams.get("end_date");

    const client = getInstantlyClient();
    if (!(await client.isConfiguredAsync())) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    const params: { campaign_id?: string; start_date?: string; end_date?: string } = {};
    if (campaignId) params.campaign_id = campaignId;
    if (startDate) params.start_date = startDate;
    if (endDate) params.end_date = endDate;

    if (type === "overview") {
      const overview = await getCampaignOverviewAnalytics();
      return NextResponse.json({ overview });
    }

    if (type === "daily") {
      const daily = await getCampaignDailyAnalytics(params);
      return NextResponse.json({ daily });
    }

    // type === "all" - fetch both
    const [analytics, overview, daily] = await Promise.all([
      getCampaignAnalytics(params),
      getCampaignOverviewAnalytics(),
      getCampaignDailyAnalytics(params),
    ]);

    return NextResponse.json({
      analytics,
      overview,
      daily,
    });
  } catch (error) {
    console.error("Error fetching analytics:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch analytics" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/instantly/status/route.ts">
import { NextResponse } from "next/server";
import { getInstantlyClient } from "@/lib/instantly";

// Lightweight status check - just verify API is configured and working
export async function GET() {
  try {
    const client = getInstantlyClient();

    if (!client.isConfigured()) {
      return NextResponse.json({
        configured: false,
        connected: false,
        campaignCount: 0,
        accountCount: 0,
      });
    }

    // Make a single lightweight request to verify connection
    // Using limit=1 to minimize data transfer
    const response = await client.get<{ items: unknown[] }>("/campaigns", { limit: 1 });

    return NextResponse.json({
      configured: true,
      connected: true,
      // We don't know exact counts without fetching all, so indicate "available"
      message: "API connected successfully",
    });
  } catch (error) {
    return NextResponse.json({
      configured: true,
      connected: false,
      error: error instanceof Error ? error.message : "Connection failed",
    });
  }
}
</file>

<file path="src/app/api/instantly/validate-key/route.ts">
import { NextResponse } from "next/server";

// POST - Validate an Instantly API key
export async function POST(request: Request) {
  try {
    const { apiKey } = await request.json();

    if (!apiKey || typeof apiKey !== "string") {
      return NextResponse.json({ valid: false, error: "API key is required" });
    }

    // Test the API key by making a simple request to Instantly
    const response = await fetch("https://api.instantly.ai/api/v2/campaigns?limit=1", {
      method: "GET",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
    });

    if (response.ok) {
      // Try to get workspace info for additional validation
      const data = await response.json();
      return NextResponse.json({
        valid: true,
        campaigns_count: data.items?.length || 0,
      });
    }

    if (response.status === 401 || response.status === 403) {
      return NextResponse.json({ valid: false, error: "Invalid or unauthorized API key" });
    }

    return NextResponse.json({ valid: false, error: "Failed to validate API key" });
  } catch (error) {
    console.error("Error validating Instantly API key:", error);
    return NextResponse.json({ valid: false, error: "Validation failed" });
  }
}
</file>

<file path="src/app/api/providers/[provider]/campaigns/route.ts">
// Provider Campaigns List Endpoint
// Fetches available campaigns from a provider using the provided API key

import { NextResponse } from "next/server";
import { createProvider, type ProviderType, type ProviderCampaign } from "@/lib/providers";

const SUPPORTED_PROVIDERS: ProviderType[] = ["instantly", "smartlead"];

export async function POST(
  request: Request,
  { params }: { params: Promise<{ provider: string }> }
) {
  try {
    const { provider } = await params;

    // Validate provider
    if (!SUPPORTED_PROVIDERS.includes(provider as ProviderType)) {
      return NextResponse.json(
        { error: `Unsupported provider: ${provider}` },
        { status: 400 }
      );
    }

    const { apiKey } = await request.json();

    if (!apiKey || typeof apiKey !== "string") {
      return NextResponse.json(
        { error: "API key is required" },
        { status: 400 }
      );
    }

    // Create provider and fetch campaigns
    const providerInstance = createProvider(provider as ProviderType, apiKey);
    const campaigns = await providerInstance.fetchCampaigns();

    // Map to response format
    const response: ProviderCampaign[] = campaigns.map((c) => ({
      id: c.id,
      name: c.name,
      status: c.status,
      createdAt: c.createdAt,
      leadsCount: c.leadsCount,
      emailsSentCount: c.emailsSentCount,
      repliesCount: c.repliesCount,
    }));

    return NextResponse.json({ campaigns: response });
  } catch (error) {
    console.error("[Provider Campaigns] Error:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch campaigns" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/providers/[provider]/validate/route.ts">
// Provider API Key Validation Endpoint
// Validates an API key for a specific provider

import { NextResponse } from "next/server";
import { createProvider, type ProviderType } from "@/lib/providers";

const SUPPORTED_PROVIDERS: ProviderType[] = ["instantly", "smartlead"];

export async function POST(
  request: Request,
  { params }: { params: Promise<{ provider: string }> }
) {
  try {
    const { provider } = await params;

    // Validate provider
    if (!SUPPORTED_PROVIDERS.includes(provider as ProviderType)) {
      return NextResponse.json(
        { valid: false, error: `Unsupported provider: ${provider}` },
        { status: 400 }
      );
    }

    const { apiKey } = await request.json();

    if (!apiKey || typeof apiKey !== "string") {
      return NextResponse.json(
        { valid: false, error: "API key is required" },
        { status: 400 }
      );
    }

    // Create provider and validate
    const providerInstance = createProvider(provider as ProviderType, apiKey);
    const isValid = await providerInstance.validateApiKey();

    return NextResponse.json({ valid: isValid });
  } catch (error) {
    console.error("[Provider Validate] Error:", error);
    return NextResponse.json(
      {
        valid: false,
        error: error instanceof Error ? error.message : "Validation failed",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/webhooks/[provider]/route.ts">
// Dynamic Multi-Provider Webhook Handler
// Handles webhooks for any provider (Instantly, Smartlead, etc.)

import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { headers } from "next/headers";
import {
  createProvider,
  type ProviderType,
  type ProviderWebhookPayload,
  type WebhookEventType,
} from "@/lib/providers";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

const SUPPORTED_PROVIDERS: ProviderType[] = ["instantly", "smartlead"];

// Get signature header name for each provider
function getSignatureHeader(provider: ProviderType): string {
  switch (provider) {
    case "instantly":
      return "x-instantly-signature";
    case "smartlead":
      return "x-smartlead-signature";
    default:
      return "x-webhook-signature";
  }
}

// Find campaign by provider campaign ID
async function findCampaign(
  supabase: ReturnType<typeof getSupabase>,
  providerType: ProviderType,
  providerCampaignId: string
) {
  // Try provider_campaign_id first
  let query = supabase
    .from("campaigns")
    .select("id, client_id, webhook_secret, provider_type")
    .eq("provider_type", providerType)
    .eq("provider_campaign_id", providerCampaignId)
    .single();

  let { data: campaign, error } = await query;

  // Fallback to instantly_campaign_id for backwards compatibility
  if (!campaign && providerType === "instantly") {
    const fallback = await supabase
      .from("campaigns")
      .select("id, client_id, webhook_secret, provider_type")
      .eq("instantly_campaign_id", providerCampaignId)
      .single();
    campaign = fallback.data;
    error = fallback.error;
  }

  return campaign;
}

// Find lead by campaign and email
async function findLead(
  supabase: ReturnType<typeof getSupabase>,
  campaignId: string,
  email: string
) {
  const { data: lead } = await supabase
    .from("leads")
    .select("id, email_open_count, email_click_count, email_reply_count")
    .eq("campaign_id", campaignId)
    .eq("email", email)
    .single();

  return lead;
}

// Process webhook event and update database
async function processWebhookEvent(
  supabase: ReturnType<typeof getSupabase>,
  providerType: ProviderType,
  payload: ProviderWebhookPayload,
  campaignId: string,
  leadId: string,
  leadEmail: string
) {
  const now = new Date().toISOString();

  // Log email event
  await supabase.from("email_events").insert({
    lead_id: leadId,
    campaign_id: campaignId,
    event_type: mapEventTypeToDb(payload.eventType),
    provider_type: providerType,
    provider_event_id: payload.providerEventId,
    email_subject: payload.emailSubject,
    link_clicked: payload.linkClicked,
    timestamp: payload.timestamp || now,
    metadata: {
      raw_payload: payload.rawPayload,
      thread_id: payload.threadId,
      sequence_step: payload.sequenceStep,
    },
  });

  // Update lead based on event type
  switch (payload.eventType) {
    case "email_sent":
      await supabase
        .from("leads")
        .update({
          status: "contacted",
          last_contacted_at: payload.timestamp || now,
        })
        .eq("id", leadId);

      // Store outbound email if data provided
      if (payload.emailSubject || payload.emailBody) {
        await storeEmail(supabase, {
          leadId,
          campaignId,
          providerId: payload.providerEventId,
          direction: "outbound",
          fromEmail: payload.emailFrom || "",
          toEmail: leadEmail,
          subject: payload.emailSubject,
          body: payload.emailBody,
          sentAt: payload.timestamp,
          threadId: payload.threadId,
          sequenceStep: payload.sequenceStep,
        });
      }
      break;

    case "email_opened":
      // Increment open count
      const { data: leadForOpen } = await supabase
        .from("leads")
        .select("email_open_count")
        .eq("id", leadId)
        .single();
      if (leadForOpen) {
        await supabase
          .from("leads")
          .update({
            email_open_count: (leadForOpen.email_open_count || 0) + 1,
          })
          .eq("id", leadId);
      }
      break;

    case "link_clicked":
      // Increment click count
      const { data: leadForClick } = await supabase
        .from("leads")
        .select("email_click_count")
        .eq("id", leadId)
        .single();
      if (leadForClick) {
        await supabase
          .from("leads")
          .update({
            email_click_count: (leadForClick.email_click_count || 0) + 1,
          })
          .eq("id", leadId);
      }
      break;

    case "reply_received":
      await supabase
        .from("leads")
        .update({
          status: "replied",
          has_replied: true,
        })
        .eq("id", leadId);

      // Increment reply count
      const { data: leadForReply } = await supabase
        .from("leads")
        .select("email_reply_count")
        .eq("id", leadId)
        .single();
      if (leadForReply) {
        await supabase
          .from("leads")
          .update({
            email_reply_count: (leadForReply.email_reply_count || 0) + 1,
          })
          .eq("id", leadId);
      }

      // Store inbound email
      if (payload.emailSubject || payload.emailBody) {
        await storeEmail(supabase, {
          leadId,
          campaignId,
          providerId: payload.providerEventId,
          direction: "inbound",
          fromEmail: leadEmail,
          toEmail: payload.emailTo || "",
          subject: payload.emailSubject,
          body: payload.emailBody,
          sentAt: payload.timestamp,
          threadId: payload.threadId,
        });
      }
      break;

    case "lead_interested":
      await supabase
        .from("leads")
        .update({
          status: "replied",
          is_positive_reply: true,
          has_replied: true,
        })
        .eq("id", leadId);
      break;

    case "lead_not_interested":
      await supabase
        .from("leads")
        .update({
          status: "not_interested",
          has_replied: true,
        })
        .eq("id", leadId);
      break;

    case "meeting_booked":
      await supabase
        .from("leads")
        .update({
          status: "booked",
          is_positive_reply: true,
        })
        .eq("id", leadId);
      break;

    case "email_bounced":
      // Log bounce but don't change lead status drastically
      await supabase
        .from("leads")
        .update({
          metadata: {
            bounced: true,
            bounce_type: payload.bounceType,
            bounce_reason: payload.bounceReason,
            bounced_at: payload.timestamp,
          },
        })
        .eq("id", leadId);
      break;

    case "unsubscribed":
      await supabase
        .from("leads")
        .update({
          metadata: {
            unsubscribed: true,
            unsubscribed_at: payload.timestamp,
          },
        })
        .eq("id", leadId);
      break;

    default:
      console.log(`[Webhook] Unhandled event type: ${payload.eventType}`);
  }
}

// Store email in lead_emails table
async function storeEmail(
  supabase: ReturnType<typeof getSupabase>,
  params: {
    leadId: string;
    campaignId: string;
    providerId?: string;
    direction: "inbound" | "outbound";
    fromEmail: string;
    toEmail: string;
    subject?: string;
    body?: string;
    sentAt?: string;
    threadId?: string;
    sequenceStep?: number;
  }
) {
  // Check if email already exists
  if (params.providerId) {
    const { data: existing } = await supabase
      .from("lead_emails")
      .select("id")
      .eq("lead_id", params.leadId)
      .eq("provider_email_id", params.providerId)
      .single();

    if (existing) return; // Already stored
  }

  await supabase.from("lead_emails").insert({
    lead_id: params.leadId,
    campaign_id: params.campaignId,
    provider_email_id: params.providerId,
    provider_thread_id: params.threadId,
    direction: params.direction,
    from_email: params.fromEmail,
    to_email: params.toEmail,
    subject: params.subject || (params.direction === "inbound" ? "Reply" : "Outreach"),
    body_text: params.body,
    sent_at: params.sentAt || new Date().toISOString(),
    sequence_step: params.sequenceStep,
  });
}

// Map webhook event type to database event type
function mapEventTypeToDb(
  eventType: WebhookEventType
): "sent" | "opened" | "clicked" | "replied" | "bounced" | "unsubscribed" | "spam_complaint" {
  switch (eventType) {
    case "email_sent":
      return "sent";
    case "email_opened":
      return "opened";
    case "link_clicked":
      return "clicked";
    case "reply_received":
    case "lead_interested":
    case "lead_not_interested":
      return "replied";
    case "email_bounced":
      return "bounced";
    case "unsubscribed":
      return "unsubscribed";
    default:
      return "sent";
  }
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ provider: string }> }
) {
  try {
    const { provider } = await params;

    // Validate provider
    if (!SUPPORTED_PROVIDERS.includes(provider as ProviderType)) {
      return NextResponse.json(
        { error: `Unsupported provider: ${provider}` },
        { status: 400 }
      );
    }

    const providerType = provider as ProviderType;
    const headersList = await headers();
    const signature = headersList.get(getSignatureHeader(providerType));
    const rawBody = await request.text();

    const supabase = getSupabase();

    // Parse webhook payload using provider-specific logic
    // For now, we'll use a temporary API key just for parsing (we'll verify per-campaign)
    let webhookPayload: ProviderWebhookPayload;
    try {
      // Create a temporary provider instance for parsing
      const tempProvider = createProvider(providerType, "temp-key-for-parsing");
      webhookPayload = tempProvider.parseWebhookPayload(rawBody, {
        signature: signature || "",
      });
    } catch (error) {
      console.error(`[Webhook] Failed to parse ${provider} webhook:`, error);
      return NextResponse.json(
        { error: "Invalid webhook payload" },
        { status: 400 }
      );
    }

    console.log(`[Webhook] Received ${provider} event: ${webhookPayload.eventType}`);

    // Find the campaign
    if (!webhookPayload.campaignId) {
      console.log("[Webhook] No campaign ID in webhook payload");
      return NextResponse.json({ success: true, message: "No campaign ID" });
    }

    const campaign = await findCampaign(supabase, providerType, webhookPayload.campaignId);
    if (!campaign) {
      console.log(`[Webhook] Campaign not found for provider campaign: ${webhookPayload.campaignId}`);
      return NextResponse.json({ success: true, message: "Campaign not found" });
    }

    // Verify signature using campaign-specific secret
    if (campaign.webhook_secret && signature) {
      const tempProvider = createProvider(providerType, "temp-key-for-verify");
      const isValid = tempProvider.verifyWebhookSignature(
        rawBody,
        signature,
        campaign.webhook_secret
      );
      if (!isValid) {
        console.log("[Webhook] Invalid signature");
        return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
      }
    }

    // Find the lead
    if (!webhookPayload.leadEmail) {
      console.log("[Webhook] No lead email in webhook payload");
      return NextResponse.json({ success: true, message: "No lead email" });
    }

    const lead = await findLead(supabase, campaign.id, webhookPayload.leadEmail);
    if (!lead) {
      console.log(`[Webhook] Lead not found: ${webhookPayload.leadEmail}`);
      return NextResponse.json({ success: true, message: "Lead not found" });
    }

    // Process the event
    await processWebhookEvent(
      supabase,
      providerType,
      webhookPayload,
      campaign.id,
      lead.id,
      webhookPayload.leadEmail
    );

    return NextResponse.json({
      success: true,
      event: webhookPayload.eventType,
      provider: providerType,
    });
  } catch (error) {
    console.error("[Webhook] Error:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Webhook processing failed" },
      { status: 500 }
    );
  }
}

// GET endpoint to check webhook status
export async function GET(
  request: Request,
  { params }: { params: Promise<{ provider: string }> }
) {
  const { provider } = await params;

  if (!SUPPORTED_PROVIDERS.includes(provider as ProviderType)) {
    return NextResponse.json(
      { error: `Unsupported provider: ${provider}` },
      { status: 400 }
    );
  }

  return NextResponse.json({
    status: "active",
    provider,
    endpoint: `/api/webhooks/${provider}`,
    supported_events: [
      "email_sent",
      "email_opened",
      "link_clicked",
      "reply_received",
      "lead_interested",
      "lead_not_interested",
      "meeting_booked",
      "email_bounced",
      "unsubscribed",
    ],
  });
}
</file>

<file path="src/app/auth/accept-invite/route.ts">
import { createClient } from "@supabase/supabase-js";
import { createClient as createServerClient } from "@/lib/supabase/server";
import { NextResponse } from "next/server";

function getSupabaseAdmin() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url);
  const token = searchParams.get("token");
  const code = searchParams.get("code");

  // If there's an auth code, exchange it first
  if (code) {
    const supabase = await createServerClient();
    const { error } = await supabase.auth.exchangeCodeForSession(code);

    if (error) {
      return NextResponse.redirect(`${origin}/login?error=Could not authenticate`);
    }
  }

  if (!token) {
    return NextResponse.redirect(`${origin}/login?error=Invalid invitation`);
  }

  const adminSupabase = getSupabaseAdmin();
  const supabase = await createServerClient();

  // Get the current user
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    // User needs to complete auth first, redirect to login with token
    return NextResponse.redirect(`${origin}/login?invite=${token}`);
  }

  // Find the invitation
  const { data: invitation, error: inviteError } = await adminSupabase
    .from("client_invitations")
    .select("*")
    .eq("token", token)
    .is("accepted_at", null)
    .single();

  if (inviteError || !invitation) {
    return NextResponse.redirect(`${origin}/dashboard?error=Invalid or expired invitation`);
  }

  // Check if invitation has expired
  if (new Date(invitation.expires_at) < new Date()) {
    return NextResponse.redirect(`${origin}/dashboard?error=Invitation has expired`);
  }

  // Check if user email matches invitation
  if (user.email?.toLowerCase() !== invitation.email.toLowerCase()) {
    return NextResponse.redirect(
      `${origin}/dashboard?error=This invitation was sent to a different email address`
    );
  }

  // Ensure profile exists
  const { data: existingProfile } = await adminSupabase
    .from("profiles")
    .select("id")
    .eq("id", user.id)
    .single();

  if (!existingProfile) {
    // Create profile
    await adminSupabase.from("profiles").insert({
      id: user.id,
      email: user.email,
      role: "client",
    });
  }

  // Link user to client
  const { error: linkError } = await adminSupabase
    .from("client_users")
    .upsert({
      client_id: invitation.client_id,
      user_id: user.id,
      role: invitation.role || "owner",
    }, {
      onConflict: "client_id,user_id",
    });

  if (linkError) {
    console.error("Error linking user to client:", linkError);
    return NextResponse.redirect(`${origin}/dashboard?error=Failed to accept invitation`);
  }

  // Mark invitation as accepted
  await adminSupabase
    .from("client_invitations")
    .update({ accepted_at: new Date().toISOString() })
    .eq("id", invitation.id);

  // Redirect to the client dashboard
  return NextResponse.redirect(`${origin}/dashboard/${invitation.client_id}`);
}
</file>

<file path="src/app/auth/signout/route.ts">
import { createClient } from "@/lib/supabase/server";
import { NextResponse } from "next/server";

export async function POST(request: Request) {
  const supabase = await createClient();

  await supabase.auth.signOut();

  const { origin } = new URL(request.url);
  return NextResponse.redirect(`${origin}/login`, {
    status: 302,
  });
}
</file>

<file path="src/app/dashboard/[clientId]/client-info-tooltip.tsx">
"use client";

import { useState } from "react";
import { Info, Target, Building2 } from "lucide-react";

interface ClientInfoTooltipProps {
  tam?: number | null;
  verticals?: string[] | null;
}

export function ClientInfoTooltip({ tam, verticals }: ClientInfoTooltipProps) {
  const [isVisible, setIsVisible] = useState(false);

  if (!tam && (!verticals || verticals.length === 0)) {
    return null;
  }

  return (
    <div className="relative inline-block">
      <button
        type="button"
        className="text-muted-foreground hover:text-foreground transition-colors p-1 rounded-full hover:bg-muted"
        onMouseEnter={() => setIsVisible(true)}
        onMouseLeave={() => setIsVisible(false)}
        onFocus={() => setIsVisible(true)}
        onBlur={() => setIsVisible(false)}
        aria-label="Campaign targeting information"
      >
        <Info className="h-4 w-4" />
      </button>
      {isVisible && (
        <div className="absolute left-0 top-full mt-2 z-50 min-w-[250px] max-w-[320px] p-4 bg-popover text-popover-foreground border border-border rounded-lg shadow-lg">
          <div className="absolute -top-2 left-3 w-3 h-3 bg-popover border-l border-t border-border rotate-45" />

          <p className="text-sm font-medium mb-3">Campaign Targeting</p>

          <div className="space-y-3">
            {tam && (
              <div className="flex items-start gap-2">
                <Target className="h-4 w-4 text-blue-500 mt-0.5 shrink-0" />
                <div>
                  <p className="text-xs text-muted-foreground">Total Addressable Market</p>
                  <p className="font-medium">{tam.toLocaleString()} leads</p>
                </div>
              </div>
            )}

            {verticals && verticals.length > 0 && (
              <div className="flex items-start gap-2">
                <Building2 className="h-4 w-4 text-emerald-500 mt-0.5 shrink-0" />
                <div>
                  <p className="text-xs text-muted-foreground">Target Industries</p>
                  <div className="flex flex-wrap gap-1 mt-1">
                    {verticals.map((vertical, index) => (
                      <span
                        key={index}
                        className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-muted text-foreground"
                      >
                        {vertical}
                      </span>
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/dashboard/[clientId]/client-leads-view.tsx">
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { LeadTable } from "@/components/leads/lead-table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { createClient } from "@/lib/supabase/client";
import type { Lead, LeadStatus, Campaign } from "@/types/database";

interface ClientLeadsViewProps {
  leads: (Lead & { campaigns: { client_id: string; name: string } })[];
  campaigns: Campaign[];
  clientId: string;
}

export function ClientLeadsView({
  leads: initialLeads,
  campaigns,
  clientId,
}: ClientLeadsViewProps) {
  const [selectedCampaign, setSelectedCampaign] = useState<string>("all");
  const [, startTransition] = useTransition();
  const router = useRouter();
  const supabase = createClient();

  const filteredLeads =
    selectedCampaign === "all"
      ? initialLeads
      : initialLeads.filter((lead) => lead.campaign_id === selectedCampaign);

  const handleStatusChange = async (leadId: string, status: LeadStatus) => {
    await supabase
      .from("leads")
      .update({ status, updated_at: new Date().toISOString() })
      .eq("id", leadId);

    startTransition(() => {
      router.refresh();
    });
  };

  const handleNotesChange = async (leadId: string, notes: string) => {
    await supabase
      .from("leads")
      .update({ notes, updated_at: new Date().toISOString() })
      .eq("id", leadId);

    startTransition(() => {
      router.refresh();
    });
  };

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle>Leads</CardTitle>
        <Select value={selectedCampaign} onValueChange={setSelectedCampaign}>
          <SelectTrigger className="w-[200px]">
            <SelectValue placeholder="Filter by campaign" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Campaigns</SelectItem>
            {campaigns.map((campaign) => (
              <SelectItem key={campaign.id} value={campaign.id}>
                {campaign.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </CardHeader>
      <CardContent>
        <LeadTable
          leads={filteredLeads}
          onStatusChange={handleStatusChange}
          onNotesChange={handleNotesChange}
        />
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/app/dashboard/layout.tsx">
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import { Sidebar } from "@/components/layout/sidebar";
import { Header } from "@/components/layout/header";
import { getClientsForUser } from "@/lib/queries/clients";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // Get user profile
  const { data: profile } = await supabase
    .from("profiles")
    .select("*")
    .eq("id", user.id)
    .single();

  const isAdmin = profile?.role === "admin";

  // Get clients for sidebar
  let clients: Array<{ id: string; name: string }> = [];

  if (isAdmin) {
    // Admins see all clients
    const { data } = await supabase.from("clients").select("id, name").order("name");
    clients = data || [];
  } else {
    // Regular users see only linked clients
    clients = await getClientsForUser(supabase, user.id);
  }

  return (
    <div className="flex min-h-screen">
      <Sidebar isAdmin={false} clients={clients} />
      <div className="flex-1 flex flex-col">
        <Header email={user.email} isAdmin={isAdmin} />
        <main className="flex-1 p-6 bg-gray-50">{children}</main>
      </div>
    </div>
  );
}
</file>

<file path="src/app/icon.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" fill="none">
  <rect width="32" height="32" rx="6" fill="#2563eb"/>
  <path d="M4 18c2-3 4-5 7-5s5 4 8 4 5-3 8-3" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
  <path d="M4 22c2-3 4-5 7-5s5 4 8 4 5-3 8-3" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none" opacity="0.6"/>
</svg>
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="src/components/admin/add-customer-dialog.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Check,
  Copy,
  ExternalLink,
  ChevronRight,
  ChevronLeft,
  Eye,
  EyeOff,
  AlertCircle,
  CheckCircle2,
  Loader2,
} from "lucide-react";

interface AddCustomerDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

type Step = "name" | "instantly" | "webhook" | "invite" | "complete";

export function AddCustomerDialog({ open, onOpenChange, onSuccess }: AddCustomerDialogProps) {
  const [step, setStep] = useState<Step>("name");
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [createdCustomerId, setCreatedCustomerId] = useState<string | null>(null);

  // Form state
  const [customerName, setCustomerName] = useState("");
  const [instantlyApiKey, setInstantlyApiKey] = useState("");
  const [showApiKey, setShowApiKey] = useState(false);
  const [apiKeyValid, setApiKeyValid] = useState<boolean | null>(null);
  const [validatingKey, setValidatingKey] = useState(false);
  const [webhookSecret, setWebhookSecret] = useState("");
  const [clientFirstName, setClientFirstName] = useState("");
  const [clientEmail, setClientEmail] = useState("");

  // Generated webhook URL
  const [webhookUrl, setWebhookUrl] = useState("");

  const resetForm = () => {
    setStep("name");
    setCustomerName("");
    setInstantlyApiKey("");
    setShowApiKey(false);
    setApiKeyValid(null);
    setWebhookSecret("");
    setClientFirstName("");
    setClientEmail("");
    setWebhookUrl("");
    setError(null);
    setCreatedCustomerId(null);
  };

  const handleClose = () => {
    resetForm();
    onOpenChange(false);
  };

  const validateApiKey = async () => {
    if (!instantlyApiKey.trim()) {
      setApiKeyValid(false);
      return;
    }

    setValidatingKey(true);
    try {
      const res = await fetch("/api/instantly/validate-key", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ apiKey: instantlyApiKey }),
      });

      const data = await res.json();
      setApiKeyValid(data.valid === true);
    } catch {
      setApiKeyValid(false);
    } finally {
      setValidatingKey(false);
    }
  };

  const generateWebhookSecret = () => {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let secret = "";
    for (let i = 0; i < 32; i++) {
      secret += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    setWebhookSecret(secret);
  };

  const handleCreateCustomer = async () => {
    if (!customerName.trim()) return;

    setIsCreating(true);
    setError(null);

    try {
      const res = await fetch("/api/admin/customers", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: customerName.trim(),
          instantly_api_key: instantlyApiKey.trim() || null,
          webhook_secret: webhookSecret.trim() || null,
        }),
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to create customer");
      }

      const data = await res.json();
      const customerId = data.client?.id || data.customer?.id || data.id;
      setCreatedCustomerId(customerId);

      // Generate webhook URL
      const baseUrl = window.location.origin;
      setWebhookUrl(`${baseUrl}/api/webhooks/instantly/${customerId}`);

      // Send invitation if email provided
      if (clientEmail.trim()) {
        try {
          await fetch("/api/admin/invitations", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              client_id: customerId,
              email: clientEmail.trim(),
              first_name: clientFirstName.trim() || null,
            }),
          });
        } catch (inviteErr) {
          console.error("Failed to send invitation:", inviteErr);
          // Don't fail the whole flow if invitation fails
        }
      }

      setStep("complete");
      onSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create customer");
    } finally {
      setIsCreating(false);
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  const renderStep = () => {
    switch (step) {
      case "name":
        return (
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="customerName">Customer Name *</Label>
              <Input
                id="customerName"
                placeholder="e.g., Acme Corporation"
                value={customerName}
                onChange={(e) => setCustomerName(e.target.value)}
                autoFocus
              />
              <p className="text-xs text-muted-foreground">
                The company or brand name for this customer.
              </p>
            </div>

            <div className="flex justify-end gap-2 pt-4">
              <Button variant="outline" onClick={handleClose}>
                Cancel
              </Button>
              <Button
                onClick={() => setStep("instantly")}
                disabled={!customerName.trim()}
              >
                Next
                <ChevronRight className="ml-2 h-4 w-4" />
              </Button>
            </div>
          </div>
        );

      case "instantly":
        return (
          <div className="space-y-4">
            <div className="bg-blue-50 dark:bg-blue-950 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
              <h4 className="font-medium text-blue-900 dark:text-blue-100 mb-2">
                How to get an Instantly API Key
              </h4>
              <ol className="text-sm text-blue-800 dark:text-blue-200 space-y-2 list-decimal list-inside">
                <li>
                  Log in to{" "}
                  <a
                    href="https://app.instantly.ai/app/settings/integrations"
                    target="_blank"
                    rel="noopener noreferrer"
                    className="underline inline-flex items-center gap-1"
                  >
                    Instantly Settings <ExternalLink className="h-3 w-3" />
                  </a>
                </li>
                <li>Go to <strong>Settings  Integrations  API</strong></li>
                <li>Click <strong>Create New API Key</strong></li>
                <li>Give it a name (e.g., &quot;{customerName} Portal&quot;)</li>
                <li>Select these permissions:
                  <ul className="ml-4 mt-1 space-y-1">
                    <li> <code className="bg-blue-100 dark:bg-blue-900 px-1 rounded">campaigns:read</code> - View campaigns</li>
                    <li> <code className="bg-blue-100 dark:bg-blue-900 px-1 rounded">leads:read</code> - View leads</li>
                    <li> <code className="bg-blue-100 dark:bg-blue-900 px-1 rounded">leads:write</code> - Update lead status</li>
                    <li> <code className="bg-blue-100 dark:bg-blue-900 px-1 rounded">analytics:read</code> - View analytics</li>
                  </ul>
                </li>
                <li>Copy the API key and paste it below</li>
              </ol>
            </div>

            <div className="space-y-2">
              <Label htmlFor="apiKey">Instantly API Key</Label>
              <div className="flex gap-2">
                <div className="relative flex-1">
                  <Input
                    id="apiKey"
                    type={showApiKey ? "text" : "password"}
                    placeholder="Enter API key..."
                    value={instantlyApiKey}
                    onChange={(e) => {
                      setInstantlyApiKey(e.target.value);
                      setApiKeyValid(null);
                    }}
                    className="pr-10"
                  />
                  <button
                    type="button"
                    onClick={() => setShowApiKey(!showApiKey)}
                    className="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
                  >
                    {showApiKey ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                  </button>
                </div>
                <Button
                  variant="outline"
                  onClick={validateApiKey}
                  disabled={validatingKey || !instantlyApiKey.trim()}
                >
                  {validatingKey ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    "Validate"
                  )}
                </Button>
              </div>
              {apiKeyValid === true && (
                <p className="text-sm text-green-600 dark:text-green-400 flex items-center gap-1">
                  <CheckCircle2 className="h-4 w-4" /> API key is valid
                </p>
              )}
              {apiKeyValid === false && (
                <p className="text-sm text-red-600 dark:text-red-400 flex items-center gap-1">
                  <AlertCircle className="h-4 w-4" /> Invalid API key
                </p>
              )}
              <p className="text-xs text-muted-foreground">
                Optional: Skip this step if you want to configure it later.
              </p>
            </div>

            <div className="flex justify-between gap-2 pt-4">
              <Button variant="outline" onClick={() => setStep("name")}>
                <ChevronLeft className="mr-2 h-4 w-4" />
                Back
              </Button>
              <div className="flex gap-2">
                <Button variant="ghost" onClick={() => setStep("webhook")}>
                  Skip
                </Button>
                <Button onClick={() => setStep("webhook")}>
                  Next
                  <ChevronRight className="ml-2 h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>
        );

      case "webhook":
        return (
          <div className="space-y-4">
            <div className="bg-amber-50 dark:bg-amber-950 border border-amber-200 dark:border-amber-800 rounded-lg p-4">
              <h4 className="font-medium text-amber-900 dark:text-amber-100 mb-2">
                Webhook Configuration (Optional)
              </h4>
              <p className="text-sm text-amber-800 dark:text-amber-200 mb-3">
                Webhooks allow Instantly to send real-time updates when leads reply,
                open emails, or change status. This keeps your portal data in sync.
              </p>
              <p className="text-sm text-amber-800 dark:text-amber-200">
                <strong>Note:</strong> You can configure webhooks after creating the customer.
                The webhook URL will be generated automatically.
              </p>
            </div>

            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="webhookSecret">Webhook Secret</Label>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={generateWebhookSecret}
                >
                  Generate
                </Button>
              </div>
              <div className="flex gap-2">
                <Input
                  id="webhookSecret"
                  placeholder="Optional webhook secret for signature verification"
                  value={webhookSecret}
                  onChange={(e) => setWebhookSecret(e.target.value)}
                />
                {webhookSecret && (
                  <Button
                    variant="outline"
                    size="icon"
                    onClick={() => copyToClipboard(webhookSecret)}
                  >
                    <Copy className="h-4 w-4" />
                  </Button>
                )}
              </div>
              <p className="text-xs text-muted-foreground">
                Used to verify webhook requests from Instantly.
              </p>
            </div>

            <div className="flex justify-between gap-2 pt-4">
              <Button variant="outline" onClick={() => setStep("instantly")}>
                <ChevronLeft className="mr-2 h-4 w-4" />
                Back
              </Button>
              <div className="flex gap-2">
                <Button variant="ghost" onClick={() => setStep("invite")}>
                  Skip
                </Button>
                <Button onClick={() => setStep("invite")}>
                  Next
                  <ChevronRight className="ml-2 h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>
        );

      case "invite":
        return (
          <div className="space-y-4">
            <div className="bg-blue-50 dark:bg-blue-950 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
              <h4 className="font-medium text-blue-900 dark:text-blue-100 mb-2">
                Invite Client to Dashboard
              </h4>
              <p className="text-sm text-blue-800 dark:text-blue-200">
                Send an email invitation to give your client access to their dashboard.
                They will sign in using Google authentication.
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="clientFirstName">Client First Name</Label>
              <Input
                id="clientFirstName"
                placeholder="e.g., John"
                value={clientFirstName}
                onChange={(e) => setClientFirstName(e.target.value)}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="clientEmail">Client Email Address</Label>
              <Input
                id="clientEmail"
                type="email"
                placeholder="e.g., john@acme.com"
                value={clientEmail}
                onChange={(e) => setClientEmail(e.target.value)}
              />
              <p className="text-xs text-muted-foreground">
                An invitation will be sent to this email with a link to access the dashboard.
              </p>
            </div>

            {error && (
              <div className="bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-300 px-4 py-3 rounded-lg">
                {error}
              </div>
            )}

            <div className="flex justify-between gap-2 pt-4">
              <Button variant="outline" onClick={() => setStep("webhook")}>
                <ChevronLeft className="mr-2 h-4 w-4" />
                Back
              </Button>
              <div className="flex gap-2">
                <Button variant="ghost" onClick={handleCreateCustomer} disabled={isCreating}>
                  Skip & Create
                </Button>
                <Button onClick={handleCreateCustomer} disabled={isCreating}>
                  {isCreating ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      Creating...
                    </>
                  ) : (
                    <>
                      Create & Send Invite
                      <Check className="ml-2 h-4 w-4" />
                    </>
                  )}
                </Button>
              </div>
            </div>
          </div>
        );

      case "complete":
        return (
          <div className="space-y-4">
            <div className="text-center py-4">
              <div className="w-12 h-12 bg-green-100 dark:bg-green-900 rounded-full flex items-center justify-center mx-auto mb-4">
                <CheckCircle2 className="h-6 w-6 text-green-600 dark:text-green-400" />
              </div>
              <h3 className="text-lg font-semibold">Customer Created!</h3>
              <p className="text-muted-foreground">
                {customerName} has been set up successfully.
              </p>
              {clientEmail && (
                <p className="text-sm text-green-600 dark:text-green-400 mt-2">
                  Invitation sent to {clientEmail}
                </p>
              )}
            </div>

            {webhookUrl && (
              <div className="bg-muted rounded-lg p-4 space-y-3">
                <div>
                  <Label className="text-xs text-muted-foreground">Webhook URL</Label>
                  <div className="flex gap-2 mt-1">
                    <code className="flex-1 text-xs bg-background p-2 rounded border break-all">
                      {webhookUrl}
                    </code>
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={() => copyToClipboard(webhookUrl)}
                    >
                      <Copy className="h-4 w-4" />
                    </Button>
                  </div>
                </div>
              </div>
            )}

            <div className="bg-blue-50 dark:bg-blue-950 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
              <h4 className="font-medium text-blue-900 dark:text-blue-100 mb-2">
                Next Steps
              </h4>
              <ol className="text-sm text-blue-800 dark:text-blue-200 space-y-1 list-decimal list-inside">
                <li>Go to Instantly  Settings  Webhooks</li>
                <li>Add a new webhook with the URL above</li>
                <li>Select events: reply_received, lead_interested, email_sent</li>
                <li>Link campaigns to this customer from their dashboard</li>
              </ol>
            </div>

            <div className="flex justify-end gap-2 pt-4">
              <Button variant="outline" onClick={handleClose}>
                Close
              </Button>
              <Button
                onClick={() => {
                  handleClose();
                  window.location.href = `/admin/clients/${createdCustomerId}`;
                }}
              >
                Go to Customer
                <ChevronRight className="ml-2 h-4 w-4" />
              </Button>
            </div>
          </div>
        );
    }
  };

  const stepTitles: Record<Step, string> = {
    name: "Customer Details",
    instantly: "Instantly API Setup",
    webhook: "Webhook Configuration",
    invite: "Client Access",
    complete: "Setup Complete",
  };

  return (
    <Dialog open={open} onOpenChange={(o) => !o && handleClose()}>
      <DialogContent className="max-w-lg">
        <DialogHeader>
          <DialogTitle>{stepTitles[step]}</DialogTitle>
          {step !== "complete" && (
            <div className="flex items-center gap-2 pt-2">
              {(["name", "instantly", "webhook", "invite"] as Step[]).map((s, i) => (
                <div
                  key={s}
                  className={`h-1 flex-1 rounded-full ${
                    (["name", "instantly", "webhook", "invite"] as Step[]).indexOf(step) >= i
                      ? "bg-primary"
                      : "bg-muted"
                  }`}
                />
              ))}
            </div>
          )}
        </DialogHeader>
        <div className="pt-4">{renderStep()}</div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/layout/sidebar.tsx">
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import { LayoutDashboard, Users, MessageSquare, Settings, Zap } from "lucide-react";

interface SidebarProps {
  isAdmin?: boolean;
  clients?: Array<{ id: string; name: string }>;
}

export function Sidebar({ isAdmin = false, clients = [] }: SidebarProps) {
  const pathname = usePathname();

  return (
    <aside className="w-64 min-h-screen bg-slate-900 text-white flex flex-col">
      {/* Logo */}
      <div className="p-6 border-b border-slate-800">
        <div className="flex items-center gap-3">
          <div className="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center">
            <Zap className="h-5 w-5 text-white" />
          </div>
          <div>
            <h1 className="text-lg font-bold text-white">BlueReach Agency</h1>
          </div>
        </div>
      </div>

      {/* Navigation */}
      <nav className="flex-1 p-4 space-y-1">
        {isAdmin ? (
          <>
            <NavLink
              href="/admin"
              active={pathname === "/admin"}
              icon={<LayoutDashboard className="h-4 w-4" />}
            >
              Command Center
            </NavLink>
            <NavLink
              href="/admin/clients"
              active={pathname.startsWith("/admin/clients")}
              icon={<Users className="h-4 w-4" />}
            >
              Customers
            </NavLink>
            <NavLink
              href="/admin/leads"
              active={pathname === "/admin/leads"}
              icon={<MessageSquare className="h-4 w-4" />}
            >
              All Leads
            </NavLink>

            <div className="pt-6">
              <p className="text-slate-500 text-xs uppercase tracking-wider mb-2 px-3">
                Integrations
              </p>
              <NavLink
                href="/admin/instantly"
                active={pathname.startsWith("/admin/instantly")}
                icon={<Zap className="h-4 w-4" />}
              >
                Instantly
              </NavLink>
            </div>
          </>
        ) : (
          <>
            <NavLink
              href="/dashboard"
              active={pathname === "/dashboard"}
              icon={<LayoutDashboard className="h-4 w-4" />}
            >
              Overview
            </NavLink>
            {clients.length > 0 && (
              <div className="pt-4">
                <p className="text-slate-500 text-xs uppercase tracking-wider mb-2 px-3">
                  Your Clients
                </p>
                {clients.map((client) => (
                  <NavLink
                    key={client.id}
                    href={`/dashboard/${client.id}`}
                    active={pathname === `/dashboard/${client.id}`}
                  >
                    {client.name}
                  </NavLink>
                ))}
              </div>
            )}
          </>
        )}
      </nav>

      {/* Footer */}
      <div className="p-4 border-t border-slate-800">
        <NavLink
          href={isAdmin ? "/admin/settings" : "/dashboard/settings"}
          active={pathname.includes("/settings")}
          icon={<Settings className="h-4 w-4" />}
        >
          Settings
        </NavLink>
      </div>
    </aside>
  );
}

function NavLink({
  href,
  active,
  icon,
  children,
}: {
  href: string;
  active: boolean;
  icon?: React.ReactNode;
  children: React.ReactNode;
}) {
  return (
    <Link
      href={href}
      className={cn(
        "flex items-center gap-3 px-3 py-2 rounded-lg transition-colors text-sm",
        active
          ? "bg-blue-600 text-white"
          : "text-slate-400 hover:bg-slate-800 hover:text-white"
      )}
    >
      {icon}
      {children}
    </Link>
  );
}
</file>

<file path="src/components/layout/stats-cards.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import type { LeadStats } from "@/lib/queries/stats";

interface StatsCardsProps {
  stats: LeadStats;
}

export function StatsCards({ stats }: StatsCardsProps) {
  const cards = [
    {
      title: "Total Contacted",
      value: stats.total_contacted,
      color: "text-gray-600",
      bgColor: "bg-gray-50",
    },
    {
      title: "Replied",
      value: stats.total_replied,
      color: "text-blue-600",
      bgColor: "bg-blue-50",
    },
    {
      title: "Meetings Booked",
      value: stats.total_booked,
      color: "text-green-600",
      bgColor: "bg-green-50",
    },
    {
      title: "Closed Won",
      value: stats.total_won,
      color: "text-purple-600",
      bgColor: "bg-purple-50",
    },
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      {cards.map((card) => (
        <Card key={card.title} className={card.bgColor}>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-gray-500">
              {card.title}
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className={`text-3xl font-bold ${card.color}`}>{card.value}</p>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}
</file>

<file path="src/components/marketing/footer.tsx">
import Link from "next/link";

export function MarketingFooter() {
  return (
    <footer className="bg-[#050508] border-t border-white/5">
      <div className="max-w-7xl mx-auto px-6 lg:px-8 py-12 lg:py-16">
        <div className="grid grid-cols-2 md:grid-cols-4 gap-8 lg:gap-12">
          {/* Brand */}
          <div className="col-span-2 md:col-span-1">
            <Link href="/" className="flex items-center gap-3 mb-4">
              <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-cyan-400 rounded-xl flex items-center justify-center">
                <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
              </div>
              <span className="text-lg font-bold text-white">Blue Reach</span>
            </Link>
            <p className="text-sm text-zinc-500 leading-relaxed">
              The command center for email outbound agencies. Manage campaigns, track leads, delight clients.
            </p>
          </div>

          {/* Product */}
          <div>
            <h4 className="text-sm font-semibold text-white mb-4">Product</h4>
            <ul className="space-y-3">
              <li>
                <Link href="/features" className="text-sm text-zinc-500 hover:text-white transition-colors">
                  Features
                </Link>
              </li>
              <li>
                <Link href="/pricing" className="text-sm text-zinc-500 hover:text-white transition-colors">
                  Pricing
                </Link>
              </li>
              <li>
                <Link href="/login" className="text-sm text-zinc-500 hover:text-white transition-colors">
                  Sign In
                </Link>
              </li>
            </ul>
          </div>

          {/* Company */}
          <div>
            <h4 className="text-sm font-semibold text-white mb-4">Company</h4>
            <ul className="space-y-3">
              <li>
                <Link href="#" className="text-sm text-zinc-500 hover:text-white transition-colors">
                  About
                </Link>
              </li>
              <li>
                <Link href="#" className="text-sm text-zinc-500 hover:text-white transition-colors">
                  Blog
                </Link>
              </li>
              <li>
                <a href="mailto:hello@blue-reach.com" className="text-sm text-zinc-500 hover:text-white transition-colors">
                  Contact
                </a>
              </li>
            </ul>
          </div>

          {/* Legal */}
          <div>
            <h4 className="text-sm font-semibold text-white mb-4">Legal</h4>
            <ul className="space-y-3">
              <li>
                <Link href="#" className="text-sm text-zinc-500 hover:text-white transition-colors">
                  Privacy Policy
                </Link>
              </li>
              <li>
                <Link href="#" className="text-sm text-zinc-500 hover:text-white transition-colors">
                  Terms of Service
                </Link>
              </li>
            </ul>
          </div>
        </div>

        {/* Bottom */}
        <div className="mt-12 pt-8 border-t border-white/5 flex flex-col md:flex-row items-center justify-between gap-4">
          <p className="text-sm text-zinc-600">
            &copy; {new Date().getFullYear()} Blue Reach. All rights reserved.
          </p>
          <div className="flex items-center gap-6">
            <a href="#" className="text-zinc-500 hover:text-white transition-colors">
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84" />
              </svg>
            </a>
            <a href="#" className="text-zinc-500 hover:text-white transition-colors">
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path fillRule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clipRule="evenodd" />
              </svg>
            </a>
            <a href="#" className="text-zinc-500 hover:text-white transition-colors">
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path fillRule="evenodd" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z" clipRule="evenodd" />
              </svg>
            </a>
          </div>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="src/components/marketing/header.tsx">
"use client";

import Link from "next/link";
import { useState } from "react";

export function MarketingHeader() {
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  const navigation = [
    { name: "Features", href: "/features" },
    { name: "Pricing", href: "/pricing" },
  ];

  return (
    <header className="fixed top-0 left-0 right-0 z-50 bg-[#050508]/80 backdrop-blur-xl border-b border-white/5">
      <nav className="max-w-7xl mx-auto px-6 lg:px-8">
        <div className="flex items-center justify-between h-16 lg:h-20">
          {/* Logo */}
          <Link href="/" className="flex items-center gap-3 group">
            <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-cyan-400 rounded-xl flex items-center justify-center shadow-lg shadow-blue-500/20 group-hover:shadow-blue-500/40 transition-all">
              <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M13 10V3L4 14h7v7l9-11h-7z" />
              </svg>
            </div>
            <span className="text-xl font-bold text-white">Blue Reach</span>
          </Link>

          {/* Desktop Navigation */}
          <div className="hidden md:flex items-center gap-8">
            {navigation.map((item) => (
              <Link
                key={item.name}
                href={item.href}
                className="text-sm font-medium text-zinc-400 hover:text-white transition-colors"
              >
                {item.name}
              </Link>
            ))}
          </div>

          {/* CTA Buttons */}
          <div className="hidden md:flex items-center gap-4">
            <Link
              href="/login"
              className="text-sm font-medium text-zinc-400 hover:text-white transition-colors"
            >
              Sign in
            </Link>
            <Link
              href="/login"
              className="px-5 py-2.5 bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white text-sm font-semibold rounded-xl transition-all shadow-lg shadow-blue-500/25 hover:shadow-blue-500/40 hover:-translate-y-0.5"
            >
              Get Started
            </Link>
          </div>

          {/* Mobile Menu Button */}
          <button
            onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
            className="md:hidden p-2 text-zinc-400 hover:text-white"
          >
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              {mobileMenuOpen ? (
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              ) : (
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
              )}
            </svg>
          </button>
        </div>

        {/* Mobile Menu */}
        {mobileMenuOpen && (
          <div className="md:hidden py-4 border-t border-white/5">
            <div className="flex flex-col gap-4">
              {navigation.map((item) => (
                <Link
                  key={item.name}
                  href={item.href}
                  className="text-base font-medium text-zinc-400 hover:text-white transition-colors"
                  onClick={() => setMobileMenuOpen(false)}
                >
                  {item.name}
                </Link>
              ))}
              <div className="flex flex-col gap-3 pt-4 border-t border-white/5">
                <Link
                  href="/login"
                  className="text-base font-medium text-zinc-400 hover:text-white transition-colors"
                >
                  Sign in
                </Link>
                <Link
                  href="/login"
                  className="w-full py-3 bg-gradient-to-r from-blue-500 to-cyan-500 text-white text-center font-semibold rounded-xl"
                >
                  Get Started
                </Link>
              </div>
            </div>
          </div>
        )}
      </nav>
    </header>
  );
}
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-gray-900 text-white [a&]:hover:bg-gray-800",
        secondary:
          "border-transparent bg-gray-100 text-gray-700 [a&]:hover:bg-gray-200",
        destructive:
          "border-transparent bg-red-500 text-white [a&]:hover:bg-red-600 focus-visible:ring-red-500/20 dark:focus-visible:ring-red-500/40",
        outline:
          "text-gray-700 border-gray-300 [a&]:hover:bg-gray-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all cursor-pointer disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-gray-900 text-white hover:bg-gray-800",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="src/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ComponentRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-gray-300 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-gray-900 data-[state=checked]:border-gray-900 data-[state=checked]:text-white",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-3 w-3" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return (
    <DialogPrimitive.Trigger
      data-slot="dialog-trigger"
      className={className}
      {...props}
    />
  )
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 outline-none sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="src/components/ui/info-tooltip.tsx">
"use client";

import { useState } from "react";
import { Info } from "lucide-react";

interface InfoTooltipProps {
  children: React.ReactNode;
}

export function InfoTooltip({ children }: InfoTooltipProps) {
  const [isVisible, setIsVisible] = useState(false);

  return (
    <div className="relative inline-block">
      <button
        type="button"
        className="text-muted-foreground hover:text-foreground transition-colors p-1 rounded-full hover:bg-muted"
        onMouseEnter={() => setIsVisible(true)}
        onMouseLeave={() => setIsVisible(false)}
        onFocus={() => setIsVisible(true)}
        onBlur={() => setIsVisible(false)}
        aria-label="More information"
      >
        <Info className="h-4 w-4" />
      </button>
      {isVisible && (
        <div className="absolute left-0 top-full mt-2 z-50 min-w-[280px] max-w-[350px] p-4 bg-popover text-popover-foreground border border-border rounded-lg shadow-lg">
          <div className="absolute -top-2 left-3 w-3 h-3 bg-popover border-l border-t border-border rotate-45" />
          {children}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "item-aligned",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span
        data-slot="select-item-indicator"
        className="absolute right-2 flex size-3.5 items-center justify-center"
      >
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="src/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="src/components/ui/table.tsx">
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="src/components/theme-toggle.tsx">
"use client";

import { useEffect, useState } from "react";
import { Moon, Sun } from "lucide-react";
import { Button } from "@/components/ui/button";

export function ThemeToggle() {
  const [isDark, setIsDark] = useState(false);
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
    // Check for saved preference or system preference
    const savedTheme = localStorage.getItem("theme");
    const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;

    if (savedTheme === "dark" || (!savedTheme && prefersDark)) {
      setIsDark(true);
      document.documentElement.classList.add("dark");
    }
  }, []);

  const toggleTheme = () => {
    const newIsDark = !isDark;
    setIsDark(newIsDark);

    if (newIsDark) {
      document.documentElement.classList.add("dark");
      localStorage.setItem("theme", "dark");
    } else {
      document.documentElement.classList.remove("dark");
      localStorage.setItem("theme", "light");
    }
  };

  // Prevent hydration mismatch
  if (!mounted) {
    return (
      <Button variant="ghost" size="sm" className="w-9 h-9 p-0">
        <span className="sr-only">Toggle theme</span>
      </Button>
    );
  }

  return (
    <Button
      variant="ghost"
      size="sm"
      onClick={toggleTheme}
      className="w-9 h-9 p-0"
    >
      {isDark ? (
        <Sun className="h-4 w-4" />
      ) : (
        <Moon className="h-4 w-4" />
      )}
      <span className="sr-only">Toggle theme</span>
    </Button>
  );
}
</file>

<file path="src/lib/dns/checker.ts">
// DNS Health Checker
// Uses DNS over HTTPS (DoH) for server-side DNS lookups

export interface SPFResult {
  found: boolean;
  valid: boolean;
  record: string | null;
  issues: string[];
}

export interface DKIMResult {
  found: boolean;
  valid: boolean;
  selector: string | null;
  record: string | null;
  issues: string[];
}

export interface DMARCResult {
  found: boolean;
  valid: boolean;
  record: string | null;
  policy: "none" | "quarantine" | "reject" | null;
  issues: string[];
}

export interface DomainHealthResult {
  domain: string;
  spf: SPFResult;
  dkim: DKIMResult;
  dmarc: DMARCResult;
  healthScore: number;
  checkedAt: string;
}

// DNS over HTTPS endpoint (using Google's public DoH)
const DOH_ENDPOINT = "https://dns.google/resolve";

interface DoHResponse {
  Status: number;
  Answer?: Array<{
    name: string;
    type: number;
    TTL: number;
    data: string;
  }>;
}

// Query DNS TXT records using DoH
async function queryTXT(domain: string): Promise<string[]> {
  try {
    const url = new URL(DOH_ENDPOINT);
    url.searchParams.set("name", domain);
    url.searchParams.set("type", "TXT");

    const response = await fetch(url.toString(), {
      headers: { Accept: "application/dns-json" },
    });

    if (!response.ok) {
      return [];
    }

    const data: DoHResponse = await response.json();

    if (data.Status !== 0 || !data.Answer) {
      return [];
    }

    // Extract TXT records, removing quotes
    return data.Answer.filter((a) => a.type === 16) // TXT = 16
      .map((a) => a.data.replace(/"/g, ""));
  } catch (error) {
    console.error(`DNS query failed for ${domain}:`, error);
    return [];
  }
}

// Check SPF record
export async function checkSPF(domain: string): Promise<SPFResult> {
  const result: SPFResult = {
    found: false,
    valid: false,
    record: null,
    issues: [],
  };

  try {
    const records = await queryTXT(domain);

    // Find SPF record (starts with v=spf1)
    const spfRecord = records.find((r) => r.toLowerCase().startsWith("v=spf1"));

    if (!spfRecord) {
      result.issues.push("No SPF record found");
      return result;
    }

    result.found = true;
    result.record = spfRecord;

    // Basic validation
    const issues: string[] = [];

    // Check for common issues
    if (spfRecord.includes("+all")) {
      issues.push("SPF uses +all which allows any server to send (insecure)");
    }

    if (!spfRecord.includes("~all") && !spfRecord.includes("-all") && !spfRecord.includes("?all")) {
      if (!spfRecord.includes("+all")) {
        issues.push("SPF record should end with ~all, -all, or ?all");
      }
    }

    // Check for too many DNS lookups (max 10)
    const lookupCount = (spfRecord.match(/include:|a:|mx:|ptr:|exists:/gi) || []).length;
    if (lookupCount > 10) {
      issues.push(`SPF has ${lookupCount} DNS lookups (max 10 allowed)`);
    }

    result.issues = issues;
    result.valid = issues.length === 0 || !issues.some((i) => i.includes("insecure"));
  } catch (error) {
    result.issues.push(`Error checking SPF: ${error}`);
  }

  return result;
}

// Common DKIM selectors to check
const DKIM_SELECTORS = [
  "google",
  "default",
  "selector1",
  "selector2",
  "k1",
  "k2",
  "s1",
  "s2",
  "dkim",
  "mail",
  "smtp",
  "email",
  "mxvault",
  "protonmail",
  "protonmail2",
  "protonmail3",
];

// Check DKIM record
export async function checkDKIM(
  domain: string,
  customSelectors?: string[]
): Promise<DKIMResult> {
  const result: DKIMResult = {
    found: false,
    valid: false,
    selector: null,
    record: null,
    issues: [],
  };

  try {
    const selectors = customSelectors || DKIM_SELECTORS;

    // Try each selector
    for (const selector of selectors) {
      const dkimDomain = `${selector}._domainkey.${domain}`;
      const records = await queryTXT(dkimDomain);

      // Find DKIM record (contains v=DKIM1 or k=rsa)
      const dkimRecord = records.find(
        (r) => r.toLowerCase().includes("v=dkim1") || r.toLowerCase().includes("k=rsa")
      );

      if (dkimRecord) {
        result.found = true;
        result.selector = selector;
        result.record = dkimRecord;

        // Basic validation
        const issues: string[] = [];

        if (!dkimRecord.toLowerCase().includes("p=")) {
          issues.push("DKIM record missing public key (p=)");
        }

        // Check if key is empty (revoked)
        if (dkimRecord.includes("p=;") || dkimRecord.includes("p= ")) {
          issues.push("DKIM key appears to be revoked (empty key)");
        }

        result.issues = issues;
        result.valid = issues.length === 0;
        break; // Found valid DKIM, stop searching
      }
    }

    if (!result.found) {
      result.issues.push("No DKIM record found (checked common selectors)");
    }
  } catch (error) {
    result.issues.push(`Error checking DKIM: ${error}`);
  }

  return result;
}

// Check DMARC record
export async function checkDMARC(domain: string): Promise<DMARCResult> {
  const result: DMARCResult = {
    found: false,
    valid: false,
    record: null,
    policy: null,
    issues: [],
  };

  try {
    const dmarcDomain = `_dmarc.${domain}`;
    const records = await queryTXT(dmarcDomain);

    // Find DMARC record (starts with v=DMARC1)
    const dmarcRecord = records.find((r) => r.toLowerCase().startsWith("v=dmarc1"));

    if (!dmarcRecord) {
      result.issues.push("No DMARC record found");
      return result;
    }

    result.found = true;
    result.record = dmarcRecord;

    // Extract policy
    const policyMatch = dmarcRecord.match(/p=(none|quarantine|reject)/i);
    if (policyMatch) {
      result.policy = policyMatch[1].toLowerCase() as "none" | "quarantine" | "reject";
    }

    // Validation
    const issues: string[] = [];

    if (!result.policy) {
      issues.push("DMARC record missing policy (p=)");
    } else if (result.policy === "none") {
      issues.push("DMARC policy is 'none' (monitoring only, not enforcing)");
    }

    // Check for rua (aggregate reports)
    if (!dmarcRecord.includes("rua=")) {
      issues.push("DMARC record missing aggregate report address (rua=)");
    }

    result.issues = issues;
    result.valid =
      result.policy !== null &&
      !issues.some((i) => i.includes("missing policy"));
  } catch (error) {
    result.issues.push(`Error checking DMARC: ${error}`);
  }

  return result;
}

// Calculate health score based on DNS authentication
export function calculateHealthScore(
  spf: SPFResult,
  dkim: DKIMResult,
  dmarc: DMARCResult
): number {
  let score = 0;

  // SPF: up to 30 points
  if (spf.found) {
    score += 15;
    if (spf.valid) {
      score += 15;
    }
  }

  // DKIM: up to 35 points
  if (dkim.found) {
    score += 17;
    if (dkim.valid) {
      score += 18;
    }
  }

  // DMARC: up to 35 points
  if (dmarc.found) {
    score += 10;
    if (dmarc.valid) {
      score += 10;
    }
    // Bonus for strict policy
    if (dmarc.policy === "reject") {
      score += 15;
    } else if (dmarc.policy === "quarantine") {
      score += 10;
    } else if (dmarc.policy === "none") {
      score += 5;
    }
  }

  return Math.min(100, score);
}

// Check all DNS records for a domain
export async function checkDomainHealth(domain: string): Promise<DomainHealthResult> {
  // Run all checks in parallel
  const [spf, dkim, dmarc] = await Promise.all([
    checkSPF(domain),
    checkDKIM(domain),
    checkDMARC(domain),
  ]);

  const healthScore = calculateHealthScore(spf, dkim, dmarc);

  return {
    domain,
    spf,
    dkim,
    dmarc,
    healthScore,
    checkedAt: new Date().toISOString(),
  };
}

// Check multiple domains
export async function checkDomainsHealth(domains: string[]): Promise<DomainHealthResult[]> {
  // Process in batches to avoid rate limiting
  const batchSize = 3;
  const results: DomainHealthResult[] = [];

  for (let i = 0; i < domains.length; i += batchSize) {
    const batch = domains.slice(i, i + batchSize);
    const batchResults = await Promise.all(batch.map((domain) => checkDomainHealth(domain)));
    results.push(...batchResults);

    // Small delay between batches
    if (i + batchSize < domains.length) {
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }

  return results;
}
</file>

<file path="src/lib/dns/index.ts">
// DNS Health Checker Library

export {
  checkSPF,
  checkDKIM,
  checkDMARC,
  checkDomainHealth,
  checkDomainsHealth,
  calculateHealthScore,
} from "./checker";

export type {
  SPFResult,
  DKIMResult,
  DMARCResult,
  DomainHealthResult,
} from "./checker";
</file>

<file path="src/lib/email/index.ts">
export { sendInvitationEmail, getBrandingSettings } from "./send";
</file>

<file path="src/lib/email/send.ts">
import { Resend } from "resend";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

interface BrandingSettings {
  agencyName: string;
  agencyLogoUrl: string | null;
  primaryColor: string;
  senderName: string;
  senderEmail: string;
}

async function getBrandingSettings(): Promise<BrandingSettings> {
  const supabase = getSupabase();

  const { data: settings } = await supabase
    .from("settings")
    .select("key, value")
    .in("key", [
      "agency_name",
      "agency_logo_url",
      "agency_primary_color",
      "agency_sender_name",
      "agency_sender_email",
    ]);

  const settingsMap = new Map(settings?.map((s) => [s.key, s.value]) || []);

  return {
    agencyName: settingsMap.get("agency_name") || "BlueReach",
    agencyLogoUrl: settingsMap.get("agency_logo_url") || null,
    primaryColor: settingsMap.get("agency_primary_color") || "#2563eb",
    senderName: settingsMap.get("agency_sender_name") || "BlueReach Team",
    senderEmail: settingsMap.get("agency_sender_email") || "noreply@bluereach.com",
  };
}

async function getResendClient(): Promise<Resend | null> {
  const supabase = getSupabase();

  const { data: setting } = await supabase
    .from("settings")
    .select("value")
    .eq("key", "resend_api_key")
    .single();

  if (!setting?.value) {
    console.log("[Email] Resend API key not configured");
    return null;
  }

  return new Resend(setting.value);
}

interface SendInvitationEmailParams {
  to: string;
  inviteeName: string;
  clientName: string;
  loginUrl: string;
}

export async function sendInvitationEmail(
  params: SendInvitationEmailParams
): Promise<{ success: boolean; error?: string }> {
  const resend = await getResendClient();

  if (!resend) {
    return { success: false, error: "Email service not configured" };
  }

  const branding = await getBrandingSettings();

  const emailHtml = generateInvitationEmailHtml({
    ...params,
    branding,
  });

  try {
    const { error } = await resend.emails.send({
      from: `${branding.senderName} <${branding.senderEmail}>`,
      to: params.to,
      subject: `You've been invited to ${params.clientName} Dashboard`,
      html: emailHtml,
    });

    if (error) {
      console.error("[Email] Failed to send:", error);
      return { success: false, error: error.message };
    }

    return { success: true };
  } catch (err) {
    console.error("[Email] Error sending invitation:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "Failed to send email",
    };
  }
}

interface GenerateEmailHtmlParams extends SendInvitationEmailParams {
  branding: BrandingSettings;
}

function generateInvitationEmailHtml(params: GenerateEmailHtmlParams): string {
  const { inviteeName, clientName, loginUrl, branding } = params;
  const firstName = inviteeName.split(" ")[0] || "there";

  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>You're Invited</title>
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f4f4f5;">
  <table role="presentation" style="width: 100%; border-collapse: collapse;">
    <tr>
      <td align="center" style="padding: 40px 20px;">
        <table role="presentation" style="width: 100%; max-width: 600px; border-collapse: collapse;">
          <!-- Header -->
          <tr>
            <td align="center" style="padding-bottom: 30px;">
              ${branding.agencyLogoUrl
                ? `<img src="${branding.agencyLogoUrl}" alt="${branding.agencyName}" style="height: 50px; max-width: 200px;">`
                : `<h1 style="margin: 0; color: ${branding.primaryColor}; font-size: 28px; font-weight: 700;">${branding.agencyName}</h1>`
              }
            </td>
          </tr>

          <!-- Main Content -->
          <tr>
            <td style="background-color: #ffffff; border-radius: 12px; padding: 40px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);">
              <h2 style="margin: 0 0 20px 0; color: #18181b; font-size: 24px; font-weight: 600;">
                Hi ${firstName}!
              </h2>

              <p style="margin: 0 0 20px 0; color: #52525b; font-size: 16px; line-height: 1.6;">
                You've been invited to access the <strong style="color: #18181b;">${clientName}</strong> dashboard. This is where you can track your campaign performance and see real-time analytics.
              </p>

              <p style="margin: 0 0 30px 0; color: #52525b; font-size: 16px; line-height: 1.6;">
                Click the button below to create your account and get started:
              </p>

              <!-- CTA Button -->
              <table role="presentation" style="width: 100%; border-collapse: collapse;">
                <tr>
                  <td align="center">
                    <a href="${loginUrl}" style="display: inline-block; padding: 16px 32px; background-color: ${branding.primaryColor}; color: #ffffff; text-decoration: none; font-size: 16px; font-weight: 600; border-radius: 8px;">
                      Access Your Dashboard
                    </a>
                  </td>
                </tr>
              </table>

              <p style="margin: 30px 0 0 0; color: #a1a1aa; font-size: 14px; line-height: 1.6;">
                Or copy and paste this link into your browser:
              </p>
              <p style="margin: 10px 0 0 0; color: ${branding.primaryColor}; font-size: 14px; word-break: break-all;">
                ${loginUrl}
              </p>

              <hr style="margin: 30px 0; border: none; border-top: 1px solid #e4e4e7;">

              <p style="margin: 0; color: #a1a1aa; font-size: 14px;">
                This invitation will expire in 7 days. If you didn't expect this invitation, you can safely ignore this email.
              </p>
            </td>
          </tr>

          <!-- Footer -->
          <tr>
            <td align="center" style="padding: 30px 20px;">
              <p style="margin: 0; color: #a1a1aa; font-size: 14px;">
                Sent by ${branding.agencyName}
              </p>
              <p style="margin: 10px 0 0 0; color: #d4d4d8; font-size: 12px;">
                Powered by BlueReach Agency Management
              </p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>
`;
}

export { getBrandingSettings };
</file>

<file path="src/lib/instantly/accounts.ts">
// Instantly Accounts API Functions

import { getInstantlyClient } from "./client";
import type {
  InstantlyAccount,
  InstantlyAccountWarmupAnalytics,
  InstantlyAccountDailyAnalytics,
} from "./types";

interface AccountsListResponse {
  items: InstantlyAccount[];
}

interface WarmupAnalyticsResponse {
  data: InstantlyAccountWarmupAnalytics[];
}

interface DailyAnalyticsResponse {
  data: InstantlyAccountDailyAnalytics[];
}

export async function fetchInstantlyAccounts(params?: {
  limit?: number;
  skip?: number;
  status?: string;
}): Promise<InstantlyAccount[]> {
  const client = getInstantlyClient();
  const response = await client.get<AccountsListResponse>("/accounts", {
    limit: params?.limit || 100,
    skip: params?.skip || 0,
    status: params?.status,
  });
  return response.items || [];
}

export async function fetchAllInstantlyAccounts(): Promise<InstantlyAccount[]> {
  const allAccounts: InstantlyAccount[] = [];
  let skip = 0;
  const limit = 100;

  while (true) {
    const accounts = await fetchInstantlyAccounts({ limit, skip });
    allAccounts.push(...accounts);

    if (accounts.length < limit) {
      break;
    }
    skip += limit;
  }

  return allAccounts;
}

export async function fetchInstantlyAccount(email: string): Promise<InstantlyAccount> {
  const client = getInstantlyClient();
  return client.get<InstantlyAccount>(`/accounts/${encodeURIComponent(email)}`);
}

export async function enableWarmup(emails: string[]): Promise<{ success: boolean }> {
  const client = getInstantlyClient();
  return client.post<{ success: boolean }>("/accounts/warmup/enable", { emails });
}

export async function disableWarmup(emails: string[]): Promise<{ success: boolean }> {
  const client = getInstantlyClient();
  return client.post<{ success: boolean }>("/accounts/warmup/disable", { emails });
}

export async function getWarmupAnalytics(emails?: string[]): Promise<InstantlyAccountWarmupAnalytics[]> {
  const client = getInstantlyClient();
  const response = await client.post<WarmupAnalyticsResponse>("/accounts/warmup-analytics", {
    emails: emails || [],
  });
  return response.data || [];
}

export async function getAccountDailyAnalytics(params?: {
  email?: string;
  start_date?: string;
  end_date?: string;
}): Promise<InstantlyAccountDailyAnalytics[]> {
  const client = getInstantlyClient();
  const response = await client.get<DailyAnalyticsResponse>("/accounts/analytics/daily", params);
  return response.data || [];
}

export async function testAccountVitals(emails: string[]): Promise<{
  results: Array<{
    email: string;
    status: string;
    error?: string;
  }>;
}> {
  const client = getInstantlyClient();
  return client.post<{
    results: Array<{
      email: string;
      status: string;
      error?: string;
    }>;
  }>("/accounts/test/vitals", { emails });
}
</file>

<file path="src/lib/instantly/analytics.ts">
// Instantly Analytics API Functions

import { getInstantlyClient } from "./client";
import { getWarmupAnalytics } from "./accounts";
import type {
  InstantlyCampaignAnalytics,
  InstantlyCampaignDailyAnalytics,
  InstantlyAccountWarmupAnalytics,
} from "./types";

interface AnalyticsOverviewResponse {
  total_leads: number;
  total_contacted: number;
  total_emails_sent: number;
  total_emails_opened: number;
  total_emails_replied: number;
  total_emails_bounced: number;
  overall_open_rate: number;
  overall_reply_rate: number;
  overall_bounce_rate: number;
}

interface CampaignAnalyticsResponse {
  data: InstantlyCampaignAnalytics[];
}

interface DailyAnalyticsResponse {
  data: InstantlyCampaignDailyAnalytics[];
}

export async function getOverviewAnalytics(): Promise<AnalyticsOverviewResponse> {
  const client = getInstantlyClient();
  return client.get<AnalyticsOverviewResponse>("/campaigns/analytics/overview");
}

export async function getCampaignsAnalytics(params?: {
  campaign_id?: string;
  start_date?: string;
  end_date?: string;
}): Promise<InstantlyCampaignAnalytics[]> {
  const client = getInstantlyClient();
  const response = await client.get<CampaignAnalyticsResponse>("/campaigns/analytics", params);
  return response.data || [];
}

export async function getDailyAnalytics(params?: {
  campaign_id?: string;
  start_date?: string;
  end_date?: string;
}): Promise<InstantlyCampaignDailyAnalytics[]> {
  const client = getInstantlyClient();
  const response = await client.get<DailyAnalyticsResponse>("/campaigns/analytics/daily", params);
  return response.data || [];
}

// Combined analytics for dashboard
export interface DashboardAnalytics {
  overview: AnalyticsOverviewResponse;
  campaigns: InstantlyCampaignAnalytics[];
  warmup: InstantlyAccountWarmupAnalytics[];
}

export async function getDashboardAnalytics(): Promise<DashboardAnalytics> {
  const [overview, campaigns, warmup] = await Promise.all([
    getOverviewAnalytics(),
    getCampaignsAnalytics(),
    getWarmupAnalytics(),
  ]);

  return {
    overview,
    campaigns,
    warmup,
  };
}
</file>

<file path="src/lib/instantly/client.ts">
// Instantly API V2 Client

import { createClient } from "@supabase/supabase-js";
import type { InstantlyApiError } from "./types";

const INSTANTLY_API_BASE = "https://api.instantly.ai/api/v2";

// Cache for API key from database
let cachedApiKey: string | null = null;
let cacheTimestamp: number = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

interface RequestOptions {
  method?: "GET" | "POST" | "PATCH" | "DELETE";
  body?: unknown;
  params?: Record<string, string | number | boolean | undefined>;
}

// Fetch API key from database settings
async function getApiKeyFromDatabase(): Promise<string | null> {
  // Return cached value if still valid
  if (cachedApiKey && Date.now() - cacheTimestamp < CACHE_DURATION) {
    return cachedApiKey;
  }

  try {
    // Only works server-side
    if (typeof window !== "undefined") {
      return null;
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

    if (!supabaseUrl || !supabaseServiceKey) {
      return null;
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const { data, error } = await supabase
      .from("settings")
      .select("value")
      .eq("key", "instantly_api_key")
      .single();

    if (error || !data?.value) {
      return null;
    }

    // Update cache
    cachedApiKey = data.value;
    cacheTimestamp = Date.now();

    return data.value;
  } catch {
    return null;
  }
}

// Clear the cache (useful when settings are updated)
export function clearApiKeyCache(): void {
  cachedApiKey = null;
  cacheTimestamp = 0;
}

class InstantlyApiClient {
  private apiKey: string;
  private apiKeyPromise: Promise<string> | null = null;

  constructor(apiKey?: string) {
    this.apiKey = apiKey || process.env.INSTANTLY_API_KEY || "";
  }

  // Lazy load API key from database if not set
  private async getApiKey(): Promise<string> {
    if (this.apiKey) {
      return this.apiKey;
    }

    // Try to get from database
    const dbKey = await getApiKeyFromDatabase();
    if (dbKey) {
      this.apiKey = dbKey;
      return dbKey;
    }

    // Fall back to environment variable
    this.apiKey = process.env.INSTANTLY_API_KEY || "";
    return this.apiKey;
  }

  private buildUrl(endpoint: string, params?: Record<string, string | number | boolean | undefined>): string {
    const url = new URL(`${INSTANTLY_API_BASE}${endpoint}`);

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }

    return url.toString();
  }

  async request<T>(endpoint: string, options: RequestOptions = {}): Promise<T> {
    const { method = "GET", body, params } = options;

    // Get API key (from cache, database, or env)
    const apiKey = await this.getApiKey();

    if (!apiKey) {
      throw new Error("Instantly API key not configured. Please set it in Settings.");
    }

    const url = this.buildUrl(endpoint, params);

    const headers: Record<string, string> = {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    };

    const fetchOptions: RequestInit = {
      method,
      headers,
    };

    if (body && method !== "GET") {
      fetchOptions.body = JSON.stringify(body);
    }

    let response: Response;
    let retries = 0;
    const maxRetries = 3;

    while (retries < maxRetries) {
      try {
        response = await fetch(url, fetchOptions);

        // Handle rate limiting
        if (response.status === 429) {
          const retryAfter = response.headers.get("Retry-After");
          const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, retries) * 1000;
          console.log(`Rate limited, waiting ${waitTime}ms before retry`);
          await this.sleep(waitTime);
          retries++;
          continue;
        }

        break;
      } catch (error) {
        if (retries >= maxRetries - 1) throw error;
        retries++;
        await this.sleep(Math.pow(2, retries) * 1000);
      }
    }

    if (!response!.ok) {
      let errorData: InstantlyApiError;
      try {
        errorData = await response!.json();
      } catch {
        errorData = { error: `HTTP ${response!.status}: ${response!.statusText}` };
      }
      throw new InstantlyError(
        errorData.message || errorData.error || "Unknown error",
        response!.status,
        errorData
      );
    }

    // Handle empty responses
    const text = await response!.text();
    if (!text) {
      return {} as T;
    }

    return JSON.parse(text) as T;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // GET request helper
  async get<T>(endpoint: string, params?: Record<string, string | number | boolean | undefined>): Promise<T> {
    return this.request<T>(endpoint, { method: "GET", params });
  }

  // POST request helper
  async post<T>(endpoint: string, body?: unknown, params?: Record<string, string | number | boolean | undefined>): Promise<T> {
    return this.request<T>(endpoint, { method: "POST", body, params });
  }

  // PATCH request helper
  async patch<T>(endpoint: string, body?: unknown): Promise<T> {
    return this.request<T>(endpoint, { method: "PATCH", body });
  }

  // DELETE request helper
  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: "DELETE" });
  }

  // Check if API is configured (sync check - for quick checks)
  isConfigured(): boolean {
    return !!(this.apiKey || cachedApiKey || process.env.INSTANTLY_API_KEY);
  }

  // Async check if API is configured
  async isConfiguredAsync(): Promise<boolean> {
    const apiKey = await this.getApiKey();
    return !!apiKey;
  }
}

// Custom error class for Instantly API errors
export class InstantlyError extends Error {
  statusCode: number;
  details: InstantlyApiError;

  constructor(message: string, statusCode: number, details: InstantlyApiError) {
    super(message);
    this.name = "InstantlyError";
    this.statusCode = statusCode;
    this.details = details;
  }
}

// Singleton instance
let clientInstance: InstantlyApiClient | null = null;

export function getInstantlyClient(): InstantlyApiClient {
  if (!clientInstance) {
    clientInstance = new InstantlyApiClient();
  }
  return clientInstance;
}

// Export the class for custom instances
export { InstantlyApiClient };
</file>

<file path="src/lib/instantly/leads.ts">
// Instantly Leads API Functions

import { getInstantlyClient } from "./client";
import type {
  InstantlyLead,
  InstantlyLeadCreatePayload,
  InstantlyLeadListPayload,
  InstantlyLeadInterestUpdate,
} from "./types";

interface LeadsListResponse {
  items: InstantlyLead[];
}

export async function fetchInstantlyLeads(params: InstantlyLeadListPayload): Promise<InstantlyLead[]> {
  const client = getInstantlyClient();
  // Leads list uses POST with body
  // Note: Instantly API v2 uses "campaign" not "campaign_id"
  const response = await client.post<LeadsListResponse>("/leads/list", {
    campaign: params.campaign_id,  // API expects "campaign" parameter
    limit: params.limit || 100,
    skip: params.skip || 0,
    email: params.email,
    interest_status: params.interest_status,
  });
  return response.items || [];
}

export async function fetchAllLeadsForCampaign(campaignId: string): Promise<InstantlyLead[]> {
  const allLeads: InstantlyLead[] = [];
  let skip = 0;
  const limit = 100;

  while (true) {
    const leads = await fetchInstantlyLeads({ campaign_id: campaignId, limit, skip });
    allLeads.push(...leads);

    if (leads.length < limit) {
      break;
    }
    skip += limit;
  }

  return allLeads;
}

export async function fetchInstantlyLead(leadId: string): Promise<InstantlyLead> {
  const client = getInstantlyClient();
  return client.get<InstantlyLead>(`/leads/${leadId}`);
}

export async function createInstantlyLead(payload: InstantlyLeadCreatePayload): Promise<InstantlyLead> {
  const client = getInstantlyClient();
  return client.post<InstantlyLead>("/leads", payload);
}

export async function createInstantlyLeads(leads: InstantlyLeadCreatePayload[]): Promise<{ created: number; failed: number }> {
  let created = 0;
  let failed = 0;

  for (const lead of leads) {
    try {
      await createInstantlyLead(lead);
      created++;
    } catch (error) {
      console.error(`Failed to create lead ${lead.email}:`, error);
      failed++;
    }
  }

  return { created, failed };
}

export async function updateInstantlyLead(
  leadId: string,
  updates: Partial<InstantlyLead>
): Promise<InstantlyLead> {
  const client = getInstantlyClient();
  return client.patch<InstantlyLead>(`/leads/${leadId}`, updates);
}

export async function updateLeadInterestStatus(
  payload: InstantlyLeadInterestUpdate
): Promise<{ success: boolean }> {
  const client = getInstantlyClient();
  return client.post<{ success: boolean }>("/leads/update-interest-status", payload);
}

export async function deleteInstantlyLead(leadId: string): Promise<{ success: boolean }> {
  const client = getInstantlyClient();
  return client.delete<{ success: boolean }>(`/leads/${leadId}`);
}

export async function mergeLeads(payload: {
  winning_lead_id: string;
  losing_lead_id: string;
}): Promise<InstantlyLead> {
  const client = getInstantlyClient();
  return client.post<InstantlyLead>("/leads/merge", payload);
}
</file>

<file path="src/lib/providers/instantly/client.ts">
// Instantly API Client with Per-Request API Key Support
// This client is instantiated per-campaign with its own API key

import { ProviderError } from "../types";

const INSTANTLY_API_BASE = "https://api.instantly.ai/api/v2";

interface RequestOptions {
  method?: "GET" | "POST" | "PATCH" | "DELETE";
  body?: unknown;
  params?: Record<string, string | number | boolean | undefined>;
}

export class InstantlyApiClient {
  private apiKey: string;

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new ProviderError(
        "Instantly API key is required",
        "instantly"
      );
    }
    this.apiKey = apiKey;
  }

  private buildUrl(
    endpoint: string,
    params?: Record<string, string | number | boolean | undefined>
  ): string {
    const url = new URL(`${INSTANTLY_API_BASE}${endpoint}`);

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }

    return url.toString();
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  async request<T>(endpoint: string, options: RequestOptions = {}): Promise<T> {
    const { method = "GET", body, params } = options;
    const url = this.buildUrl(endpoint, params);

    const headers: Record<string, string> = {
      Authorization: `Bearer ${this.apiKey}`,
      "Content-Type": "application/json",
    };

    const fetchOptions: RequestInit = {
      method,
      headers,
    };

    if (body && method !== "GET") {
      fetchOptions.body = JSON.stringify(body);
    }

    let response: Response;
    let retries = 0;
    const maxRetries = 3;

    while (retries < maxRetries) {
      try {
        response = await fetch(url, fetchOptions);

        // Handle rate limiting
        if (response.status === 429) {
          const retryAfter = response.headers.get("Retry-After");
          const waitTime = retryAfter
            ? parseInt(retryAfter) * 1000
            : Math.pow(2, retries) * 1000;
          console.log(`[Instantly] Rate limited, waiting ${waitTime}ms before retry`);
          await this.sleep(waitTime);
          retries++;
          continue;
        }

        break;
      } catch (error) {
        if (retries >= maxRetries - 1) throw error;
        retries++;
        await this.sleep(Math.pow(2, retries) * 1000);
      }
    }

    if (!response!.ok) {
      let errorData: { error?: string; message?: string } = {};
      try {
        errorData = await response!.json();
      } catch {
        errorData = { error: `HTTP ${response!.status}: ${response!.statusText}` };
      }
      throw new ProviderError(
        errorData.message || errorData.error || "Unknown Instantly API error",
        "instantly",
        response!.status,
        errorData
      );
    }

    // Handle empty responses
    const text = await response!.text();
    if (!text) {
      return {} as T;
    }

    return JSON.parse(text) as T;
  }

  // GET request helper
  async get<T>(
    endpoint: string,
    params?: Record<string, string | number | boolean | undefined>
  ): Promise<T> {
    return this.request<T>(endpoint, { method: "GET", params });
  }

  // POST request helper
  async post<T>(
    endpoint: string,
    body?: unknown,
    params?: Record<string, string | number | boolean | undefined>
  ): Promise<T> {
    return this.request<T>(endpoint, { method: "POST", body, params });
  }

  // PATCH request helper
  async patch<T>(endpoint: string, body?: unknown): Promise<T> {
    return this.request<T>(endpoint, { method: "PATCH", body });
  }

  // DELETE request helper
  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: "DELETE" });
  }
}
</file>

<file path="src/lib/providers/smartlead/client.ts">
// Smartlead API Client with Per-Request API Key Support
// This client is instantiated per-campaign with its own API key

import { ProviderError } from "../types";

const SMARTLEAD_API_BASE = "https://server.smartlead.ai/api/v1";

interface RequestOptions {
  method?: "GET" | "POST" | "PATCH" | "DELETE";
  body?: unknown;
  params?: Record<string, string | number | boolean | undefined>;
}

export class SmartleadApiClient {
  private apiKey: string;
  private lastRequestTime: number = 0;
  private requestCount: number = 0;

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new ProviderError(
        "Smartlead API key is required",
        "smartlead"
      );
    }
    this.apiKey = apiKey;
  }

  private buildUrl(
    endpoint: string,
    params?: Record<string, string | number | boolean | undefined>
  ): string {
    const url = new URL(`${SMARTLEAD_API_BASE}${endpoint}`);

    // Add API key as query parameter (Smartlead's auth method)
    url.searchParams.append("api_key", this.apiKey);

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }

    return url.toString();
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  // Rate limiting: 10 requests per 2 seconds
  private async enforceRateLimit(): Promise<void> {
    const now = Date.now();
    const windowMs = 2000; // 2 seconds
    const maxRequests = 10;

    if (now - this.lastRequestTime > windowMs) {
      // Reset window
      this.requestCount = 0;
      this.lastRequestTime = now;
    }

    if (this.requestCount >= maxRequests) {
      const waitTime = windowMs - (now - this.lastRequestTime);
      if (waitTime > 0) {
        console.log(`[Smartlead] Rate limit approaching, waiting ${waitTime}ms`);
        await this.sleep(waitTime);
        this.requestCount = 0;
        this.lastRequestTime = Date.now();
      }
    }

    this.requestCount++;
  }

  async request<T>(endpoint: string, options: RequestOptions = {}): Promise<T> {
    const { method = "GET", body, params } = options;

    await this.enforceRateLimit();

    const url = this.buildUrl(endpoint, params);

    const headers: Record<string, string> = {
      "Content-Type": "application/json",
    };

    const fetchOptions: RequestInit = {
      method,
      headers,
    };

    if (body && method !== "GET") {
      fetchOptions.body = JSON.stringify(body);
    }

    let response: Response;
    let retries = 0;
    const maxRetries = 3;

    while (retries < maxRetries) {
      try {
        response = await fetch(url, fetchOptions);

        // Handle rate limiting
        if (response.status === 429) {
          const retryAfter = response.headers.get("Retry-After");
          const waitTime = retryAfter
            ? parseInt(retryAfter) * 1000
            : Math.pow(2, retries) * 1000;
          console.log(`[Smartlead] Rate limited, waiting ${waitTime}ms before retry`);
          await this.sleep(waitTime);
          retries++;
          continue;
        }

        break;
      } catch (error) {
        if (retries >= maxRetries - 1) throw error;
        retries++;
        await this.sleep(Math.pow(2, retries) * 1000);
      }
    }

    if (!response!.ok) {
      let errorData: { error?: string; message?: string } = {};
      try {
        errorData = await response!.json();
      } catch {
        errorData = { error: `HTTP ${response!.status}: ${response!.statusText}` };
      }
      throw new ProviderError(
        errorData.message || errorData.error || "Unknown Smartlead API error",
        "smartlead",
        response!.status,
        errorData
      );
    }

    // Handle empty responses
    const text = await response!.text();
    if (!text) {
      return {} as T;
    }

    return JSON.parse(text) as T;
  }

  // GET request helper
  async get<T>(
    endpoint: string,
    params?: Record<string, string | number | boolean | undefined>
  ): Promise<T> {
    return this.request<T>(endpoint, { method: "GET", params });
  }

  // POST request helper
  async post<T>(
    endpoint: string,
    body?: unknown,
    params?: Record<string, string | number | boolean | undefined>
  ): Promise<T> {
    return this.request<T>(endpoint, { method: "POST", body, params });
  }

  // DELETE request helper
  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: "DELETE" });
  }
}
</file>

<file path="src/lib/providers/smartlead/index.ts">
// Smartlead Provider Implementation
// Implements EmailCampaignProvider interface for Smartlead integration

import type {
  EmailCampaignProvider,
  ProviderCampaign,
  ProviderCampaignDetails,
  ProviderLead,
  ProviderLeadCreatePayload,
  ProviderCampaignAnalytics,
  ProviderDailyAnalytics,
  ProviderEmail,
  ProviderWebhookPayload,
  WebhookEventType,
} from "../types";
import { SmartleadApiClient } from "./client";

// ============================================
// SMARTLEAD API TYPES
// ============================================

interface SmartleadCampaign {
  id: number;
  name: string;
  status: "DRAFTED" | "ACTIVE" | "COMPLETED" | "STOPPED" | "PAUSED";
  created_at: string;
  updated_at?: string;
}

interface SmartleadCampaignStats {
  sent_count: number;
  unique_sent_count: number;
  open_count: number;
  unique_open_count: number;
  click_count: number;
  unique_click_count: number;
  reply_count: number;
  unique_reply_count: number;
  bounce_count: number;
  unsubscribe_count: number;
  total_leads: number;
}

interface SmartleadLead {
  id: number;
  email: string;
  first_name?: string;
  last_name?: string;
  company_name?: string;
  phone_number?: string;
  website?: string;
  linkedin_profile?: string;
  lead_status: "STARTED" | "COMPLETED" | "BLOCKED" | "INPROGRESS";
  category?:
    | "Interested"
    | "Meeting Request"
    | "Not Interested"
    | "Do Not Contact"
    | "Information Request"
    | "Out Of Office"
    | "Wrong Person";
  created_at?: string;
  updated_at?: string;
  // Custom fields are included as additional properties
  [key: string]: unknown;
}

interface SmartleadLeadResponse {
  data: SmartleadLead[];
  total_leads: number;
  offset: number;
  limit: number;
}

interface SmartleadEmailMessage {
  id: number;
  campaign_id: number;
  lead_id: number;
  email_account: string;
  to_email: string;
  subject: string;
  body: string;
  message_type: "SENT" | "REPLY";
  sent_at: string;
  opened_at?: string;
  clicked_at?: string;
  replied_at?: string;
}

interface SmartleadWebhookPayload {
  event_type:
    | "EMAIL_SENT"
    | "EMAIL_OPEN"
    | "EMAIL_LINK_CLICK"
    | "EMAIL_REPLY"
    | "LEAD_UNSUBSCRIBED"
    | "LEAD_CATEGORY_UPDATED";
  campaign_id: number;
  campaign_name?: string;
  lead_id: number;
  email: string;
  timestamp: string;
  // Event-specific fields
  subject?: string;
  body?: string;
  from_email?: string;
  to_email?: string;
  link_url?: string;
  category?: string;
  previous_category?: string;
}

// ============================================
// SMARTLEAD PROVIDER
// ============================================

export class SmartleadProvider implements EmailCampaignProvider {
  readonly providerType = "smartlead" as const;
  private client: SmartleadApiClient;

  constructor(apiKey: string) {
    this.client = new SmartleadApiClient(apiKey);
  }

  // ============================================
  // API KEY VALIDATION
  // ============================================

  async validateApiKey(): Promise<boolean> {
    try {
      // Fetch campaigns to validate the key
      await this.client.get<SmartleadCampaign[]>("/campaigns");
      return true;
    } catch (error) {
      console.error("[SmartleadProvider] API key validation failed:", error);
      return false;
    }
  }

  // ============================================
  // CAMPAIGN OPERATIONS
  // ============================================

  async fetchCampaigns(): Promise<ProviderCampaign[]> {
    const campaigns = await this.client.get<SmartleadCampaign[]>("/campaigns");

    return campaigns.map((campaign) => ({
      id: String(campaign.id),
      name: campaign.name,
      status: this.mapCampaignStatus(campaign.status),
      createdAt: campaign.created_at,
      updatedAt: campaign.updated_at,
    }));
  }

  async fetchCampaign(campaignId: string): Promise<ProviderCampaignDetails> {
    const campaign = await this.client.get<SmartleadCampaign>(
      `/campaigns/${campaignId}`
    );

    // Fetch stats separately
    let stats: SmartleadCampaignStats | null = null;
    try {
      stats = await this.client.get<SmartleadCampaignStats>(
        `/campaigns/${campaignId}/analytics`
      );
    } catch {
      // Stats may not be available
    }

    return {
      id: String(campaign.id),
      name: campaign.name,
      status: this.mapCampaignStatus(campaign.status),
      createdAt: campaign.created_at,
      updatedAt: campaign.updated_at,
      leadsCount: stats?.total_leads,
      emailsSentCount: stats?.sent_count,
      repliesCount: stats?.reply_count,
      bouncesCount: stats?.bounce_count,
    };
  }

  private mapCampaignStatus(
    status: SmartleadCampaign["status"]
  ): ProviderCampaign["status"] {
    switch (status) {
      case "ACTIVE":
        return "active";
      case "PAUSED":
      case "STOPPED":
        return "paused";
      case "COMPLETED":
        return "completed";
      case "DRAFTED":
      default:
        return "draft";
    }
  }

  // ============================================
  // LEAD OPERATIONS
  // ============================================

  async fetchLeads(
    campaignId: string,
    options?: { limit?: number; offset?: number }
  ): Promise<ProviderLead[]> {
    const limit = options?.limit || 100;
    const offset = options?.offset || 0;

    const response = await this.client.get<SmartleadLeadResponse>(
      `/campaigns/${campaignId}/leads`,
      { limit, offset }
    );

    return response.data.map((lead) => this.mapLead(lead));
  }

  async fetchAllLeads(campaignId: string): Promise<ProviderLead[]> {
    const allLeads: ProviderLead[] = [];
    const limit = 100;
    let offset = 0;
    let hasMore = true;

    while (hasMore) {
      const response = await this.client.get<SmartleadLeadResponse>(
        `/campaigns/${campaignId}/leads`,
        { limit, offset }
      );

      const leads = response.data.map((lead) => this.mapLead(lead));
      allLeads.push(...leads);

      offset += limit;
      hasMore = response.data.length === limit && offset < response.total_leads;

      // Log progress for large syncs
      if (allLeads.length % 500 === 0) {
        console.log(
          `[SmartleadProvider] Fetched ${allLeads.length}/${response.total_leads} leads`
        );
      }
    }

    console.log(
      `[SmartleadProvider] Completed fetching ${allLeads.length} leads`
    );
    return allLeads;
  }

  async createLead(
    campaignId: string,
    lead: ProviderLeadCreatePayload
  ): Promise<ProviderLead> {
    const response = await this.client.post<{ lead: SmartleadLead }>(
      `/campaigns/${campaignId}/leads`,
      {
        lead_list: [
          {
            email: lead.email,
            first_name: lead.firstName,
            last_name: lead.lastName,
            company_name: lead.companyName,
            phone_number: lead.phone,
            website: lead.website,
            ...lead.customVariables,
          },
        ],
        settings: {
          ignore_global_block_list: false,
          ignore_unsubscribe_list: false,
          ignore_duplicate_leads_in_other_campaign:
            !lead.skipIfInWorkspace,
        },
      }
    );

    return this.mapLead(response.lead);
  }

  async createLeads(
    campaignId: string,
    leads: ProviderLeadCreatePayload[]
  ): Promise<{ success: number; failed: number }> {
    const leadList = leads.map((lead) => ({
      email: lead.email,
      first_name: lead.firstName,
      last_name: lead.lastName,
      company_name: lead.companyName,
      phone_number: lead.phone,
      website: lead.website,
      ...lead.customVariables,
    }));

    // Smartlead accepts bulk leads
    try {
      await this.client.post(`/campaigns/${campaignId}/leads`, {
        lead_list: leadList,
        settings: {
          ignore_global_block_list: false,
          ignore_unsubscribe_list: false,
          ignore_duplicate_leads_in_other_campaign: false,
        },
      });

      return { success: leads.length, failed: 0 };
    } catch (error) {
      console.error("[SmartleadProvider] Bulk lead creation failed:", error);
      return { success: 0, failed: leads.length };
    }
  }

  async updateLeadInterestStatus(
    campaignId: string,
    email: string,
    status: "interested" | "not_interested" | "neutral"
  ): Promise<void> {
    const categoryMap = {
      interested: "Interested",
      not_interested: "Not Interested",
      neutral: null,
    };

    const category = categoryMap[status];
    if (!category) return;

    // First, find the lead by email
    const response = await this.client.get<SmartleadLeadResponse>(
      `/campaigns/${campaignId}/leads`,
      { email }
    );

    if (response.data.length === 0) {
      throw new Error(`Lead not found: ${email}`);
    }

    const leadId = response.data[0].id;

    // Update the lead category
    await this.client.post(`/campaigns/${campaignId}/leads/${leadId}/update-category`, {
      category,
    });
  }

  private mapLead(lead: SmartleadLead): ProviderLead {
    // Extract custom fields (any field not in standard fields)
    const standardFields = [
      "id",
      "email",
      "first_name",
      "last_name",
      "company_name",
      "phone_number",
      "website",
      "linkedin_profile",
      "lead_status",
      "category",
      "created_at",
      "updated_at",
    ];

    const customFields: Record<string, string> = {};
    Object.entries(lead).forEach(([key, value]) => {
      if (!standardFields.includes(key) && typeof value === "string") {
        customFields[key] = value;
      }
    });

    return {
      id: String(lead.id),
      email: lead.email,
      firstName: lead.first_name,
      lastName: lead.last_name,
      companyName: lead.company_name,
      phone: lead.phone_number,
      website: lead.website,
      linkedinUrl: lead.linkedin_profile,
      status: this.mapLeadStatus(lead.lead_status),
      interestStatus: this.mapLeadCategory(lead.category),
      createdAt: lead.created_at,
      updatedAt: lead.updated_at,
      customFields:
        Object.keys(customFields).length > 0 ? customFields : undefined,
    };
  }

  private mapLeadStatus(status: SmartleadLead["lead_status"]): string {
    switch (status) {
      case "STARTED":
        return "contacted";
      case "INPROGRESS":
        return "in_progress";
      case "COMPLETED":
        return "completed";
      case "BLOCKED":
        return "blocked";
      default:
        return "new";
    }
  }

  private mapLeadCategory(
    category?: SmartleadLead["category"]
  ): ProviderLead["interestStatus"] {
    switch (category) {
      case "Interested":
        return "interested";
      case "Meeting Request":
        return "meeting_booked";
      case "Not Interested":
      case "Do Not Contact":
        return "not_interested";
      case "Out Of Office":
        return "out_of_office";
      case "Wrong Person":
        return "wrong_person";
      case "Information Request":
        return "neutral";
      default:
        return undefined;
    }
  }

  // ============================================
  // ANALYTICS
  // ============================================

  async fetchCampaignAnalytics(
    campaignId: string
  ): Promise<ProviderCampaignAnalytics> {
    const stats = await this.client.get<SmartleadCampaignStats>(
      `/campaigns/${campaignId}/analytics`
    );

    const campaign = await this.client.get<SmartleadCampaign>(
      `/campaigns/${campaignId}`
    );

    return {
      campaignId,
      campaignName: campaign.name,
      leadsCount: stats.total_leads,
      contactedCount: stats.unique_sent_count,
      completedCount: 0, // Not directly available
      emailsSentCount: stats.sent_count,
      openCount: stats.open_count,
      openCountUnique: stats.unique_open_count,
      replyCount: stats.reply_count,
      replyCountUnique: stats.unique_reply_count,
      linkClickCount: stats.click_count,
      linkClickCountUnique: stats.unique_click_count,
      bouncedCount: stats.bounce_count,
      unsubscribedCount: stats.unsubscribe_count,
    };
  }

  async fetchDailyAnalytics(
    campaignId: string,
    startDate: string,
    endDate: string
  ): Promise<ProviderDailyAnalytics[]> {
    // Smartlead may have a different endpoint for daily analytics
    // For now, return empty array as daily breakdown may need custom implementation
    console.log(
      `[SmartleadProvider] Daily analytics for ${campaignId} from ${startDate} to ${endDate}`
    );

    try {
      interface DailyStats {
        date: string;
        sent: number;
        opened: number;
        unique_opened: number;
        replied: number;
        unique_replied: number;
        clicked: number;
        unique_clicked: number;
        bounced?: number;
      }

      const response = await this.client.get<DailyStats[]>(
        `/campaigns/${campaignId}/analytics/daily`,
        {
          start_date: startDate,
          end_date: endDate,
        }
      );

      return response.map((day) => ({
        date: day.date,
        sent: day.sent,
        opened: day.opened,
        uniqueOpened: day.unique_opened,
        replied: day.replied,
        uniqueReplied: day.unique_replied,
        clicked: day.clicked,
        uniqueClicked: day.unique_clicked,
        bounced: day.bounced,
      }));
    } catch {
      // Daily analytics may not be available
      return [];
    }
  }

  // ============================================
  // EMAIL OPERATIONS
  // ============================================

  async fetchEmailsForLead(
    campaignId: string,
    leadEmail: string
  ): Promise<ProviderEmail[]> {
    try {
      // First find the lead
      const leadResponse = await this.client.get<SmartleadLeadResponse>(
        `/campaigns/${campaignId}/leads`,
        { email: leadEmail }
      );

      if (leadResponse.data.length === 0) {
        return [];
      }

      const leadId = leadResponse.data[0].id;

      // Fetch messages for this lead
      const messages = await this.client.get<SmartleadEmailMessage[]>(
        `/campaigns/${campaignId}/leads/${leadId}/messages`
      );

      return messages.map((msg) => ({
        id: String(msg.id),
        fromEmail: msg.email_account,
        toEmail: msg.to_email,
        subject: msg.subject,
        bodyHtml: msg.body,
        campaignId: String(msg.campaign_id),
        leadEmail: msg.to_email,
        isReply: msg.message_type === "REPLY",
        sentAt: msg.sent_at,
        openedAt: msg.opened_at,
        repliedAt: msg.replied_at,
      }));
    } catch (error) {
      console.error("[SmartleadProvider] Error fetching emails:", error);
      return [];
    }
  }

  // ============================================
  // WEBHOOK HANDLING
  // ============================================

  parseWebhookPayload(
    rawBody: string,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _headers: Record<string, string>
  ): ProviderWebhookPayload {
    const payload: SmartleadWebhookPayload = JSON.parse(rawBody);

    return {
      eventType: this.mapWebhookEventType(payload.event_type),
      providerEventId: `${payload.campaign_id}-${payload.lead_id}-${payload.timestamp}`,
      campaignId: String(payload.campaign_id),
      campaignName: payload.campaign_name,
      leadEmail: payload.email,
      leadId: String(payload.lead_id),
      timestamp: payload.timestamp,
      emailSubject: payload.subject,
      emailBody: payload.body,
      emailFrom: payload.from_email,
      emailTo: payload.to_email,
      linkClicked: payload.link_url,
      rawPayload: payload,
    };
  }

  private mapWebhookEventType(
    eventType: SmartleadWebhookPayload["event_type"]
  ): WebhookEventType {
    switch (eventType) {
      case "EMAIL_SENT":
        return "email_sent";
      case "EMAIL_OPEN":
        return "email_opened";
      case "EMAIL_LINK_CLICK":
        return "link_clicked";
      case "EMAIL_REPLY":
        return "reply_received";
      case "LEAD_UNSUBSCRIBED":
        return "unsubscribed";
      case "LEAD_CATEGORY_UPDATED":
        // Map category updates to interest events
        return "lead_interested"; // Will be refined based on category
      default:
        return "unknown";
    }
  }

  verifyWebhookSignature(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _rawBody: string,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _signature: string | null,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _secret: string | null
  ): boolean {
    // Smartlead may not use signature verification
    // Return true for now - implement when docs specify signature method
    return true;
  }
}
</file>

<file path="src/lib/providers/types.ts">
// Provider Abstraction Layer Types
// Shared interfaces for multi-provider support (Instantly, Smartlead, etc.)

export type ProviderType = "instantly" | "smartlead" | "lemlist" | "apollo";

// ============================================
// CAMPAIGN TYPES
// ============================================

export interface ProviderCampaign {
  id: string;
  name: string;
  status: "active" | "paused" | "draft" | "completed";
  createdAt: string;
  updatedAt?: string;
  leadsCount?: number;
  emailsSentCount?: number;
  repliesCount?: number;
  bouncesCount?: number;
}

export interface ProviderCampaignDetails extends ProviderCampaign {
  sequences?: ProviderSequence[];
  emailGap?: number;
  dailyLimit?: number;
  stopOnReply?: boolean;
  linkTracking?: boolean;
  openTracking?: boolean;
}

export interface ProviderSequence {
  steps: ProviderSequenceStep[];
}

export interface ProviderSequenceStep {
  stepNumber: number;
  delayDays: number;
  variants: ProviderSequenceVariant[];
}

export interface ProviderSequenceVariant {
  id?: string;
  subject?: string;
  body?: string;
  isActive: boolean;
}

// ============================================
// LEAD TYPES
// ============================================

export interface ProviderLead {
  id: string;
  email: string;
  firstName?: string;
  lastName?: string;
  companyName?: string;
  companyDomain?: string;
  phone?: string;
  linkedinUrl?: string;
  website?: string;
  status?: string;
  interestStatus?: "interested" | "not_interested" | "neutral" | "wrong_person" | "out_of_office" | "meeting_booked" | "meeting_completed" | "closed";
  createdAt?: string;
  updatedAt?: string;
  lastContactedAt?: string;
  customFields?: Record<string, string>;
  // Engagement metrics
  emailOpenCount?: number;
  emailClickCount?: number;
  emailReplyCount?: number;
}

export interface ProviderLeadCreatePayload {
  email: string;
  firstName?: string;
  lastName?: string;
  companyName?: string;
  phone?: string;
  website?: string;
  customVariables?: Record<string, string>;
  skipIfInCampaign?: boolean;
  skipIfInWorkspace?: boolean;
}

// ============================================
// ANALYTICS TYPES
// ============================================

export interface ProviderCampaignAnalytics {
  campaignId: string;
  campaignName: string;
  // Lead counts
  leadsCount: number;
  contactedCount: number;
  completedCount: number;
  // Email metrics
  emailsSentCount: number;
  openCount: number;
  openCountUnique: number;
  replyCount: number;
  replyCountUnique: number;
  linkClickCount: number;
  linkClickCountUnique: number;
  bouncedCount: number;
  unsubscribedCount: number;
  // Opportunities
  totalOpportunities?: number;
  totalInterested?: number;
  totalMeetingBooked?: number;
  totalClosed?: number;
}

export interface ProviderDailyAnalytics {
  date: string;
  sent: number;
  opened: number;
  uniqueOpened: number;
  replied: number;
  uniqueReplied: number;
  clicked: number;
  uniqueClicked: number;
  bounced?: number;
}

// ============================================
// WEBHOOK TYPES
// ============================================

export type WebhookEventType =
  | "email_sent"
  | "email_opened"
  | "link_clicked"
  | "reply_received"
  | "email_bounced"
  | "unsubscribed"
  | "lead_interested"
  | "lead_not_interested"
  | "meeting_booked"
  | "meeting_completed"
  | "out_of_office"
  | "unknown";

export interface ProviderWebhookPayload {
  eventType: WebhookEventType;
  providerEventId?: string;
  campaignId?: string;
  campaignName?: string;
  leadEmail?: string;
  leadId?: string;
  timestamp: string;
  // Email-specific data
  emailSubject?: string;
  emailBody?: string;
  emailFrom?: string;
  emailTo?: string;
  threadId?: string;
  sequenceStep?: number;
  // Click-specific data
  linkClicked?: string;
  // Bounce-specific data
  bounceType?: "hard" | "soft";
  bounceReason?: string;
  // Raw payload for debugging
  rawPayload: unknown;
}

// ============================================
// EMAIL TYPES
// ============================================

export interface ProviderEmail {
  id: string;
  fromEmail: string;
  toEmail: string;
  ccEmails?: string[];
  bccEmails?: string[];
  subject: string;
  bodyText?: string;
  bodyHtml?: string;
  threadId?: string;
  campaignId?: string;
  leadEmail?: string;
  isReply: boolean;
  sentAt: string;
  openedAt?: string;
  repliedAt?: string;
}

// ============================================
// PROVIDER INTERFACE
// ============================================

export interface EmailCampaignProvider {
  readonly providerType: ProviderType;

  // API Key Validation
  validateApiKey(): Promise<boolean>;

  // Campaign Operations
  fetchCampaigns(): Promise<ProviderCampaign[]>;
  fetchCampaign(campaignId: string): Promise<ProviderCampaignDetails>;

  // Lead Operations
  fetchLeads(campaignId: string, options?: { limit?: number; offset?: number }): Promise<ProviderLead[]>;
  fetchAllLeads(campaignId: string): Promise<ProviderLead[]>;
  createLead(campaignId: string, lead: ProviderLeadCreatePayload): Promise<ProviderLead>;
  createLeads(campaignId: string, leads: ProviderLeadCreatePayload[]): Promise<{ success: number; failed: number }>;
  updateLeadInterestStatus(campaignId: string, email: string, status: "interested" | "not_interested" | "neutral"): Promise<void>;

  // Analytics (for campaign-level only)
  fetchCampaignAnalytics(campaignId: string): Promise<ProviderCampaignAnalytics>;
  fetchDailyAnalytics(campaignId: string, startDate: string, endDate: string): Promise<ProviderDailyAnalytics[]>;

  // Email Operations
  fetchEmailsForLead(campaignId: string, leadEmail: string): Promise<ProviderEmail[]>;

  // Webhook Handling
  parseWebhookPayload(rawBody: string, headers: Record<string, string>): ProviderWebhookPayload;
  verifyWebhookSignature(rawBody: string, signature: string | null, secret: string | null): boolean;
}

// ============================================
// PROVIDER ERROR
// ============================================

export class ProviderError extends Error {
  provider: ProviderType;
  statusCode?: number;
  details?: unknown;

  constructor(
    message: string,
    provider: ProviderType,
    statusCode?: number,
    details?: unknown
  ) {
    super(message);
    this.name = "ProviderError";
    this.provider = provider;
    this.statusCode = statusCode;
    this.details = details;
  }
}

// ============================================
// SYNC RESULT
// ============================================

export interface SyncResult {
  success: boolean;
  imported: number;
  updated: number;
  skipped: number;
  failed: number;
  errors?: string[];
}
</file>

<file path="src/lib/queries/analytics.ts">
// Supabase-based Analytics Queries
// Calculates analytics from local database for client and admin levels
// Campaign-level analytics can use provider API for real-time data

import { SupabaseClient } from "@supabase/supabase-js";

// ============================================
// TYPES
// ============================================

export interface AggregatedAnalytics {
  // Lead counts
  totalLeads: number;
  totalContacted: number;
  totalCompleted: number;
  // Email metrics
  totalEmailsSent: number;
  totalOpens: number;
  totalUniqueOpens: number;
  totalClicks: number;
  totalUniqueClicks: number;
  totalReplies: number;
  totalUniqueReplies: number;
  totalBounced: number;
  // Outcome metrics
  totalPositiveReplies: number;
  totalMeetingsBooked: number;
  totalWon: number;
  totalLost: number;
  totalNotInterested: number;
  // Calculated rates (percentages)
  openRate: number;
  clickRate: number;
  replyRate: number;
  positiveReplyRate: number;
  bounceRate: number;
}

export interface CampaignAnalyticsSummary extends AggregatedAnalytics {
  campaignId: string;
  campaignName: string;
  clientId: string;
  clientName: string;
  isActive: boolean;
  providerType: string;
}

export interface ClientAnalyticsSummary extends AggregatedAnalytics {
  clientId: string;
  clientName: string;
  activeCampaigns: number;
  totalCampaigns: number;
}

export interface AdminAnalyticsSummary extends AggregatedAnalytics {
  totalClients: number;
  activeClients: number;
  totalCampaigns: number;
  activeCampaigns: number;
}

// ============================================
// HELPER FUNCTIONS
// ============================================

function calculateRate(numerator: number, denominator: number): number {
  if (denominator === 0) return 0;
  return Math.round((numerator / denominator) * 10000) / 100; // 2 decimal places
}

function createEmptyAnalytics(): AggregatedAnalytics {
  return {
    totalLeads: 0,
    totalContacted: 0,
    totalCompleted: 0,
    totalEmailsSent: 0,
    totalOpens: 0,
    totalUniqueOpens: 0,
    totalClicks: 0,
    totalUniqueClicks: 0,
    totalReplies: 0,
    totalUniqueReplies: 0,
    totalBounced: 0,
    totalPositiveReplies: 0,
    totalMeetingsBooked: 0,
    totalWon: 0,
    totalLost: 0,
    totalNotInterested: 0,
    openRate: 0,
    clickRate: 0,
    replyRate: 0,
    positiveReplyRate: 0,
    bounceRate: 0,
  };
}

// ============================================
// CAMPAIGN-LEVEL ANALYTICS (from Supabase)
// ============================================

export async function getCampaignAnalyticsFromSupabase(
  supabase: SupabaseClient,
  campaignId: string
): Promise<AggregatedAnalytics> {
  // Get lead-based metrics
  const { data: leadStats, error: leadError } = await supabase
    .from("leads")
    .select("status, is_positive_reply, email_open_count, email_click_count, email_reply_count")
    .eq("campaign_id", campaignId);

  if (leadError) {
    console.error("[Analytics] Error fetching lead stats:", leadError);
    return createEmptyAnalytics();
  }

  // Get email event counts
  const { data: eventStats, error: eventError } = await supabase
    .from("email_events")
    .select("event_type")
    .eq("campaign_id", campaignId);

  if (eventError) {
    console.error("[Analytics] Error fetching event stats:", eventError);
  }

  // Calculate metrics from leads
  const leads = leadStats || [];
  const events = eventStats || [];

  const totalLeads = leads.length;
  const totalContacted = leads.filter((l) => l.status !== "new" && l.status !== null).length;
  const totalCompleted = leads.filter((l) => ["won", "lost", "not_interested"].includes(l.status)).length;

  // Engagement from lead counters
  const totalOpens = leads.reduce((sum, l) => sum + (l.email_open_count || 0), 0);
  const totalUniqueOpens = leads.filter((l) => (l.email_open_count || 0) > 0).length;
  const totalClicks = leads.reduce((sum, l) => sum + (l.email_click_count || 0), 0);
  const totalUniqueClicks = leads.filter((l) => (l.email_click_count || 0) > 0).length;
  const totalReplies = leads.reduce((sum, l) => sum + (l.email_reply_count || 0), 0);
  const totalUniqueReplies = leads.filter((l) => (l.email_reply_count || 0) > 0).length;

  // Outcome metrics
  const totalPositiveReplies = leads.filter((l) => l.is_positive_reply).length;
  const totalMeetingsBooked = leads.filter((l) => l.status === "booked").length;
  const totalWon = leads.filter((l) => l.status === "won").length;
  const totalLost = leads.filter((l) => l.status === "lost").length;
  const totalNotInterested = leads.filter((l) => l.status === "not_interested").length;

  // Event-based metrics
  const totalEmailsSent = events.filter((e) => e.event_type === "sent").length;
  const totalBounced = events.filter((e) => e.event_type === "bounced").length;

  // If no sent events recorded, estimate from contacted leads
  const effectiveSent = totalEmailsSent > 0 ? totalEmailsSent : totalContacted;

  return {
    totalLeads,
    totalContacted,
    totalCompleted,
    totalEmailsSent: effectiveSent,
    totalOpens,
    totalUniqueOpens,
    totalClicks,
    totalUniqueClicks,
    totalReplies,
    totalUniqueReplies,
    totalBounced,
    totalPositiveReplies,
    totalMeetingsBooked,
    totalWon,
    totalLost,
    totalNotInterested,
    openRate: calculateRate(totalUniqueOpens, effectiveSent),
    clickRate: calculateRate(totalUniqueClicks, effectiveSent),
    replyRate: calculateRate(totalUniqueReplies, effectiveSent),
    positiveReplyRate: calculateRate(totalPositiveReplies, effectiveSent),
    bounceRate: calculateRate(totalBounced, effectiveSent),
  };
}

// ============================================
// CLIENT-LEVEL ANALYTICS (aggregated from Supabase)
// ============================================

export async function getClientAnalytics(
  supabase: SupabaseClient,
  clientId: string,
  dateRange?: { start: string; end: string }
): Promise<ClientAnalyticsSummary> {
  // Get client info
  const { data: client, error: clientError } = await supabase
    .from("clients")
    .select("id, name")
    .eq("id", clientId)
    .single();

  if (clientError || !client) {
    throw new Error(`Client not found: ${clientId}`);
  }

  // Get campaigns for this client
  const { data: campaigns, error: campaignError } = await supabase
    .from("campaigns")
    .select("id, is_active")
    .eq("client_id", clientId);

  if (campaignError) {
    console.error("[Analytics] Error fetching campaigns:", campaignError);
  }

  const campaignList = campaigns || [];
  const campaignIds = campaignList.map((c) => c.id);
  const activeCampaigns = campaignList.filter((c) => c.is_active).length;

  if (campaignIds.length === 0) {
    return {
      ...createEmptyAnalytics(),
      clientId: client.id,
      clientName: client.name,
      activeCampaigns: 0,
      totalCampaigns: 0,
    };
  }

  // Build lead query
  let leadQuery = supabase
    .from("leads")
    .select("status, is_positive_reply, email_open_count, email_click_count, email_reply_count")
    .in("campaign_id", campaignIds);

  // Apply date filter if provided
  if (dateRange?.start) {
    leadQuery = leadQuery.gte("created_at", dateRange.start);
  }
  if (dateRange?.end) {
    leadQuery = leadQuery.lte("created_at", dateRange.end);
  }

  const { data: leads, error: leadError } = await leadQuery;

  if (leadError) {
    console.error("[Analytics] Error fetching leads:", leadError);
  }

  // Get email events
  let eventQuery = supabase
    .from("email_events")
    .select("event_type")
    .in("campaign_id", campaignIds);

  if (dateRange?.start) {
    eventQuery = eventQuery.gte("timestamp", dateRange.start);
  }
  if (dateRange?.end) {
    eventQuery = eventQuery.lte("timestamp", dateRange.end);
  }

  const { data: events, error: eventError } = await eventQuery;

  if (eventError) {
    console.error("[Analytics] Error fetching events:", eventError);
  }

  // Calculate aggregated metrics
  const leadList = leads || [];
  const eventList = events || [];

  const totalLeads = leadList.length;
  const totalContacted = leadList.filter((l) => l.status !== "new" && l.status !== null).length;
  const totalCompleted = leadList.filter((l) => ["won", "lost", "not_interested"].includes(l.status)).length;

  const totalOpens = leadList.reduce((sum, l) => sum + (l.email_open_count || 0), 0);
  const totalUniqueOpens = leadList.filter((l) => (l.email_open_count || 0) > 0).length;
  const totalClicks = leadList.reduce((sum, l) => sum + (l.email_click_count || 0), 0);
  const totalUniqueClicks = leadList.filter((l) => (l.email_click_count || 0) > 0).length;
  const totalReplies = leadList.reduce((sum, l) => sum + (l.email_reply_count || 0), 0);
  const totalUniqueReplies = leadList.filter((l) => (l.email_reply_count || 0) > 0).length;

  const totalPositiveReplies = leadList.filter((l) => l.is_positive_reply).length;
  const totalMeetingsBooked = leadList.filter((l) => l.status === "booked").length;
  const totalWon = leadList.filter((l) => l.status === "won").length;
  const totalLost = leadList.filter((l) => l.status === "lost").length;
  const totalNotInterested = leadList.filter((l) => l.status === "not_interested").length;

  const totalEmailsSent = eventList.filter((e) => e.event_type === "sent").length;
  const totalBounced = eventList.filter((e) => e.event_type === "bounced").length;

  const effectiveSent = totalEmailsSent > 0 ? totalEmailsSent : totalContacted;

  return {
    clientId: client.id,
    clientName: client.name,
    activeCampaigns,
    totalCampaigns: campaignList.length,
    totalLeads,
    totalContacted,
    totalCompleted,
    totalEmailsSent: effectiveSent,
    totalOpens,
    totalUniqueOpens,
    totalClicks,
    totalUniqueClicks,
    totalReplies,
    totalUniqueReplies,
    totalBounced,
    totalPositiveReplies,
    totalMeetingsBooked,
    totalWon,
    totalLost,
    totalNotInterested,
    openRate: calculateRate(totalUniqueOpens, effectiveSent),
    clickRate: calculateRate(totalUniqueClicks, effectiveSent),
    replyRate: calculateRate(totalUniqueReplies, effectiveSent),
    positiveReplyRate: calculateRate(totalPositiveReplies, effectiveSent),
    bounceRate: calculateRate(totalBounced, effectiveSent),
  };
}

// ============================================
// ADMIN-LEVEL ANALYTICS (all clients)
// ============================================

export async function getAdminAnalytics(
  supabase: SupabaseClient,
  dateRange?: { start: string; end: string }
): Promise<AdminAnalyticsSummary> {
  // Get all clients
  const { data: clients, error: clientError } = await supabase
    .from("clients")
    .select("id, is_active");

  if (clientError) {
    console.error("[Analytics] Error fetching clients:", clientError);
  }

  const clientList = clients || [];
  const totalClients = clientList.length;
  const activeClients = clientList.filter((c) => c.is_active !== false).length;

  // Get all campaigns
  const { data: campaigns, error: campaignError } = await supabase
    .from("campaigns")
    .select("id, is_active");

  if (campaignError) {
    console.error("[Analytics] Error fetching campaigns:", campaignError);
  }

  const campaignList = campaigns || [];
  const totalCampaigns = campaignList.length;
  const activeCampaigns = campaignList.filter((c) => c.is_active).length;

  if (campaignList.length === 0) {
    return {
      ...createEmptyAnalytics(),
      totalClients,
      activeClients,
      totalCampaigns: 0,
      activeCampaigns: 0,
    };
  }

  // Build lead query
  let leadQuery = supabase
    .from("leads")
    .select("status, is_positive_reply, email_open_count, email_click_count, email_reply_count");

  if (dateRange?.start) {
    leadQuery = leadQuery.gte("created_at", dateRange.start);
  }
  if (dateRange?.end) {
    leadQuery = leadQuery.lte("created_at", dateRange.end);
  }

  const { data: leads, error: leadError } = await leadQuery;

  if (leadError) {
    console.error("[Analytics] Error fetching leads:", leadError);
  }

  // Get email events
  let eventQuery = supabase.from("email_events").select("event_type");

  if (dateRange?.start) {
    eventQuery = eventQuery.gte("timestamp", dateRange.start);
  }
  if (dateRange?.end) {
    eventQuery = eventQuery.lte("timestamp", dateRange.end);
  }

  const { data: events, error: eventError } = await eventQuery;

  if (eventError) {
    console.error("[Analytics] Error fetching events:", eventError);
  }

  // Calculate aggregated metrics
  const leadList = leads || [];
  const eventList = events || [];

  const totalLeads = leadList.length;
  const totalContacted = leadList.filter((l) => l.status !== "new" && l.status !== null).length;
  const totalCompleted = leadList.filter((l) => ["won", "lost", "not_interested"].includes(l.status)).length;

  const totalOpens = leadList.reduce((sum, l) => sum + (l.email_open_count || 0), 0);
  const totalUniqueOpens = leadList.filter((l) => (l.email_open_count || 0) > 0).length;
  const totalClicks = leadList.reduce((sum, l) => sum + (l.email_click_count || 0), 0);
  const totalUniqueClicks = leadList.filter((l) => (l.email_click_count || 0) > 0).length;
  const totalReplies = leadList.reduce((sum, l) => sum + (l.email_reply_count || 0), 0);
  const totalUniqueReplies = leadList.filter((l) => (l.email_reply_count || 0) > 0).length;

  const totalPositiveReplies = leadList.filter((l) => l.is_positive_reply).length;
  const totalMeetingsBooked = leadList.filter((l) => l.status === "booked").length;
  const totalWon = leadList.filter((l) => l.status === "won").length;
  const totalLost = leadList.filter((l) => l.status === "lost").length;
  const totalNotInterested = leadList.filter((l) => l.status === "not_interested").length;

  const totalEmailsSent = eventList.filter((e) => e.event_type === "sent").length;
  const totalBounced = eventList.filter((e) => e.event_type === "bounced").length;

  const effectiveSent = totalEmailsSent > 0 ? totalEmailsSent : totalContacted;

  return {
    totalClients,
    activeClients,
    totalCampaigns,
    activeCampaigns,
    totalLeads,
    totalContacted,
    totalCompleted,
    totalEmailsSent: effectiveSent,
    totalOpens,
    totalUniqueOpens,
    totalClicks,
    totalUniqueClicks,
    totalReplies,
    totalUniqueReplies,
    totalBounced,
    totalPositiveReplies,
    totalMeetingsBooked,
    totalWon,
    totalLost,
    totalNotInterested,
    openRate: calculateRate(totalUniqueOpens, effectiveSent),
    clickRate: calculateRate(totalUniqueClicks, effectiveSent),
    replyRate: calculateRate(totalUniqueReplies, effectiveSent),
    positiveReplyRate: calculateRate(totalPositiveReplies, effectiveSent),
    bounceRate: calculateRate(totalBounced, effectiveSent),
  };
}

// ============================================
// PER-CLIENT BREAKDOWN (for admin dashboard)
// ============================================

export async function getAnalyticsByClient(
  supabase: SupabaseClient,
  dateRange?: { start: string; end: string }
): Promise<ClientAnalyticsSummary[]> {
  // Get all clients
  const { data: clients, error: clientError } = await supabase
    .from("clients")
    .select("id, name, is_active")
    .order("name");

  if (clientError) {
    console.error("[Analytics] Error fetching clients:", clientError);
    return [];
  }

  // Fetch analytics for each client
  const results: ClientAnalyticsSummary[] = [];

  for (const client of clients || []) {
    try {
      const analytics = await getClientAnalytics(supabase, client.id, dateRange);
      results.push(analytics);
    } catch (error) {
      console.error(`[Analytics] Error fetching analytics for client ${client.id}:`, error);
    }
  }

  return results;
}
</file>

<file path="src/lib/queries/campaigns.ts">
import { SupabaseClient } from "@supabase/supabase-js";
import type { Campaign } from "@/types/database";

type TypedSupabaseClient = SupabaseClient;

export async function getCampaigns(supabase: TypedSupabaseClient, clientId: string) {
  const { data, error } = await supabase
    .from("campaigns")
    .select("*")
    .eq("client_id", clientId)
    .order("name");

  if (error) throw error;
  return data;
}

export async function getCampaign(supabase: TypedSupabaseClient, campaignId: string) {
  const { data, error } = await supabase
    .from("campaigns")
    .select("*")
    .eq("id", campaignId)
    .single();

  if (error) throw error;
  return data;
}

export async function getCampaignByInstantlyId(
  supabase: TypedSupabaseClient,
  instantlyCampaignId: string
) {
  const { data, error } = await supabase
    .from("campaigns")
    .select("*")
    .eq("instantly_campaign_id", instantlyCampaignId)
    .single();

  if (error && error.code !== "PGRST116") throw error;
  return data;
}

export async function createCampaign(
  supabase: TypedSupabaseClient,
  campaign: {
    client_id: string;
    name: string;
    instantly_campaign_id?: string;
    copy_body?: string;
  }
) {
  const { data, error } = await supabase
    .from("campaigns")
    .insert(campaign)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function updateCampaign(
  supabase: TypedSupabaseClient,
  campaignId: string,
  updates: Partial<Campaign>
) {
  const { data, error } = await supabase
    .from("campaigns")
    .update(updates)
    .eq("id", campaignId)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteCampaign(supabase: TypedSupabaseClient, campaignId: string) {
  const { error } = await supabase.from("campaigns").delete().eq("id", campaignId);

  if (error) throw error;
}
</file>

<file path="src/lib/queries/clients.ts">
import { SupabaseClient } from "@supabase/supabase-js";
import type { Client } from "@/types/database";

type TypedSupabaseClient = SupabaseClient;

export async function getClients(supabase: TypedSupabaseClient) {
  const { data, error } = await supabase
    .from("clients")
    .select("*")
    .order("created_at", { ascending: false });

  if (error) throw error;
  return data;
}

export async function getClient(supabase: TypedSupabaseClient, clientId: string) {
  const { data, error } = await supabase
    .from("clients")
    .select("*")
    .eq("id", clientId)
    .single();

  if (error) throw error;
  return data;
}

export async function createClient(
  supabase: TypedSupabaseClient,
  client: { name: string }
) {
  const { data, error } = await supabase
    .from("clients")
    .insert(client)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function updateClient(
  supabase: TypedSupabaseClient,
  clientId: string,
  updates: Partial<Client>
) {
  const { data, error } = await supabase
    .from("clients")
    .update(updates)
    .eq("id", clientId)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteClient(supabase: TypedSupabaseClient, clientId: string) {
  const { error } = await supabase.from("clients").delete().eq("id", clientId);

  if (error) throw error;
}

export async function getClientsForUser(supabase: TypedSupabaseClient, userId: string) {
  const { data, error } = await supabase
    .from("client_users")
    .select("clients(*)")
    .eq("user_id", userId);

  if (error) throw error;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return (data?.map((cu: any) => cu.clients).filter(Boolean) || []) as Client[];
}

export async function linkUserToClient(
  supabase: TypedSupabaseClient,
  userId: string,
  clientId: string
) {
  const { error } = await supabase
    .from("client_users")
    .insert({ user_id: userId, client_id: clientId });

  if (error) throw error;
}
</file>

<file path="src/lib/queries/leads.ts">
import { SupabaseClient } from "@supabase/supabase-js";
import type { LeadStatus } from "@/types/database";

type TypedSupabaseClient = SupabaseClient;

export async function getLeads(supabase: TypedSupabaseClient, campaignId: string) {
  const { data, error } = await supabase
    .from("leads")
    .select("*")
    .eq("campaign_id", campaignId)
    .order("updated_at", { ascending: false });

  if (error) throw error;
  return data;
}

export async function getLeadsForClient(supabase: TypedSupabaseClient, clientId: string) {
  const { data, error } = await supabase
    .from("leads")
    .select("*, campaigns!inner(client_id)")
    .eq("campaigns.client_id", clientId)
    .order("updated_at", { ascending: false });

  if (error) throw error;
  return data;
}

export async function getAllLeads(supabase: TypedSupabaseClient) {
  const { data, error } = await supabase
    .from("leads")
    .select("*, campaigns(name, clients(name))")
    .order("updated_at", { ascending: false });

  if (error) throw error;
  return data;
}

export async function getLead(supabase: TypedSupabaseClient, leadId: string) {
  const { data, error } = await supabase
    .from("leads")
    .select("*")
    .eq("id", leadId)
    .single();

  if (error) throw error;
  return data;
}

export async function upsertLead(
  supabase: TypedSupabaseClient,
  lead: {
    campaign_id: string;
    email: string;
    first_name?: string;
    status?: LeadStatus;
    instantly_lead_id?: string;
  }
) {
  const { data, error } = await supabase
    .from("leads")
    .upsert(
      { ...lead, updated_at: new Date().toISOString() },
      { onConflict: "campaign_id,email", ignoreDuplicates: false }
    )
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function updateLeadStatus(
  supabase: TypedSupabaseClient,
  leadId: string,
  status: LeadStatus
) {
  const { data, error } = await supabase
    .from("leads")
    .update({ status, updated_at: new Date().toISOString() })
    .eq("id", leadId)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function updateLeadNotes(
  supabase: TypedSupabaseClient,
  leadId: string,
  notes: string
) {
  const { data, error } = await supabase
    .from("leads")
    .update({ notes, updated_at: new Date().toISOString() })
    .eq("id", leadId)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteLead(supabase: TypedSupabaseClient, leadId: string) {
  const { error } = await supabase.from("leads").delete().eq("id", leadId);

  if (error) throw error;
}
</file>

<file path="src/lib/queries/stats.ts">
import { SupabaseClient } from "@supabase/supabase-js";

type TypedSupabaseClient = SupabaseClient;

export interface LeadStats {
  total_contacted: number;
  total_replied: number;
  total_booked: number;
  total_won: number;
  total_lost: number;
}

export async function getClientStats(
  supabase: TypedSupabaseClient,
  clientId: string
): Promise<LeadStats> {
  const { data, error } = await supabase
    .from("leads")
    .select("status, campaigns!inner(client_id)")
    .eq("campaigns.client_id", clientId);

  if (error) throw error;

  const stats: LeadStats = {
    total_contacted: 0,
    total_replied: 0,
    total_booked: 0,
    total_won: 0,
    total_lost: 0,
  };

  data?.forEach((lead) => {
    switch (lead.status) {
      case "contacted":
        stats.total_contacted++;
        break;
      case "replied":
        stats.total_replied++;
        break;
      case "booked":
        stats.total_booked++;
        break;
      case "won":
        stats.total_won++;
        break;
      case "lost":
        stats.total_lost++;
        break;
    }
  });

  return stats;
}

export async function getCampaignStats(
  supabase: TypedSupabaseClient,
  campaignId: string
): Promise<LeadStats> {
  const { data, error } = await supabase
    .from("leads")
    .select("status")
    .eq("campaign_id", campaignId);

  if (error) throw error;

  const stats: LeadStats = {
    total_contacted: 0,
    total_replied: 0,
    total_booked: 0,
    total_won: 0,
    total_lost: 0,
  };

  data?.forEach((lead) => {
    switch (lead.status) {
      case "contacted":
        stats.total_contacted++;
        break;
      case "replied":
        stats.total_replied++;
        break;
      case "booked":
        stats.total_booked++;
        break;
      case "won":
        stats.total_won++;
        break;
      case "lost":
        stats.total_lost++;
        break;
    }
  });

  return stats;
}

export async function getGlobalStats(supabase: TypedSupabaseClient): Promise<LeadStats> {
  const { data, error } = await supabase.from("leads").select("status");

  if (error) throw error;

  const stats: LeadStats = {
    total_contacted: 0,
    total_replied: 0,
    total_booked: 0,
    total_won: 0,
    total_lost: 0,
  };

  data?.forEach((lead) => {
    switch (lead.status) {
      case "contacted":
        stats.total_contacted++;
        break;
      case "replied":
        stats.total_replied++;
        break;
      case "booked":
        stats.total_booked++;
        break;
      case "won":
        stats.total_won++;
        break;
      case "lost":
        stats.total_lost++;
        break;
    }
  });

  return stats;
}
</file>

<file path="src/lib/smartlead/accounts.ts">
// Smartlead Accounts API Functions

import { getSmartleadClient } from "./client";
import type { SmartleadAccount, SmartleadWarmupStats } from "./types";

// Response types for Smartlead API
interface AccountsListResponse {
  data?: SmartleadAccount[];
  // Smartlead may return array directly
}

interface WarmupStatsResponse {
  total_sent?: number;
  total_inbox?: number;
  total_spam?: number;
  warmup_reputation?: number;
  daily_stats?: Array<{
    date: string;
    sent: number;
    inbox: number;
    spam: number;
  }>;
}

// Fetch all email accounts
export async function fetchSmartleadAccounts(): Promise<SmartleadAccount[]> {
  const client = getSmartleadClient();

  try {
    // Smartlead API: GET /email-accounts
    const response = await client.get<SmartleadAccount[] | AccountsListResponse>(
      "/email-accounts"
    );

    // Handle both array and object responses
    if (Array.isArray(response)) {
      return response;
    }

    return response.data || [];
  } catch (error) {
    console.error("Failed to fetch Smartlead accounts:", error);
    throw error;
  }
}

// Fetch a single email account
export async function fetchSmartleadAccount(
  accountId: number | string
): Promise<SmartleadAccount | null> {
  const client = getSmartleadClient();

  try {
    const response = await client.get<SmartleadAccount>(`/email-accounts/${accountId}`);
    return response;
  } catch (error) {
    console.error(`Failed to fetch Smartlead account ${accountId}:`, error);
    return null;
  }
}

// Get warmup statistics for an account (last 7 days)
export async function getSmartleadWarmupStats(
  accountId: number | string
): Promise<SmartleadWarmupStats | null> {
  const client = getSmartleadClient();

  try {
    // Smartlead API: GET /email-accounts/{id}/warmup-stats
    const response = await client.get<WarmupStatsResponse>(
      `/email-accounts/${accountId}/warmup-stats`
    );

    return {
      email_account_id: typeof accountId === "number" ? accountId : parseInt(accountId),
      total_sent: response.total_sent || 0,
      total_inbox: response.total_inbox || 0,
      total_spam: response.total_spam || 0,
      warmup_reputation: response.warmup_reputation || 0,
      daily_stats: response.daily_stats || [],
    };
  } catch (error) {
    console.error(`Failed to fetch Smartlead warmup stats for ${accountId}:`, error);
    return null;
  }
}

// Get warmup stats for multiple accounts
export async function getSmartleadWarmupAnalytics(
  accounts: SmartleadAccount[]
): Promise<SmartleadWarmupStats[]> {
  const results: SmartleadWarmupStats[] = [];

  // Process in batches to avoid rate limiting
  const batchSize = 5;
  for (let i = 0; i < accounts.length; i += batchSize) {
    const batch = accounts.slice(i, i + batchSize);

    const batchResults = await Promise.all(
      batch.map(async (account) => {
        const stats = await getSmartleadWarmupStats(account.id);
        if (stats) {
          stats.email = account.email;
        }
        return stats;
      })
    );

    results.push(...batchResults.filter((s): s is SmartleadWarmupStats => s !== null));

    // Small delay between batches to avoid rate limiting
    if (i + batchSize < accounts.length) {
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
  }

  return results;
}

// Enable warmup for an account
export async function enableSmartleadWarmup(
  accountId: number | string,
  options?: {
    total_warmup_per_day?: number;
    daily_rampup?: number;
    reply_rate_percentage?: number;
  }
): Promise<boolean> {
  const client = getSmartleadClient();

  try {
    await client.post(`/email-accounts/${accountId}/warmup`, {
      warmup_enabled: true,
      total_warmup_per_day: options?.total_warmup_per_day || 35,
      daily_rampup: options?.daily_rampup || 3,
      reply_rate_percentage: options?.reply_rate_percentage || 38,
    });
    return true;
  } catch (error) {
    console.error(`Failed to enable Smartlead warmup for ${accountId}:`, error);
    return false;
  }
}

// Disable warmup for an account
export async function disableSmartleadWarmup(accountId: number | string): Promise<boolean> {
  const client = getSmartleadClient();

  try {
    await client.post(`/email-accounts/${accountId}/warmup`, {
      warmup_enabled: false,
    });
    return true;
  } catch (error) {
    console.error(`Failed to disable Smartlead warmup for ${accountId}:`, error);
    return false;
  }
}

// Get all accounts with their warmup stats (combined call)
export async function fetchSmartleadAccountsWithWarmup(): Promise<
  Array<SmartleadAccount & { warmup_stats?: SmartleadWarmupStats }>
> {
  const accounts = await fetchSmartleadAccounts();
  const warmupStats = await getSmartleadWarmupAnalytics(accounts);

  // Merge stats with accounts
  return accounts.map((account) => {
    const stats = warmupStats.find((s) => s.email_account_id === account.id);
    return {
      ...account,
      warmup_stats: stats,
    };
  });
}
</file>

<file path="src/lib/smartlead/client.ts">
// Smartlead API Client

import { createClient } from "@supabase/supabase-js";
import type { SmartleadApiError } from "./types";

const SMARTLEAD_API_BASE = "https://server.smartlead.ai/api/v1";

// Cache for API key from database
let cachedApiKey: string | null = null;
let cacheTimestamp: number = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

interface RequestOptions {
  method?: "GET" | "POST" | "PATCH" | "DELETE";
  body?: unknown;
  params?: Record<string, string | number | boolean | undefined>;
}

// Fetch API key from database settings
async function getApiKeyFromDatabase(): Promise<string | null> {
  // Return cached value if still valid
  if (cachedApiKey && Date.now() - cacheTimestamp < CACHE_DURATION) {
    return cachedApiKey;
  }

  try {
    // Only works server-side
    if (typeof window !== "undefined") {
      return null;
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

    if (!supabaseUrl || !supabaseServiceKey) {
      return null;
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const { data, error } = await supabase
      .from("settings")
      .select("value")
      .eq("key", "smartlead_api_key")
      .single();

    if (error || !data?.value) {
      return null;
    }

    // Update cache
    cachedApiKey = data.value;
    cacheTimestamp = Date.now();

    return data.value;
  } catch {
    return null;
  }
}

// Clear the cache (useful when settings are updated)
export function clearApiKeyCache(): void {
  cachedApiKey = null;
  cacheTimestamp = 0;
}

class SmartleadApiClient {
  private apiKey: string;

  constructor(apiKey?: string) {
    this.apiKey = apiKey || process.env.SMARTLEAD_API_KEY || "";
  }

  // Lazy load API key from database if not set
  private async getApiKey(): Promise<string> {
    if (this.apiKey) {
      return this.apiKey;
    }

    // Try to get from database
    const dbKey = await getApiKeyFromDatabase();
    if (dbKey) {
      this.apiKey = dbKey;
      return dbKey;
    }

    // Fall back to environment variable
    this.apiKey = process.env.SMARTLEAD_API_KEY || "";
    return this.apiKey;
  }

  private buildUrl(
    endpoint: string,
    apiKey: string,
    params?: Record<string, string | number | boolean | undefined>
  ): string {
    const url = new URL(`${SMARTLEAD_API_BASE}${endpoint}`);

    // Smartlead uses api_key as query parameter
    url.searchParams.append("api_key", apiKey);

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }

    return url.toString();
  }

  async request<T>(endpoint: string, options: RequestOptions = {}): Promise<T> {
    const { method = "GET", body, params } = options;

    // Get API key (from cache, database, or env)
    const apiKey = await this.getApiKey();

    if (!apiKey) {
      throw new Error("Smartlead API key not configured. Please set it in Settings.");
    }

    const url = this.buildUrl(endpoint, apiKey, params);

    const headers: Record<string, string> = {
      "Content-Type": "application/json",
    };

    const fetchOptions: RequestInit = {
      method,
      headers,
    };

    if (body && method !== "GET") {
      fetchOptions.body = JSON.stringify(body);
    }

    let response: Response;
    let retries = 0;
    const maxRetries = 3;

    while (retries < maxRetries) {
      try {
        response = await fetch(url, fetchOptions);

        // Handle rate limiting
        if (response.status === 429) {
          const retryAfter = response.headers.get("Retry-After");
          const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, retries) * 1000;
          console.log(`Smartlead rate limited, waiting ${waitTime}ms before retry`);
          await this.sleep(waitTime);
          retries++;
          continue;
        }

        break;
      } catch (error) {
        if (retries >= maxRetries - 1) throw error;
        retries++;
        await this.sleep(Math.pow(2, retries) * 1000);
      }
    }

    if (!response!.ok) {
      let errorData: SmartleadApiError;
      try {
        errorData = await response!.json();
      } catch {
        errorData = { error: `HTTP ${response!.status}: ${response!.statusText}` };
      }
      throw new SmartleadError(
        errorData.message || errorData.error || "Unknown error",
        response!.status,
        errorData
      );
    }

    // Handle empty responses
    const text = await response!.text();
    if (!text) {
      return {} as T;
    }

    return JSON.parse(text) as T;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  // GET request helper
  async get<T>(
    endpoint: string,
    params?: Record<string, string | number | boolean | undefined>
  ): Promise<T> {
    return this.request<T>(endpoint, { method: "GET", params });
  }

  // POST request helper
  async post<T>(
    endpoint: string,
    body?: unknown,
    params?: Record<string, string | number | boolean | undefined>
  ): Promise<T> {
    return this.request<T>(endpoint, { method: "POST", body, params });
  }

  // PATCH request helper
  async patch<T>(endpoint: string, body?: unknown): Promise<T> {
    return this.request<T>(endpoint, { method: "PATCH", body });
  }

  // DELETE request helper
  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: "DELETE" });
  }

  // Check if API is configured (sync check)
  isConfigured(): boolean {
    return !!(this.apiKey || cachedApiKey || process.env.SMARTLEAD_API_KEY);
  }

  // Async check if API is configured
  async isConfiguredAsync(): Promise<boolean> {
    const apiKey = await this.getApiKey();
    return !!apiKey;
  }
}

// Custom error class for Smartlead API errors
export class SmartleadError extends Error {
  statusCode: number;
  details: SmartleadApiError;

  constructor(message: string, statusCode: number, details: SmartleadApiError) {
    super(message);
    this.name = "SmartleadError";
    this.statusCode = statusCode;
    this.details = details;
  }
}

// Singleton instance
let clientInstance: SmartleadApiClient | null = null;

export function getSmartleadClient(): SmartleadApiClient {
  if (!clientInstance) {
    clientInstance = new SmartleadApiClient();
  }
  return clientInstance;
}

// Export the class for custom instances
export { SmartleadApiClient };
</file>

<file path="src/lib/smartlead/index.ts">
// Smartlead API Library
// Export all functions and types for use in the application

// Client
export { getSmartleadClient, SmartleadApiClient, SmartleadError, clearApiKeyCache } from "./client";

// Account functions
export {
  fetchSmartleadAccounts,
  fetchSmartleadAccount,
  getSmartleadWarmupStats,
  getSmartleadWarmupAnalytics,
  enableSmartleadWarmup,
  disableSmartleadWarmup,
  fetchSmartleadAccountsWithWarmup,
} from "./accounts";

// Types
export type {
  SmartleadApiError,
  SmartleadAccount,
  SmartleadWarmupStats,
  SmartleadWarmupDayStats,
  SmartleadCampaign,
  SmartleadLead,
  SmartleadListResponse,
  SmartleadSyncResult,
} from "./types";
</file>

<file path="src/lib/smartlead/types.ts">
// Smartlead API Types

// Error types
export interface SmartleadApiError {
  error?: string;
  message?: string;
  statusCode?: number;
}

// Account types
export interface SmartleadAccount {
  id: number;
  email: string;
  from_name?: string;
  first_name?: string;
  last_name?: string;
  signature?: string;
  smtp_host?: string;
  smtp_port?: number;
  imap_host?: string;
  imap_port?: number;
  warmup_enabled?: boolean;
  total_warmup_per_day?: number;
  daily_rampup?: number;
  reply_rate_percentage?: number;
  max_email_per_day?: number;
  client_id?: number;
  type?: string;
  created_at?: string;
  updated_at?: string;
}

// Warmup statistics
export interface SmartleadWarmupDayStats {
  date: string;
  sent: number;
  inbox: number;
  spam: number;
  reputation?: number;
}

export interface SmartleadWarmupStats {
  email_account_id: number;
  email?: string;
  total_sent: number;
  total_inbox: number;
  total_spam: number;
  warmup_reputation: number;
  daily_stats?: SmartleadWarmupDayStats[];
}

// Campaign types (for reference)
export interface SmartleadCampaign {
  id: number;
  name: string;
  status?: string;
  created_at?: string;
  updated_at?: string;
}

// Lead types
export interface SmartleadLead {
  id: number;
  email: string;
  first_name?: string;
  last_name?: string;
  company_name?: string;
  phone?: string;
  website?: string;
  campaign_id?: number;
  status?: string;
  created_at?: string;
}

// API Response wrappers
export interface SmartleadListResponse<T> {
  data?: T[];
  items?: T[];
  total?: number;
}

// Sync result type
export interface SmartleadSyncResult {
  success: boolean;
  added: number;
  updated: number;
  failed: number;
  errors?: string[];
}
</file>

<file path="src/lib/supabase/client.ts">
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
</file>

<file path="src/lib/supabase/server.ts">
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing sessions.
          }
        },
      },
    }
  );
}
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/middleware.ts">
import { type NextRequest } from "next/server";
import { updateSession } from "@/lib/supabase/middleware";

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - api/webhooks (webhook endpoints - no auth needed)
     */
    "/((?!_next/static|_next/image|favicon.ico|api/webhooks).*)",
  ],
};
</file>

<file path="supabase/migrations/20241230_add_lead_database.sql">
-- ============================================
-- Migration: Master Lead Database
-- Date: 2024-12-30
-- Purpose: Store all scraped/contacted leads with rich metadata
-- ============================================

-- ============================================
-- 1. LEAD SOURCES TABLE (Upload Batches)
-- ============================================
-- Each CSV upload creates a new source with batch-level metadata
CREATE TABLE IF NOT EXISTS lead_sources (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Batch identification
  name text NOT NULL, -- e.g., "German SaaS Companies Dec 2024"
  file_name text, -- Original uploaded file name

  -- Batch-level metadata (applies to all leads in this batch)
  industry text, -- e.g., "SaaS", "E-commerce", "Manufacturing"
  region text, -- e.g., "DACH", "US", "UK", "EU"
  sub_region text, -- e.g., "Bavaria", "California"
  source_type text, -- e.g., "Apollo", "LinkedIn", "Manual", "ZoomInfo"
  scrape_date date, -- When the data was scraped

  -- Additional flexible metadata
  tags text[], -- Array of tags for categorization
  notes text,
  custom_fields jsonb DEFAULT '{}', -- Any other metadata

  -- Stats
  total_records integer DEFAULT 0,
  imported_records integer DEFAULT 0,
  duplicate_records integer DEFAULT 0,

  -- Timestamps
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_lead_sources_created ON lead_sources(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_lead_sources_industry ON lead_sources(industry);
CREATE INDEX IF NOT EXISTS idx_lead_sources_region ON lead_sources(region);

-- ============================================
-- 2. ENRICHED LEADS TABLE (Master Lead Database)
-- ============================================
-- All leads from all sources, with URL as primary company identifier
CREATE TABLE IF NOT EXISTS enriched_leads (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  source_id uuid REFERENCES lead_sources(id) ON DELETE SET NULL,

  -- Primary identifiers
  url text, -- Company website URL (primary matching key, normalized)
  domain text, -- Extracted domain from URL (e.g., "example.com")
  email text,

  -- Person info
  first_name text,
  last_name text,
  full_name text, -- Computed or provided
  job_title text,
  linkedin_url text,
  phone text,

  -- Company info
  company_name text,
  company_size text, -- e.g., "1-10", "11-50", "51-200"
  company_revenue text,
  company_founded integer, -- Year
  company_linkedin text,

  -- Location
  country text,
  city text,
  state text,

  -- Classification (can override source-level)
  industry text,
  sub_industry text,

  -- Flexible data (for any CSV columns we don't have fixed fields for)
  extra_data jsonb DEFAULT '{}',

  -- Status tracking
  contacted_at timestamptz, -- When first contacted (if ever)
  campaign_id uuid REFERENCES campaigns(id) ON DELETE SET NULL, -- Link to campaign if contacted
  lead_id uuid REFERENCES leads(id) ON DELETE SET NULL, -- Link to campaign lead if exists

  -- Timestamps
  scraped_at timestamptz, -- When this data was scraped
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),

  -- Unique constraint: one person per company (by URL + name combo)
  UNIQUE(domain, email)
);

-- Indexes for fast lookups
CREATE INDEX IF NOT EXISTS idx_enriched_leads_domain ON enriched_leads(domain);
CREATE INDEX IF NOT EXISTS idx_enriched_leads_url ON enriched_leads(url);
CREATE INDEX IF NOT EXISTS idx_enriched_leads_email ON enriched_leads(email);
CREATE INDEX IF NOT EXISTS idx_enriched_leads_company ON enriched_leads(company_name);
CREATE INDEX IF NOT EXISTS idx_enriched_leads_source ON enriched_leads(source_id);
CREATE INDEX IF NOT EXISTS idx_enriched_leads_industry ON enriched_leads(industry);
CREATE INDEX IF NOT EXISTS idx_enriched_leads_country ON enriched_leads(country);
CREATE INDEX IF NOT EXISTS idx_enriched_leads_name ON enriched_leads(first_name, last_name);

-- Full text search on company and person names
CREATE INDEX IF NOT EXISTS idx_enriched_leads_search ON enriched_leads
  USING gin(to_tsvector('english', coalesce(company_name, '') || ' ' || coalesce(first_name, '') || ' ' || coalesce(last_name, '')));

-- ============================================
-- 3. HELPER FUNCTION: Extract domain from URL
-- ============================================
CREATE OR REPLACE FUNCTION extract_domain(url_input text)
RETURNS text AS $$
DECLARE
  domain_result text;
BEGIN
  IF url_input IS NULL OR url_input = '' THEN
    RETURN NULL;
  END IF;

  -- Remove protocol
  domain_result := regexp_replace(url_input, '^https?://', '', 'i');
  -- Remove www.
  domain_result := regexp_replace(domain_result, '^www\.', '', 'i');
  -- Remove path and query
  domain_result := regexp_replace(domain_result, '/.*$', '');
  -- Remove port
  domain_result := regexp_replace(domain_result, ':\d+$', '');
  -- Lowercase
  domain_result := lower(domain_result);

  RETURN domain_result;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================
-- 4. TRIGGER: Auto-extract domain from URL
-- ============================================
CREATE OR REPLACE FUNCTION set_enriched_lead_domain()
RETURNS TRIGGER AS $$
BEGIN
  -- Extract domain from URL if not provided
  IF NEW.url IS NOT NULL AND (NEW.domain IS NULL OR NEW.domain = '') THEN
    NEW.domain := extract_domain(NEW.url);
  END IF;

  -- Extract domain from email if still no domain
  IF NEW.domain IS NULL AND NEW.email IS NOT NULL THEN
    NEW.domain := lower(split_part(NEW.email, '@', 2));
  END IF;

  -- Compute full name
  IF NEW.full_name IS NULL AND (NEW.first_name IS NOT NULL OR NEW.last_name IS NOT NULL) THEN
    NEW.full_name := trim(coalesce(NEW.first_name, '') || ' ' || coalesce(NEW.last_name, ''));
  END IF;

  NEW.updated_at := now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS set_enriched_lead_domain_trigger ON enriched_leads;
CREATE TRIGGER set_enriched_lead_domain_trigger
  BEFORE INSERT OR UPDATE ON enriched_leads
  FOR EACH ROW
  EXECUTE FUNCTION set_enriched_lead_domain();

-- ============================================
-- 5. UPDATE TRIGGER FOR lead_sources
-- ============================================
DROP TRIGGER IF EXISTS update_lead_sources_updated_at ON lead_sources;
CREATE TRIGGER update_lead_sources_updated_at
  BEFORE UPDATE ON lead_sources
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- 6. ROW LEVEL SECURITY
-- ============================================
ALTER TABLE lead_sources ENABLE ROW LEVEL SECURITY;
ALTER TABLE enriched_leads ENABLE ROW LEVEL SECURITY;

-- Admin only for now (can add client access later)
CREATE POLICY "Admin can manage lead_sources" ON lead_sources
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
    )
  );

CREATE POLICY "Admin can manage enriched_leads" ON enriched_leads
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
    )
  );

-- ============================================
-- 7. VIEW: Lead with enrichment data
-- ============================================
-- Use this view to get campaign leads with their enriched data
CREATE OR REPLACE VIEW leads_with_enrichment AS
SELECT
  l.*,
  el.industry as enriched_industry,
  el.company_size as enriched_company_size,
  el.country as enriched_country,
  el.city as enriched_city,
  el.job_title as enriched_job_title,
  el.linkedin_url as enriched_linkedin,
  el.extra_data as enriched_extra_data,
  ls.name as source_name,
  ls.region as source_region,
  ls.source_type as source_type
FROM leads l
LEFT JOIN enriched_leads el ON (
  -- Match by email domain
  lower(split_part(l.email, '@', 2)) = el.domain
  AND (
    -- And optionally by name
    (lower(l.first_name) = lower(el.first_name) AND lower(l.last_name) = lower(el.last_name))
    OR el.first_name IS NULL
  )
)
LEFT JOIN lead_sources ls ON el.source_id = ls.id;

-- ============================================
-- 8. COMMENTS
-- ============================================
COMMENT ON TABLE lead_sources IS 'Metadata for CSV upload batches - industry, region, source, etc.';
COMMENT ON TABLE enriched_leads IS 'Master database of all scraped/contacted leads with rich data';
COMMENT ON COLUMN enriched_leads.domain IS 'Normalized domain extracted from URL or email - primary matching key';
COMMENT ON COLUMN enriched_leads.extra_data IS 'Flexible JSONB field for any CSV columns not in fixed schema';
COMMENT ON FUNCTION extract_domain IS 'Extracts and normalizes domain from a URL';
</file>

<file path="supabase/migrations/20250101_add_instantly_lead_fields.sql">
-- ============================================
-- Migration: Add additional Instantly lead fields
-- Date: 2025-01-01
-- Purpose: Store more data from Instantly API
-- ============================================

-- Add new columns to leads table
ALTER TABLE leads ADD COLUMN IF NOT EXISTS company_domain text;
ALTER TABLE leads ADD COLUMN IF NOT EXISTS personalization text;
ALTER TABLE leads ADD COLUMN IF NOT EXISTS instantly_created_at timestamptz;
ALTER TABLE leads ADD COLUMN IF NOT EXISTS last_contacted_at timestamptz;
ALTER TABLE leads ADD COLUMN IF NOT EXISTS last_step_info jsonb;
ALTER TABLE leads ADD COLUMN IF NOT EXISTS email_open_count integer DEFAULT 0;
ALTER TABLE leads ADD COLUMN IF NOT EXISTS email_click_count integer DEFAULT 0;
ALTER TABLE leads ADD COLUMN IF NOT EXISTS email_reply_count integer DEFAULT 0;

-- Add indexes for common queries
CREATE INDEX IF NOT EXISTS idx_leads_company_domain ON leads(company_domain);
CREATE INDEX IF NOT EXISTS idx_leads_last_contacted_at ON leads(last_contacted_at DESC);
CREATE INDEX IF NOT EXISTS idx_leads_instantly_created_at ON leads(instantly_created_at DESC);

-- Comments for documentation
COMMENT ON COLUMN leads.company_domain IS 'Company domain extracted by Instantly (e.g., example.com)';
COMMENT ON COLUMN leads.personalization IS 'Personalization/custom intro text from Instantly';
COMMENT ON COLUMN leads.instantly_created_at IS 'When the lead was created in Instantly';
COMMENT ON COLUMN leads.last_contacted_at IS 'When the lead was last contacted (email sent)';
COMMENT ON COLUMN leads.last_step_info IS 'JSON with last email step info (stepID, from, timestamp)';
COMMENT ON COLUMN leads.email_open_count IS 'Number of email opens tracked by Instantly';
COMMENT ON COLUMN leads.email_click_count IS 'Number of link clicks tracked by Instantly';
COMMENT ON COLUMN leads.email_reply_count IS 'Number of replies received from this lead';
</file>

<file path="supabase/migrations/20250103_add_per_campaign_api_keys.sql">
-- Migration: Add per-campaign API key storage
-- This enables each campaign to have its own API key, supporting multi-provider scenarios
-- where different campaigns under the same client may use different API keys or providers

-- Add new columns to campaigns table
ALTER TABLE campaigns
ADD COLUMN IF NOT EXISTS api_key_encrypted text,
ADD COLUMN IF NOT EXISTS api_key_label text,
ADD COLUMN IF NOT EXISTS webhook_secret text,
ADD COLUMN IF NOT EXISTS last_lead_sync_at timestamptz;

-- Add comment for documentation
COMMENT ON COLUMN campaigns.api_key_encrypted IS 'Encrypted API key for the campaign provider (Instantly/Smartlead)';
COMMENT ON COLUMN campaigns.api_key_label IS 'Optional label to identify which workspace/account this key belongs to';
COMMENT ON COLUMN campaigns.webhook_secret IS 'Per-campaign webhook secret for signature verification';
COMMENT ON COLUMN campaigns.last_lead_sync_at IS 'Timestamp of the last full lead sync from provider';

-- Update email_events table for multi-provider support
ALTER TABLE email_events
ADD COLUMN IF NOT EXISTS provider_type text CHECK (provider_type IN ('instantly', 'smartlead', 'lemlist', 'apollo')),
ADD COLUMN IF NOT EXISTS provider_event_id text;

-- Create index for provider event lookups (prevents duplicates)
CREATE UNIQUE INDEX IF NOT EXISTS idx_email_events_provider_unique
ON email_events(provider_type, provider_event_id)
WHERE provider_event_id IS NOT NULL;

-- Add provider_lead_id to leads table for multi-provider support
ALTER TABLE leads
ADD COLUMN IF NOT EXISTS provider_type text CHECK (provider_type IN ('instantly', 'smartlead', 'lemlist', 'apollo')),
ADD COLUMN IF NOT EXISTS provider_lead_id text;

-- Create index for provider lead lookups
CREATE INDEX IF NOT EXISTS idx_leads_provider_lookup
ON leads(provider_type, provider_lead_id)
WHERE provider_lead_id IS NOT NULL;

-- Migrate existing data: Set provider_type to 'instantly' for existing records
UPDATE campaigns
SET provider_type = 'instantly'
WHERE provider_type IS NULL AND instantly_campaign_id IS NOT NULL;

UPDATE leads
SET provider_type = 'instantly', provider_lead_id = instantly_lead_id
WHERE provider_type IS NULL AND instantly_lead_id IS NOT NULL;

UPDATE email_events
SET provider_type = 'instantly', provider_event_id = instantly_event_id
WHERE provider_type IS NULL AND instantly_event_id IS NOT NULL;

-- Note: We're not dropping the legacy columns (instantly_campaign_id, instantly_lead_id, instantly_event_id)
-- to maintain backward compatibility. They can be removed in a future migration.
</file>

<file path="supabase/migrations/20250103_add_subscriptions.sql">
-- ============================================
-- SUBSCRIPTIONS TABLE - Agency SaaS Expense Tracking
-- ============================================

-- Billing cycle enum
CREATE TYPE billing_cycle AS ENUM ('monthly', 'yearly', 'quarterly', 'weekly', 'custom');

-- Subscriptions table
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  url TEXT,
  username TEXT,
  password TEXT,
  cost DECIMAL(10, 2) DEFAULT 0,
  billing_cycle billing_cycle DEFAULT 'monthly',
  renewal_date DATE,
  credits_balance INTEGER DEFAULT 0,
  credits_limit INTEGER DEFAULT 0,
  category TEXT,
  notes TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Index for common queries
CREATE INDEX idx_subscriptions_is_active ON subscriptions(is_active);
CREATE INDEX idx_subscriptions_renewal_date ON subscriptions(renewal_date);
CREATE INDEX idx_subscriptions_category ON subscriptions(category);

-- Updated at trigger
CREATE OR REPLACE FUNCTION update_subscriptions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER subscriptions_updated_at
  BEFORE UPDATE ON subscriptions
  FOR EACH ROW
  EXECUTE FUNCTION update_subscriptions_updated_at();

-- RLS Policies (admin only)
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;

-- Only admins can view subscriptions
CREATE POLICY "Admins can view subscriptions"
  ON subscriptions
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- Only admins can insert subscriptions
CREATE POLICY "Admins can insert subscriptions"
  ON subscriptions
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- Only admins can update subscriptions
CREATE POLICY "Admins can update subscriptions"
  ON subscriptions
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- Only admins can delete subscriptions
CREATE POLICY "Admins can delete subscriptions"
  ON subscriptions
  FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role = 'admin'
    )
  );
</file>

<file path="supabase/migrations/20260103_add_infrastructure_health.sql">
-- ============================================
-- INFRASTRUCTURE HEALTH TABLES
-- Date: 2026-01-03
-- Purpose: Store email accounts, DNS health, and historical metrics
-- ============================================

-- ============================================
-- 1. EMAIL ACCOUNTS TABLE (Central account registry)
-- ============================================
CREATE TABLE IF NOT EXISTS email_accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Provider identification
  provider_type TEXT NOT NULL CHECK (provider_type IN ('instantly', 'smartlead')),
  provider_account_id TEXT, -- ID from the provider (e.g., Smartlead numeric ID)
  email TEXT NOT NULL,

  -- Client assignment (manual mapping by admin)
  client_id UUID REFERENCES clients(id) ON DELETE SET NULL,

  -- Account metadata
  first_name TEXT,
  last_name TEXT,
  domain TEXT GENERATED ALWAYS AS (SPLIT_PART(email, '@', 2)) STORED,

  -- Status fields
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'error', 'disconnected', 'paused')),
  error_message TEXT,

  -- Warmup fields
  warmup_enabled BOOLEAN DEFAULT false,
  warmup_reputation INTEGER, -- 0-100
  warmup_emails_sent INTEGER DEFAULT 0,
  warmup_emails_received INTEGER DEFAULT 0,
  warmup_saved_from_spam INTEGER DEFAULT 0,

  -- Sending configuration
  daily_limit INTEGER,
  emails_sent_today INTEGER DEFAULT 0,

  -- Timestamps
  last_synced_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),

  -- Unique constraint per provider
  UNIQUE(provider_type, email)
);

-- Indexes for email_accounts
CREATE INDEX IF NOT EXISTS idx_email_accounts_client ON email_accounts(client_id);
CREATE INDEX IF NOT EXISTS idx_email_accounts_domain ON email_accounts(domain);
CREATE INDEX IF NOT EXISTS idx_email_accounts_provider ON email_accounts(provider_type);
CREATE INDEX IF NOT EXISTS idx_email_accounts_status ON email_accounts(status);

-- ============================================
-- 2. EMAIL ACCOUNT HEALTH HISTORY (Daily snapshots)
-- ============================================
CREATE TABLE IF NOT EXISTS email_account_health_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email_account_id UUID NOT NULL REFERENCES email_accounts(id) ON DELETE CASCADE,

  -- Snapshot date (one record per account per day)
  snapshot_date DATE NOT NULL DEFAULT CURRENT_DATE,

  -- Status at snapshot time
  status TEXT,
  warmup_reputation INTEGER,
  warmup_emails_sent INTEGER,
  warmup_emails_received INTEGER,

  -- Daily sending metrics
  emails_sent_today INTEGER DEFAULT 0,
  emails_bounced_today INTEGER DEFAULT 0,

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT now(),

  -- One snapshot per account per day
  UNIQUE(email_account_id, snapshot_date)
);

-- Indexes for health history
CREATE INDEX IF NOT EXISTS idx_health_history_date ON email_account_health_history(snapshot_date DESC);
CREATE INDEX IF NOT EXISTS idx_health_history_account ON email_account_health_history(email_account_id, snapshot_date DESC);

-- ============================================
-- 3. DOMAIN HEALTH TABLE (DNS validation cache)
-- ============================================
CREATE TABLE IF NOT EXISTS domain_health (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  domain TEXT NOT NULL UNIQUE,

  -- SPF Record
  has_spf BOOLEAN DEFAULT false,
  spf_record TEXT,
  spf_valid BOOLEAN DEFAULT false,

  -- DKIM Record
  has_dkim BOOLEAN DEFAULT false,
  dkim_selector TEXT, -- e.g., 'google', 'default'
  dkim_record TEXT,
  dkim_valid BOOLEAN DEFAULT false,

  -- DMARC Record
  has_dmarc BOOLEAN DEFAULT false,
  dmarc_record TEXT,
  dmarc_policy TEXT CHECK (dmarc_policy IS NULL OR dmarc_policy IN ('none', 'quarantine', 'reject')),
  dmarc_valid BOOLEAN DEFAULT false,

  -- Overall health score (0-100)
  health_score INTEGER DEFAULT 0,

  -- Timestamps
  last_checked_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Index for domain lookups
CREATE INDEX IF NOT EXISTS idx_domain_health_score ON domain_health(health_score);

-- ============================================
-- 4. TRIGGERS
-- ============================================

-- Updated at trigger for email_accounts
DROP TRIGGER IF EXISTS update_email_accounts_updated_at ON email_accounts;
CREATE TRIGGER update_email_accounts_updated_at
  BEFORE UPDATE ON email_accounts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Updated at trigger for domain_health
DROP TRIGGER IF EXISTS update_domain_health_updated_at ON domain_health;
CREATE TRIGGER update_domain_health_updated_at
  BEFORE UPDATE ON domain_health
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- 5. ROW LEVEL SECURITY
-- ============================================

ALTER TABLE email_accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_account_health_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE domain_health ENABLE ROW LEVEL SECURITY;

-- Admin full access to email_accounts
DROP POLICY IF EXISTS "Admin can manage email_accounts" ON email_accounts;
CREATE POLICY "Admin can manage email_accounts" ON email_accounts
  FOR ALL TO authenticated
  USING (EXISTS (
    SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
  ));

-- Service role full access to email_accounts
DROP POLICY IF EXISTS "Service role can manage email_accounts" ON email_accounts;
CREATE POLICY "Service role can manage email_accounts" ON email_accounts
  FOR ALL TO service_role
  USING (true);

-- Admin full access to health history
DROP POLICY IF EXISTS "Admin can manage health_history" ON email_account_health_history;
CREATE POLICY "Admin can manage health_history" ON email_account_health_history
  FOR ALL TO authenticated
  USING (EXISTS (
    SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
  ));

-- Service role full access to health history
DROP POLICY IF EXISTS "Service role can manage health_history" ON email_account_health_history;
CREATE POLICY "Service role can manage health_history" ON email_account_health_history
  FOR ALL TO service_role
  USING (true);

-- Admin full access to domain health
DROP POLICY IF EXISTS "Admin can manage domain_health" ON domain_health;
CREATE POLICY "Admin can manage domain_health" ON domain_health
  FOR ALL TO authenticated
  USING (EXISTS (
    SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
  ));

-- Service role full access to domain health
DROP POLICY IF EXISTS "Service role can manage domain_health" ON domain_health;
CREATE POLICY "Service role can manage domain_health" ON domain_health
  FOR ALL TO service_role
  USING (true);

-- ============================================
-- 6. HELPFUL VIEWS
-- ============================================

-- View: Email accounts with client info and domain health
CREATE OR REPLACE VIEW email_accounts_with_health AS
SELECT
  ea.id,
  ea.provider_type,
  ea.provider_account_id,
  ea.email,
  ea.client_id,
  ea.first_name,
  ea.last_name,
  ea.domain,
  ea.status,
  ea.error_message,
  ea.warmup_enabled,
  ea.warmup_reputation,
  ea.warmup_emails_sent,
  ea.warmup_emails_received,
  ea.warmup_saved_from_spam,
  ea.daily_limit,
  ea.emails_sent_today,
  ea.last_synced_at,
  ea.created_at,
  ea.updated_at,
  c.name as client_name,
  dh.health_score as domain_health_score,
  dh.has_spf,
  dh.spf_valid,
  dh.has_dkim,
  dh.dkim_valid,
  dh.has_dmarc,
  dh.dmarc_valid,
  dh.dmarc_policy
FROM email_accounts ea
LEFT JOIN clients c ON c.id = ea.client_id
LEFT JOIN domain_health dh ON dh.domain = ea.domain;

-- View: Domain summary with account counts
CREATE OR REPLACE VIEW domain_summary AS
SELECT
  dh.id,
  dh.domain,
  dh.has_spf,
  dh.spf_valid,
  dh.spf_record,
  dh.has_dkim,
  dh.dkim_valid,
  dh.dkim_selector,
  dh.has_dmarc,
  dh.dmarc_valid,
  dh.dmarc_policy,
  dh.dmarc_record,
  dh.health_score,
  dh.last_checked_at,
  dh.created_at,
  dh.updated_at,
  COUNT(ea.id) as account_count,
  COUNT(DISTINCT ea.client_id) as client_count
FROM domain_health dh
LEFT JOIN email_accounts ea ON ea.domain = dh.domain
GROUP BY dh.id;

-- ============================================
-- 7. FUNCTION TO CALCULATE DOMAIN HEALTH SCORE
-- ============================================

CREATE OR REPLACE FUNCTION calculate_domain_health_score(
  p_spf_valid BOOLEAN,
  p_dkim_valid BOOLEAN,
  p_dmarc_valid BOOLEAN,
  p_dmarc_policy TEXT
) RETURNS INTEGER AS $$
BEGIN
  -- Calculate score based on DNS authentication status
  IF p_spf_valid AND p_dkim_valid AND p_dmarc_valid AND p_dmarc_policy IN ('quarantine', 'reject') THEN
    RETURN 100;
  ELSIF p_spf_valid AND p_dkim_valid AND p_dmarc_valid THEN
    RETURN 85;
  ELSIF p_spf_valid AND p_dkim_valid THEN
    RETURN 70;
  ELSIF p_spf_valid OR p_dkim_valid THEN
    RETURN 50;
  ELSE
    RETURN 25;
  END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================
-- DONE! Infrastructure health tables are ready.
-- ============================================
</file>

<file path="supabase/migrations/20260104_add_email_sync_timestamp.sql">
-- Add last_email_sync_at to campaigns table
ALTER TABLE campaigns
ADD COLUMN IF NOT EXISTS last_email_sync_at timestamptz;

COMMENT ON COLUMN campaigns.last_email_sync_at IS 'Timestamp of the last email history sync from provider';
</file>

<file path="supabase/migrations/20260104_add_leads_unique_constraint.sql">
-- Add UNIQUE constraint on (campaign_id, email) for leads table
-- This is required for the upsert logic in sync-positive endpoint to work correctly

-- First, remove any duplicate entries (keep the most recently updated one)
DELETE FROM leads a
USING leads b
WHERE a.campaign_id = b.campaign_id
  AND LOWER(a.email) = LOWER(b.email)
  AND a.updated_at < b.updated_at;

-- Create the unique index (case-insensitive on email)
CREATE UNIQUE INDEX IF NOT EXISTS idx_leads_campaign_email_unique
ON leads (campaign_id, LOWER(email));

-- Add comment
COMMENT ON INDEX idx_leads_campaign_email_unique IS 'Ensures each email can only appear once per campaign (case-insensitive)';
</file>

<file path="supabase/migrations/20260104_fix_positive_leads_logic.sql">
-- Fix for positive leads data corruption
--
-- Issue: The sync-leads endpoint was incorrectly setting is_positive_reply = true
-- based on interestStatus from the Instantly /leads/list API. However, this API
-- does NOT return interest_status for regular leads - it only returns it when
-- filtering by interest_status. This caused ~11,000+ leads to be incorrectly
-- marked as positive.
--
-- Fix applied in code:
-- 1. sync-leads/route.ts: Removed the incorrect positive marking logic
--    Now only marks negative statuses (not_interested) explicitly
-- 2. sync-leads/route.ts: Added reset before fetchPositiveLeads()
--    Resets is_positive_reply=false before fetching and marking actual positives
-- 3. sync-positive/route.ts: Added client-level reset at start
--    Resets ALL is_positive_reply=false for the client before re-syncing
--
-- To fix existing data:
-- Option 1: Click "Sync from Instantly" button on the client dashboard
--           This will reset + re-sync positive leads automatically
--
-- Option 2: Run manual SQL cleanup (uncomment below):

-- Reset all positive leads for a specific client:
-- UPDATE leads
-- SET is_positive_reply = false
-- WHERE client_id = 'YOUR_CLIENT_UUID_HERE'
-- AND is_positive_reply = true;

-- Then run sync-positive via API or UI to re-mark actual positives

-- Count positive leads per client (diagnostic query):
-- SELECT c.name as client_name,
--        COUNT(*) as positive_count
-- FROM leads l
-- JOIN clients c ON l.client_id = c.id
-- WHERE l.is_positive_reply = true
-- GROUP BY c.id, c.name
-- ORDER BY positive_count DESC;

COMMENT ON COLUMN leads.is_positive_reply IS 'True only for leads with positive interest status in Instantly (interested, meeting_booked, meeting_completed, closed). Reset and re-synced via sync-positive endpoint.';
</file>

<file path=".dockerignore">
# Dependencies
node_modules
npm-debug.log

# Next.js build output
.next

# Git
.git
.gitignore

# IDE
.vscode
.idea

# Environment files (these should be passed at runtime)
.env
.env.local
.env.*.local

# Docker
Dockerfile
docker-compose.yml
.dockerignore

# Documentation
*.md
!README.md

# Testing
coverage
.nyc_output
</file>

<file path="Caddyfile">
# Replace with your domain
your-domain.com {
    reverse_proxy app:3000

    # Enable compression
    encode gzip

    # Security headers
    header {
        X-Content-Type-Options nosniff
        X-Frame-Options DENY
        Referrer-Policy strict-origin-when-cross-origin
    }
}

# For local development/testing without a domain
# Uncomment the block below and comment the block above
# :80 {
#     reverse_proxy app:3000
# }
</file>

<file path="check_db.mjs">
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';
dotenv.config({ path: '.env.local' });

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

async function check() {
  // Count total leads
  const { count: totalLeads } = await supabase.from('leads').select('*', { count: 'exact', head: true });

  // Count positive replies
  const { count: positiveReplies } = await supabase.from('leads').select('*', { count: 'exact', head: true }).eq('is_positive_reply', true);

  // Get status breakdown manually
  const statuses = ['contacted', 'replied', 'booked', 'won', 'not_interested'];
  const statusBreakdown = {};
  for (const status of statuses) {
    const { count } = await supabase.from('leads').select('*', { count: 'exact', head: true }).eq('status', status);
    statusBreakdown[status] = count;
  }

  // Count campaigns
  const { count: totalCampaigns } = await supabase.from('campaigns').select('*', { count: 'exact', head: true });

  // Get campaigns with instantly_campaign_id
  const { data: campaigns } = await supabase.from('campaigns').select('id, name, instantly_campaign_id, client_id');

  // Get leads with email_reply_count > 0
  const { count: leadsWithReplies } = await supabase.from('leads').select('*', { count: 'exact', head: true }).gt('email_reply_count', 0);

  console.log('=== Database Stats ===');
  console.log('Total Leads:', totalLeads);
  console.log('Positive Replies (is_positive_reply=true):', positiveReplies);
  console.log('Leads with email_reply_count > 0:', leadsWithReplies);
  console.log('\nStatus Breakdown:');
  console.log(statusBreakdown);
  console.log('\nTotal Campaigns:', totalCampaigns);
  console.log('\nCampaigns:');
  if (campaigns) {
    campaigns.forEach(function(c) {
      console.log('  - ' + c.name + ' (instantly_id: ' + (c.instantly_campaign_id || 'none') + ')');
    });
  }
}

check().catch(console.error);
</file>

<file path="check-positive.mjs">
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';
dotenv.config({ path: '.env.local' });

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

async function check() {
  // Get Almaron client
  const { data: client } = await supabase
    .from('clients')
    .select('id')
    .ilike('name', '%almaron%')
    .single();

  // Get linked campaigns
  const { data: campaigns } = await supabase
    .from('campaigns')
    .select('id, name, instantly_campaign_id')
    .eq('client_id', client.id);

  console.log('Linked campaigns:');
  campaigns.forEach(c => console.log('  -', c.name, '(', c.id, ')'));

  // Get positive leads grouped by campaign
  const { data: leads } = await supabase
    .from('leads')
    .select('campaign_id, campaign_name, status, is_positive_reply')
    .eq('client_id', client.id)
    .eq('is_positive_reply', true);

  console.log('\nPositive leads by campaign_id:');
  const byCampaignId = {};
  leads.forEach(l => {
    const key = l.campaign_id || 'no_campaign_id';
    if (!byCampaignId[key]) byCampaignId[key] = { count: 0, statuses: {} };
    byCampaignId[key].count++;
    byCampaignId[key].statuses[l.status] = (byCampaignId[key].statuses[l.status] || 0) + 1;
  });

  const linkedIds = campaigns.map(c => c.id);

  Object.entries(byCampaignId).forEach(([id, data]) => {
    const campaign = campaigns.find(c => c.id === id);
    const isLinked = linkedIds.includes(id);
    console.log('  Campaign:', campaign ? campaign.name : id, isLinked ? '' : '(NOT LINKED)');
    console.log('    Count:', data.count);
    console.log('    Statuses:', data.statuses);
  });

  console.log('\nTotal positive leads:', leads.length);
}

check();
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}
</file>

<file path="CRON_SETUP.md">
# Cron Job Setup - Analytics Sync

## Overview

The analytics sync should run **once daily** to pull the latest campaign analytics from Instantly and store them in Supabase.

## Endpoint

```
POST /api/admin/analytics/sync
```

This endpoint:
- Fetches all campaign analytics from Instantly API
- Stores/updates them in the `analytics_snapshots` table
- Returns sync status with count of synced campaigns

## Setup Options

### Option 1: Vercel Cron (Recommended for Vercel deployments)

1. Create `vercel.json` in your project root:

```json
{
  "crons": [
    {
      "path": "/api/admin/analytics/sync",
      "schedule": "0 6 * * *"
    }
  ]
}
```

This runs daily at 6:00 AM UTC.

2. Add a cron secret for security. In your `.env`:

```env
CRON_SECRET=your-secure-random-string
```

3. Update the sync route to verify the cron secret (optional but recommended).

### Option 2: External Cron Service

Use services like:
- **cron-job.org** (free)
- **EasyCron**
- **Upstash QStash**

Configure them to call:
```
POST https://your-domain.com/api/admin/analytics/sync
```

Schedule: `0 6 * * *` (daily at 6 AM)

### Option 3: GitHub Actions

Create `.github/workflows/sync-analytics.yml`:

```yaml
name: Sync Analytics Daily

on:
  schedule:
    - cron: '0 6 * * *'  # Daily at 6 AM UTC
  workflow_dispatch:  # Allow manual trigger

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Sync Analytics
        run: |
          curl -X POST ${{ secrets.APP_URL }}/api/admin/analytics/sync \
            -H "Authorization: Bearer ${{ secrets.CRON_SECRET }}"
```

Add secrets in GitHub:
- `APP_URL`: Your deployed app URL
- `CRON_SECRET`: Secret for authentication

### Option 4: Supabase Edge Functions + pg_cron

If using Supabase, you can use pg_cron extension:

```sql
-- Enable pg_cron (requires Supabase Pro plan)
SELECT cron.schedule(
  'sync-instantly-analytics',
  '0 6 * * *',
  $$
  SELECT net.http_post(
    url := 'https://your-domain.com/api/admin/analytics/sync',
    headers := '{"Content-Type": "application/json"}'::jsonb
  );
  $$
);
```

## Manual Sync

You can always trigger a manual sync:

```bash
curl -X POST https://your-domain.com/api/admin/analytics/sync
```

Or from the browser console:
```javascript
fetch('/api/admin/analytics/sync', { method: 'POST' })
  .then(r => r.json())
  .then(console.log)
```

## Monitoring

Check the `analytics_snapshots` table in Supabase to verify syncs are working:

```sql
SELECT snapshot_date, COUNT(*) as campaigns_synced
FROM analytics_snapshots
GROUP BY snapshot_date
ORDER BY snapshot_date DESC
LIMIT 7;
```

## Recommended Schedule

- **Daily sync**: `0 6 * * *` (6 AM UTC) - recommended
- **Twice daily**: `0 6,18 * * *` (6 AM and 6 PM UTC)
- **Hourly** (if needed): `0 * * * *`

Daily sync is usually sufficient since Instantly analytics don't change frequently.
</file>

<file path="docker-compose.yml">
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    restart: unless-stopped
    environment:
      - NEXT_PUBLIC_SUPABASE_URL=${NEXT_PUBLIC_SUPABASE_URL}
      - NEXT_PUBLIC_SUPABASE_ANON_KEY=${NEXT_PUBLIC_SUPABASE_ANON_KEY}
      - SUPABASE_SERVICE_ROLE_KEY=${SUPABASE_SERVICE_ROLE_KEY}
      - INSTANTLY_WEBHOOK_SECRET=${INSTANTLY_WEBHOOK_SECRET}
    networks:
      - web

  caddy:
    image: caddy:2-alpine
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
      - caddy_config:/config
    networks:
      - web
    depends_on:
      - app

networks:
  web:
    driver: bridge

volumes:
  caddy_data:
  caddy_config:
</file>

<file path="Dockerfile">
# Stage 1: Dependencies
FROM node:20-alpine AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json package-lock.json* ./
RUN npm ci

# Stage 2: Builder
FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Set environment variables for build
ENV NEXT_TELEMETRY_DISABLED=1
ENV NODE_ENV=production

RUN npm run build

# Stage 3: Runner
FROM node:20-alpine AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

CMD ["node", "server.js"]
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="refresh-status.mjs">
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';
dotenv.config({ path: '.env.local' });

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

const INSTANTLY_API_KEY = process.env.INSTANTLY_API_KEY;
const BASE_URL = 'https://api.instantly.ai/api/v2';

async function fetchLeadsBatch(campaignId, skip, limit) {
  const response = await fetch(BASE_URL + '/leads/list', {
    method: 'POST',
    headers: {
      'Authorization': 'Bearer ' + INSTANTLY_API_KEY,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      campaign_id: campaignId,
      limit,
      skip,
    }),
  });

  if (!response.ok) {
    throw new Error('Failed to fetch leads: ' + response.status);
  }

  const data = await response.json();
  return data.items || data || [];
}

async function refreshStatus() {
  console.log('Starting status refresh...\n');

  // Get all campaigns with instantly_campaign_id
  const { data: campaigns, error } = await supabase
    .from('campaigns')
    .select('id, name, instantly_campaign_id')
    .not('instantly_campaign_id', 'is', null);

  if (error) {
    console.error('Failed to fetch campaigns:', error.message);
    return;
  }

  console.log('Found ' + campaigns.length + ' campaigns to process\n');

  let totalUpdated = 0;
  let totalNotFound = 0;

  for (const campaign of campaigns) {
    console.log('Processing: ' + campaign.name);
    console.log('  Instantly ID: ' + campaign.instantly_campaign_id);

    let skip = 0;
    const limit = 100;
    let campaignUpdated = 0;
    let campaignNotFound = 0;
    let batchNum = 0;

    while (true) {
      batchNum++;
      process.stdout.write('  Batch ' + batchNum + ': fetching...');

      let leads;
      try {
        leads = await fetchLeadsBatch(campaign.instantly_campaign_id, skip, limit);
      } catch (err) {
        console.log(' ERROR: ' + err.message);
        break;
      }

      if (leads.length === 0) {
        console.log(' no more leads');
        break;
      }

      console.log(' got ' + leads.length + ' leads, updating...');

      // Process leads in this batch
      for (const lead of leads) {
        // Check if lead has replied
        const hasReplied = (lead.email_reply_count || 0) > 0;
        // Positive reply = manually tagged as interested/booked/etc (NOT just any reply)
        const positiveStatuses = ['interested', 'meeting_booked', 'meeting_completed', 'closed'];
        const isPositiveReply = positiveStatuses.includes(lead.interest_status || '');

        // Determine status: contacted  replied  meeting  closed_won / closed_lost
        let newStatus = null;
        if (lead.interest_status === 'closed') {
          newStatus = 'closed_won';
        } else if (lead.interest_status === 'not_interested' || lead.interest_status === 'wrong_person') {
          newStatus = 'closed_lost';
        } else if (lead.interest_status === 'meeting_booked' || lead.interest_status === 'meeting_completed') {
          newStatus = 'meeting';
        } else if (hasReplied || lead.interest_status === 'interested') {
          newStatus = 'replied';
        }

        // Update in database
        const updateData = {
          is_positive_reply: isPositiveReply,
          email_reply_count: lead.email_reply_count || 0,
          has_replied: hasReplied,
        };

        // Only add status if we have a new one and it's an upgrade
        if (newStatus) {
          updateData.status = newStatus;
        }

        const { data: result, error: updateError } = await supabase
          .from('leads')
          .update(updateData)
          .eq('campaign_id', campaign.id)
          .eq('email', lead.email)
          .select('id');

        if (result && result.length > 0) {
          campaignUpdated++;
        } else {
          campaignNotFound++;
        }
      }

      skip += limit;

      // Small delay to avoid rate limits
      await new Promise(r => setTimeout(r, 200));

      if (leads.length < limit) {
        break;
      }
    }

    console.log('  Campaign done: updated=' + campaignUpdated + ', not_found=' + campaignNotFound);
    totalUpdated += campaignUpdated;
    totalNotFound += campaignNotFound;
    console.log('');
  }

  console.log('=== COMPLETE ===');
  console.log('Total updated:', totalUpdated);
  console.log('Total not found in DB:', totalNotFound);
}

refreshStatus().catch(console.error);
</file>

<file path="supabase-add-icp.sql">
-- ============================================
-- BLUEREACH AGENCY PORTAL - ADD ICP COLUMN
-- ============================================
-- Run this in Supabase SQL Editor
-- This adds the ICP (Ideal Customer Profile) column to clients table
-- ============================================

-- Add ICP column to clients table
ALTER TABLE clients
ADD COLUMN IF NOT EXISTS icp text;

-- Also ensure all Client Intelligence columns exist (in case they're missing)
ALTER TABLE clients
ADD COLUMN IF NOT EXISTS product_service text,
ADD COLUMN IF NOT EXISTS acv numeric,
ADD COLUMN IF NOT EXISTS tcv numeric,
ADD COLUMN IF NOT EXISTS verticals text[],
ADD COLUMN IF NOT EXISTS tam integer,
ADD COLUMN IF NOT EXISTS target_daily_emails integer;

-- Add a comment to document the ICP field
COMMENT ON COLUMN clients.icp IS 'Ideal Customer Profile - describes the target customer characteristics';
COMMENT ON COLUMN clients.product_service IS 'The offer - product or service description';
COMMENT ON COLUMN clients.tam IS 'Total Addressable Market - number of potential leads';
</file>

<file path="supabase-analytics.sql">
-- ============================================
-- ANALYTICS STORAGE TABLE
-- Store Instantly analytics in Supabase
-- Run this in your Supabase SQL Editor
-- ============================================

-- Create analytics_snapshots table to store daily analytics
CREATE TABLE IF NOT EXISTS analytics_snapshots (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  campaign_id uuid REFERENCES campaigns(id) ON DELETE CASCADE,
  instantly_campaign_id text NOT NULL,
  snapshot_date date NOT NULL DEFAULT CURRENT_DATE,

  -- Lead counts
  leads_count integer DEFAULT 0,
  contacted_count integer DEFAULT 0,
  completed_count integer DEFAULT 0,
  new_leads_contacted_count integer DEFAULT 0,

  -- Email metrics
  emails_sent_count integer DEFAULT 0,
  open_count integer DEFAULT 0,
  open_count_unique integer DEFAULT 0,
  reply_count integer DEFAULT 0,
  reply_count_unique integer DEFAULT 0,
  link_click_count integer DEFAULT 0,
  link_click_count_unique integer DEFAULT 0,
  bounced_count integer DEFAULT 0,
  unsubscribed_count integer DEFAULT 0,

  -- Opportunities
  total_opportunities integer DEFAULT 0,
  total_opportunity_value decimal(12,2) DEFAULT 0,
  total_interested integer DEFAULT 0,
  total_meeting_booked integer DEFAULT 0,
  total_meeting_completed integer DEFAULT 0,
  total_closed integer DEFAULT 0,

  -- Metadata
  raw_data jsonb,
  created_at timestamp with time zone DEFAULT now(),

  -- Unique constraint: one snapshot per campaign per day
  CONSTRAINT unique_campaign_date UNIQUE (instantly_campaign_id, snapshot_date)
);

-- Create index for faster lookups
CREATE INDEX IF NOT EXISTS idx_analytics_snapshots_campaign ON analytics_snapshots(campaign_id);
CREATE INDEX IF NOT EXISTS idx_analytics_snapshots_instantly_id ON analytics_snapshots(instantly_campaign_id);
CREATE INDEX IF NOT EXISTS idx_analytics_snapshots_date ON analytics_snapshots(snapshot_date);

-- Create a view for the latest analytics per campaign
CREATE OR REPLACE VIEW latest_campaign_analytics AS
SELECT DISTINCT ON (instantly_campaign_id)
  id,
  campaign_id,
  instantly_campaign_id,
  snapshot_date,
  leads_count,
  contacted_count,
  emails_sent_count,
  open_count,
  open_count_unique,
  reply_count,
  reply_count_unique,
  link_click_count,
  link_click_count_unique,
  bounced_count,
  unsubscribed_count,
  total_opportunities,
  total_opportunity_value,
  -- Calculate rates
  CASE WHEN emails_sent_count > 0
    THEN ROUND((open_count_unique::decimal / emails_sent_count * 100), 2)
    ELSE 0
  END as open_rate,
  CASE WHEN emails_sent_count > 0
    THEN ROUND((link_click_count_unique::decimal / emails_sent_count * 100), 2)
    ELSE 0
  END as click_rate,
  CASE WHEN emails_sent_count > 0
    THEN ROUND((reply_count_unique::decimal / emails_sent_count * 100), 2)
    ELSE 0
  END as reply_rate,
  created_at
FROM analytics_snapshots
ORDER BY instantly_campaign_id, snapshot_date DESC;

-- Create aggregated overview view
CREATE OR REPLACE VIEW analytics_overview AS
SELECT
  COUNT(DISTINCT instantly_campaign_id) as total_campaigns,
  SUM(leads_count) as total_leads,
  SUM(emails_sent_count) as total_emails_sent,
  SUM(open_count_unique) as total_opened,
  SUM(link_click_count_unique) as total_clicked,
  SUM(reply_count_unique) as total_replies,
  SUM(bounced_count) as total_bounced,
  SUM(total_opportunities) as total_opportunities,
  SUM(total_opportunity_value) as total_opportunity_value,
  CASE WHEN SUM(emails_sent_count) > 0
    THEN ROUND((SUM(open_count_unique)::decimal / SUM(emails_sent_count) * 100), 2)
    ELSE 0
  END as overall_open_rate,
  CASE WHEN SUM(emails_sent_count) > 0
    THEN ROUND((SUM(link_click_count_unique)::decimal / SUM(emails_sent_count) * 100), 2)
    ELSE 0
  END as overall_click_rate,
  CASE WHEN SUM(emails_sent_count) > 0
    THEN ROUND((SUM(reply_count_unique)::decimal / SUM(emails_sent_count) * 100), 2)
    ELSE 0
  END as overall_reply_rate,
  MAX(snapshot_date) as last_updated
FROM latest_campaign_analytics;

-- Enable RLS
ALTER TABLE analytics_snapshots ENABLE ROW LEVEL SECURITY;

-- Policy: Admins can do everything
CREATE POLICY "Admins can manage analytics_snapshots"
  ON analytics_snapshots
  FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- Function to upsert analytics snapshot
CREATE OR REPLACE FUNCTION upsert_analytics_snapshot(
  p_instantly_campaign_id text,
  p_campaign_id uuid,
  p_data jsonb
) RETURNS uuid AS $$
DECLARE
  v_id uuid;
BEGIN
  INSERT INTO analytics_snapshots (
    campaign_id,
    instantly_campaign_id,
    snapshot_date,
    leads_count,
    contacted_count,
    completed_count,
    new_leads_contacted_count,
    emails_sent_count,
    open_count,
    open_count_unique,
    reply_count,
    reply_count_unique,
    link_click_count,
    link_click_count_unique,
    bounced_count,
    unsubscribed_count,
    total_opportunities,
    total_opportunity_value,
    total_interested,
    total_meeting_booked,
    total_meeting_completed,
    total_closed,
    raw_data
  ) VALUES (
    p_campaign_id,
    p_instantly_campaign_id,
    CURRENT_DATE,
    COALESCE((p_data->>'leads_count')::integer, 0),
    COALESCE((p_data->>'contacted_count')::integer, 0),
    COALESCE((p_data->>'completed_count')::integer, 0),
    COALESCE((p_data->>'new_leads_contacted_count')::integer, 0),
    COALESCE((p_data->>'emails_sent_count')::integer, 0),
    COALESCE((p_data->>'open_count')::integer, 0),
    COALESCE((p_data->>'open_count_unique')::integer, 0),
    COALESCE((p_data->>'reply_count')::integer, 0),
    COALESCE((p_data->>'reply_count_unique')::integer, 0),
    COALESCE((p_data->>'link_click_count')::integer, 0),
    COALESCE((p_data->>'link_click_count_unique')::integer, 0),
    COALESCE((p_data->>'bounced_count')::integer, 0),
    COALESCE((p_data->>'unsubscribed_count')::integer, 0),
    COALESCE((p_data->>'total_opportunities')::integer, 0),
    COALESCE((p_data->>'total_opportunity_value')::decimal, 0),
    COALESCE((p_data->>'total_interested')::integer, 0),
    COALESCE((p_data->>'total_meeting_booked')::integer, 0),
    COALESCE((p_data->>'total_meeting_completed')::integer, 0),
    COALESCE((p_data->>'total_closed')::integer, 0),
    p_data
  )
  ON CONFLICT (instantly_campaign_id, snapshot_date)
  DO UPDATE SET
    leads_count = EXCLUDED.leads_count,
    contacted_count = EXCLUDED.contacted_count,
    completed_count = EXCLUDED.completed_count,
    new_leads_contacted_count = EXCLUDED.new_leads_contacted_count,
    emails_sent_count = EXCLUDED.emails_sent_count,
    open_count = EXCLUDED.open_count,
    open_count_unique = EXCLUDED.open_count_unique,
    reply_count = EXCLUDED.reply_count,
    reply_count_unique = EXCLUDED.reply_count_unique,
    link_click_count = EXCLUDED.link_click_count,
    link_click_count_unique = EXCLUDED.link_click_count_unique,
    bounced_count = EXCLUDED.bounced_count,
    unsubscribed_count = EXCLUDED.unsubscribed_count,
    total_opportunities = EXCLUDED.total_opportunities,
    total_opportunity_value = EXCLUDED.total_opportunity_value,
    total_interested = EXCLUDED.total_interested,
    total_meeting_booked = EXCLUDED.total_meeting_booked,
    total_meeting_completed = EXCLUDED.total_meeting_completed,
    total_closed = EXCLUDED.total_closed,
    raw_data = EXCLUDED.raw_data
  RETURNING id INTO v_id;

  RETURN v_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
</file>

<file path="supabase-preserve-leads.sql">
-- ============================================
-- PRESERVE LEADS MIGRATION
-- Keeps leads when clients/campaigns are deleted
-- Run this in Supabase SQL Editor
-- ============================================

-- 1. Drop existing views that depend on leads table
DROP VIEW IF EXISTS positive_replies CASCADE;
DROP VIEW IF EXISTS campaign_performance CASCADE;
DROP VIEW IF EXISTS all_leads_with_history CASCADE;

-- 2. Add client_id and client_name directly to leads (denormalized for preservation)
ALTER TABLE leads
ADD COLUMN IF NOT EXISTS client_id uuid REFERENCES clients(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS client_name text,
ADD COLUMN IF NOT EXISTS campaign_name text;

-- 3. Change campaign foreign key from CASCADE to SET NULL
-- First, drop the existing constraint
ALTER TABLE leads
DROP CONSTRAINT IF EXISTS leads_campaign_id_fkey;

-- Re-add with SET NULL instead of CASCADE
ALTER TABLE leads
ADD CONSTRAINT leads_campaign_id_fkey
FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE SET NULL;

-- 4. Backfill client_id, client_name, and campaign_name for existing leads
UPDATE leads l
SET
  client_id = c.client_id,
  client_name = cl.name,
  campaign_name = c.name
FROM campaigns c
JOIN clients cl ON c.client_id = cl.id
WHERE l.campaign_id = c.id
  AND (l.client_id IS NULL OR l.client_name IS NULL OR l.campaign_name IS NULL);

-- 5. Create index for client_id lookups
CREATE INDEX IF NOT EXISTS idx_leads_client_id ON leads(client_id);

-- 6. Create a trigger to auto-populate client info when lead is created/updated
CREATE OR REPLACE FUNCTION populate_lead_client_info()
RETURNS TRIGGER AS $$
BEGIN
  -- Only update if campaign_id is set and client fields are empty
  IF NEW.campaign_id IS NOT NULL AND (NEW.client_id IS NULL OR NEW.client_name IS NULL OR NEW.campaign_name IS NULL) THEN
    SELECT c.client_id, cl.name, c.name
    INTO NEW.client_id, NEW.client_name, NEW.campaign_name
    FROM campaigns c
    JOIN clients cl ON c.client_id = cl.id
    WHERE c.id = NEW.campaign_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_populate_lead_client_info ON leads;
CREATE TRIGGER trigger_populate_lead_client_info
  BEFORE INSERT OR UPDATE ON leads
  FOR EACH ROW
  EXECUTE FUNCTION populate_lead_client_info();

-- 7. Recreate the positive_replies view with denormalized fields
CREATE OR REPLACE VIEW positive_replies AS
SELECT
  l.id,
  l.email,
  l.first_name,
  l.last_name,
  l.company_name,
  l.phone,
  l.status,
  l.is_positive_reply,
  l.notes,
  l.metadata,
  l.created_at,
  l.updated_at,
  l.campaign_id,
  l.client_id,
  COALESCE(l.campaign_name, c.name) as campaign_name,
  COALESCE(l.client_name, cl.name) as client_name,
  (SELECT COUNT(*) FROM activities a WHERE a.lead_id = l.id) as activity_count,
  (SELECT MAX(created_at) FROM activities a WHERE a.lead_id = l.id) as last_activity_at
FROM leads l
LEFT JOIN campaigns c ON l.campaign_id = c.id
LEFT JOIN clients cl ON COALESCE(l.client_id, c.client_id) = cl.id
WHERE l.is_positive_reply = true
ORDER BY l.updated_at DESC;

-- 8. Recreate campaign_performance view
CREATE OR REPLACE VIEW campaign_performance AS
SELECT
  c.id as campaign_id,
  c.name as campaign_name,
  cl.name as client_name,
  COUNT(DISTINCT l.id) as total_leads,
  COUNT(DISTINCT l.id) FILTER (WHERE l.status = 'opened') as opened_count,
  COUNT(DISTINCT l.id) FILTER (WHERE l.status = 'clicked') as clicked_count,
  COUNT(DISTINCT l.id) FILTER (WHERE l.status = 'replied') as replied_count,
  COUNT(DISTINCT l.id) FILTER (WHERE l.is_positive_reply = true) as positive_reply_count,
  COUNT(DISTINCT l.id) FILTER (WHERE l.status = 'booked') as booked_count,
  COUNT(DISTINCT l.id) FILTER (WHERE l.status = 'won') as won_count,
  COALESCE(SUM(l.deal_value) FILTER (WHERE l.status = 'won'), 0) as total_deal_value
FROM campaigns c
JOIN clients cl ON c.client_id = cl.id
LEFT JOIN leads l ON l.campaign_id = c.id
GROUP BY c.id, c.name, cl.name;

-- 9. Create a view to see all leads with their client info (even deleted clients)
CREATE OR REPLACE VIEW all_leads_with_history AS
SELECT
  l.id,
  l.email,
  l.first_name,
  l.last_name,
  l.company_name,
  l.phone,
  l.status,
  l.is_positive_reply,
  l.notes,
  l.instantly_lead_id,
  l.metadata,
  l.created_at,
  l.updated_at,
  -- Client info (preserved even after deletion)
  l.client_id,
  COALESCE(l.client_name, cl.name, 'Deleted Client') as client_name,
  -- Campaign info (preserved even after deletion)
  l.campaign_id,
  COALESCE(l.campaign_name, c.name, 'Deleted Campaign') as campaign_name,
  -- Current status
  CASE
    WHEN l.campaign_id IS NULL AND l.client_id IS NULL THEN 'orphaned'
    WHEN c.id IS NULL THEN 'campaign_deleted'
    WHEN cl.id IS NULL THEN 'client_deleted'
    ELSE 'active'
  END as record_status
FROM leads l
LEFT JOIN campaigns c ON l.campaign_id = c.id
LEFT JOIN clients cl ON COALESCE(l.client_id, c.client_id) = cl.id
ORDER BY l.created_at DESC;

-- ============================================
-- DONE! Leads will now be preserved.
-- ============================================

-- Summary:
-- - Dropped and recreated views
-- - Added client_id, client_name, campaign_name columns to leads
-- - Changed campaign_id foreign key from CASCADE to SET NULL
-- - Backfilled existing leads with client/campaign info
-- - Created trigger to auto-populate on insert/update
-- - Recreated views to use denormalized data
</file>

<file path="supabase-schema-v2.sql">
-- ============================================
-- BLUEREACH AGENCY PORTAL - SCHEMA V2
-- ============================================
-- Run this in Supabase SQL Editor
-- This adds new tables and columns to existing schema
-- ============================================

-- ============================================
-- 1. MODIFY LEADS TABLE - Add new columns
-- ============================================

-- Add new columns to leads table
ALTER TABLE leads
ADD COLUMN IF NOT EXISTS last_name text,
ADD COLUMN IF NOT EXISTS company_name text,
ADD COLUMN IF NOT EXISTS phone text,
ADD COLUMN IF NOT EXISTS linkedin_url text,
ADD COLUMN IF NOT EXISTS is_positive_reply boolean DEFAULT false,
ADD COLUMN IF NOT EXISTS deal_value numeric,
ADD COLUMN IF NOT EXISTS next_action text,
ADD COLUMN IF NOT EXISTS next_action_date date,
ADD COLUMN IF NOT EXISTS metadata jsonb DEFAULT '{}',
ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();

-- Update status check constraint to include more statuses
ALTER TABLE leads DROP CONSTRAINT IF EXISTS leads_status_check;
ALTER TABLE leads ADD CONSTRAINT leads_status_check
  CHECK (status IN ('contacted', 'opened', 'clicked', 'replied', 'booked', 'won', 'lost', 'not_interested'));

-- Index for positive replies (frequently filtered)
CREATE INDEX IF NOT EXISTS idx_leads_positive_reply ON leads(is_positive_reply) WHERE is_positive_reply = true;

-- Index for next action date (for follow-up reminders)
CREATE INDEX IF NOT EXISTS idx_leads_next_action_date ON leads(next_action_date) WHERE next_action_date IS NOT NULL;


-- ============================================
-- 2. CREATE ACTIVITIES TABLE
-- ============================================

CREATE TABLE IF NOT EXISTS activities (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  lead_id uuid NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
  user_id uuid REFERENCES profiles(id) ON DELETE SET NULL,

  -- Activity details
  type text NOT NULL CHECK (type IN ('call', 'meeting', 'email', 'note', 'status_change', 'task', 'other')),
  title text,
  description text,

  -- Scheduling
  scheduled_at timestamptz,
  completed_at timestamptz,

  -- Metadata
  metadata jsonb DEFAULT '{}',
  created_at timestamptz DEFAULT now()
);

-- Indexes for activities
CREATE INDEX IF NOT EXISTS idx_activities_lead ON activities(lead_id);
CREATE INDEX IF NOT EXISTS idx_activities_user ON activities(user_id);
CREATE INDEX IF NOT EXISTS idx_activities_type ON activities(type);
CREATE INDEX IF NOT EXISTS idx_activities_scheduled ON activities(scheduled_at) WHERE scheduled_at IS NOT NULL;

-- RLS for activities
ALTER TABLE activities ENABLE ROW LEVEL SECURITY;

-- Admins can do everything
CREATE POLICY "Admins can manage all activities" ON activities
  FOR ALL
  TO authenticated
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
  );

-- Users can view activities for leads they have access to
CREATE POLICY "Users can view activities for accessible leads" ON activities
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM leads l
      JOIN campaigns c ON l.campaign_id = c.id
      JOIN client_users cu ON c.client_id = cu.client_id
      WHERE l.id = activities.lead_id AND cu.user_id = auth.uid()
    )
  );

-- Users can create activities for leads they have access to
CREATE POLICY "Users can create activities for accessible leads" ON activities
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM leads l
      JOIN campaigns c ON l.campaign_id = c.id
      JOIN client_users cu ON c.client_id = cu.client_id
      WHERE l.id = activities.lead_id AND cu.user_id = auth.uid()
    )
  );


-- ============================================
-- 3. CREATE EMAIL_EVENTS TABLE
-- ============================================

CREATE TABLE IF NOT EXISTS email_events (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  lead_id uuid REFERENCES leads(id) ON DELETE CASCADE,
  campaign_id uuid REFERENCES campaigns(id) ON DELETE CASCADE,

  -- Event details
  event_type text NOT NULL CHECK (event_type IN ('sent', 'opened', 'clicked', 'replied', 'bounced', 'unsubscribed', 'spam_complaint')),

  -- From Instantly
  instantly_event_id text,
  email_subject text,
  link_clicked text,  -- URL if event_type = 'clicked'

  -- Timing
  timestamp timestamptz DEFAULT now(),

  -- Extra data from webhook
  metadata jsonb DEFAULT '{}'
);

-- Indexes for email_events
CREATE INDEX IF NOT EXISTS idx_email_events_lead ON email_events(lead_id);
CREATE INDEX IF NOT EXISTS idx_email_events_campaign ON email_events(campaign_id);
CREATE INDEX IF NOT EXISTS idx_email_events_type ON email_events(event_type);
CREATE INDEX IF NOT EXISTS idx_email_events_timestamp ON email_events(timestamp DESC);

-- Unique constraint to prevent duplicate events
CREATE UNIQUE INDEX IF NOT EXISTS idx_email_events_unique
  ON email_events(lead_id, event_type, timestamp)
  WHERE instantly_event_id IS NULL;

CREATE UNIQUE INDEX IF NOT EXISTS idx_email_events_instantly_unique
  ON email_events(instantly_event_id)
  WHERE instantly_event_id IS NOT NULL;

-- RLS for email_events
ALTER TABLE email_events ENABLE ROW LEVEL SECURITY;

-- Admins can do everything
CREATE POLICY "Admins can manage all email_events" ON email_events
  FOR ALL
  TO authenticated
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
  );

-- Users can view email_events for their campaigns
CREATE POLICY "Users can view email_events for accessible campaigns" ON email_events
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM campaigns c
      JOIN client_users cu ON c.client_id = cu.client_id
      WHERE c.id = email_events.campaign_id AND cu.user_id = auth.uid()
    )
  );

-- Service role can insert (for webhooks)
CREATE POLICY "Service role can insert email_events" ON email_events
  FOR INSERT
  TO service_role
  WITH CHECK (true);


-- ============================================
-- 4. CREATE TEAM_MEMBERS TABLE
-- ============================================

CREATE TABLE IF NOT EXISTS team_members (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id uuid NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,

  -- Role within this client
  role text NOT NULL DEFAULT 'viewer' CHECK (role IN ('owner', 'manager', 'member', 'viewer')),

  -- Invitation tracking
  invited_by uuid REFERENCES profiles(id) ON DELETE SET NULL,
  invited_at timestamptz DEFAULT now(),
  accepted_at timestamptz,

  -- Unique constraint: one role per user per client
  UNIQUE(client_id, user_id)
);

-- Indexes for team_members
CREATE INDEX IF NOT EXISTS idx_team_members_client ON team_members(client_id);
CREATE INDEX IF NOT EXISTS idx_team_members_user ON team_members(user_id);
CREATE INDEX IF NOT EXISTS idx_team_members_role ON team_members(role);

-- RLS for team_members
ALTER TABLE team_members ENABLE ROW LEVEL SECURITY;

-- Admins can do everything
CREATE POLICY "Admins can manage all team_members" ON team_members
  FOR ALL
  TO authenticated
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
  );

-- Users can view their own team memberships
CREATE POLICY "Users can view own team memberships" ON team_members
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

-- Owners and managers can view team members for their clients
CREATE POLICY "Owners can view team for their clients" ON team_members
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM team_members tm
      WHERE tm.client_id = team_members.client_id
        AND tm.user_id = auth.uid()
        AND tm.role IN ('owner', 'manager')
    )
  );

-- Owners can manage team members
CREATE POLICY "Owners can manage team for their clients" ON team_members
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM team_members tm
      WHERE tm.client_id = team_members.client_id
        AND tm.user_id = auth.uid()
        AND tm.role = 'owner'
    )
  );


-- ============================================
-- 5. CREATE AUDIT_LOGS TABLE
-- ============================================

CREATE TABLE IF NOT EXISTS audit_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Who made the change
  user_id uuid REFERENCES profiles(id) ON DELETE SET NULL,
  user_email text,  -- Denormalized for when user is deleted

  -- What was changed
  action text NOT NULL CHECK (action IN ('create', 'update', 'delete')),
  table_name text NOT NULL,
  record_id uuid NOT NULL,

  -- The actual changes
  old_data jsonb,  -- Previous values (for update/delete)
  new_data jsonb,  -- New values (for create/update)
  changed_fields text[],  -- List of fields that changed

  -- Context
  ip_address inet,
  user_agent text,

  -- Timestamp
  created_at timestamptz DEFAULT now()
);

-- Indexes for audit_logs (optimized for common queries)
CREATE INDEX IF NOT EXISTS idx_audit_logs_record ON audit_logs(table_name, record_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_user ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_table ON audit_logs(table_name);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created ON audit_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);

-- RLS for audit_logs
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- Only admins can view audit logs
CREATE POLICY "Admins can view all audit_logs" ON audit_logs
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
  );

-- Service role can insert (for automatic logging)
CREATE POLICY "Service role can insert audit_logs" ON audit_logs
  FOR INSERT
  TO service_role
  WITH CHECK (true);

-- Prevent updates and deletes on audit logs (immutable)
-- No UPDATE or DELETE policies = cannot modify audit logs


-- ============================================
-- 6. HELPER FUNCTION: Log audit entry
-- ============================================

CREATE OR REPLACE FUNCTION log_audit(
  p_user_id uuid,
  p_action text,
  p_table_name text,
  p_record_id uuid,
  p_old_data jsonb DEFAULT NULL,
  p_new_data jsonb DEFAULT NULL
) RETURNS uuid AS $$
DECLARE
  v_user_email text;
  v_changed_fields text[];
  v_audit_id uuid;
BEGIN
  -- Get user email
  SELECT email INTO v_user_email FROM profiles WHERE id = p_user_id;

  -- Calculate changed fields for updates
  IF p_action = 'update' AND p_old_data IS NOT NULL AND p_new_data IS NOT NULL THEN
    SELECT array_agg(key) INTO v_changed_fields
    FROM (
      SELECT key FROM jsonb_each(p_new_data)
      EXCEPT
      SELECT key FROM jsonb_each(p_old_data) WHERE p_old_data->key = p_new_data->key
    ) changed;
  END IF;

  -- Insert audit log
  INSERT INTO audit_logs (user_id, user_email, action, table_name, record_id, old_data, new_data, changed_fields)
  VALUES (p_user_id, v_user_email, p_action, p_table_name, p_record_id, p_old_data, p_new_data, v_changed_fields)
  RETURNING id INTO v_audit_id;

  RETURN v_audit_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ============================================
-- 7. UPDATE CLIENT_USERS TABLE (if exists)
-- ============================================

-- Add role column to existing client_users if it doesn't have one
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'client_users') THEN
    ALTER TABLE client_users ADD COLUMN IF NOT EXISTS role text DEFAULT 'viewer';
  END IF;
END $$;


-- ============================================
-- 8. CREATE VIEWS FOR COMMON QUERIES
-- ============================================

-- View: Positive replies with lead details
CREATE OR REPLACE VIEW positive_replies AS
SELECT
  l.*,
  c.name as campaign_name,
  cl.name as client_name,
  (SELECT COUNT(*) FROM activities a WHERE a.lead_id = l.id) as activity_count,
  (SELECT MAX(created_at) FROM activities a WHERE a.lead_id = l.id) as last_activity_at
FROM leads l
JOIN campaigns c ON l.campaign_id = c.id
JOIN clients cl ON c.client_id = cl.id
WHERE l.is_positive_reply = true
ORDER BY l.updated_at DESC;

-- View: Campaign performance summary
CREATE OR REPLACE VIEW campaign_performance AS
SELECT
  c.id as campaign_id,
  c.name as campaign_name,
  cl.name as client_name,
  COUNT(DISTINCT l.id) as total_leads,
  COUNT(DISTINCT l.id) FILTER (WHERE l.status = 'opened') as opened_count,
  COUNT(DISTINCT l.id) FILTER (WHERE l.status = 'clicked') as clicked_count,
  COUNT(DISTINCT l.id) FILTER (WHERE l.status = 'replied') as replied_count,
  COUNT(DISTINCT l.id) FILTER (WHERE l.is_positive_reply = true) as positive_reply_count,
  COUNT(DISTINCT l.id) FILTER (WHERE l.status = 'booked') as booked_count,
  COUNT(DISTINCT l.id) FILTER (WHERE l.status = 'won') as won_count,
  COALESCE(SUM(l.deal_value) FILTER (WHERE l.status = 'won'), 0) as total_deal_value
FROM campaigns c
JOIN clients cl ON c.client_id = cl.id
LEFT JOIN leads l ON l.campaign_id = c.id
GROUP BY c.id, c.name, cl.name;


-- ============================================
-- DONE! Schema V2 is ready.
-- ============================================

-- Summary of changes:
-- 1. leads: Added last_name, company_name, phone, linkedin_url,
--           is_positive_reply, deal_value, next_action, next_action_date,
--           metadata, created_at
-- 2. activities: NEW - Track calls, meetings, notes per lead
-- 3. email_events: NEW - Store Instantly webhook events
-- 4. team_members: NEW - Multi-user access with roles
-- 5. audit_logs: NEW - Track who changed what
-- 6. Views: positive_replies, campaign_performance
</file>

<file path="supabase-settings.sql">
-- ============================================
-- SETTINGS TABLE
-- ============================================
-- Run this in Supabase SQL Editor
-- Stores app settings like API keys
-- ============================================

CREATE TABLE IF NOT EXISTS settings (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  key text UNIQUE NOT NULL,
  value text,
  is_encrypted boolean DEFAULT false,
  updated_at timestamptz DEFAULT now(),
  updated_by uuid REFERENCES profiles(id) ON DELETE SET NULL
);

-- Index for fast key lookup
CREATE INDEX IF NOT EXISTS idx_settings_key ON settings(key);

-- RLS
ALTER TABLE settings ENABLE ROW LEVEL SECURITY;

-- Only admins can view and manage settings
CREATE POLICY "Admins can manage settings" ON settings
  FOR ALL
  TO authenticated
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
  );

-- Insert default settings (empty values)
INSERT INTO settings (key, value, is_encrypted) VALUES
  ('instantly_api_key', '', true),
  ('instantly_webhook_secret', '', true)
ON CONFLICT (key) DO NOTHING;

-- Function to update setting
CREATE OR REPLACE FUNCTION update_setting(p_key text, p_value text, p_user_id uuid DEFAULT NULL)
RETURNS void AS $$
BEGIN
  UPDATE settings
  SET value = p_value,
      updated_at = now(),
      updated_by = p_user_id
  WHERE key = p_key;

  IF NOT FOUND THEN
    INSERT INTO settings (key, value, updated_by)
    VALUES (p_key, p_value, p_user_id);
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get setting
CREATE OR REPLACE FUNCTION get_setting(p_key text)
RETURNS text AS $$
DECLARE
  v_value text;
BEGIN
  SELECT value INTO v_value FROM settings WHERE key = p_key;
  RETURN v_value;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
</file>

<file path="sync-payload.mjs">
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';
dotenv.config({ path: '.env.local' });

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

const INSTANTLY_API_KEY = process.env.INSTANTLY_API_KEY;
const BASE_URL = 'https://api.instantly.ai/api/v2';

async function fetchLeadsBatch(campaignId, skip, limit) {
  const response = await fetch(BASE_URL + '/leads/list', {
    method: 'POST',
    headers: {
      'Authorization': 'Bearer ' + INSTANTLY_API_KEY,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      campaign_id: campaignId,
      limit,
      skip,
    }),
  });

  if (!response.ok) {
    throw new Error('Failed to fetch leads: ' + response.status);
  }

  const data = await response.json();
  return data.items || data || [];
}

async function syncPayloadData() {
  console.log('Starting payload sync...\n');

  // Get all campaigns with instantly_campaign_id
  const { data: campaigns, error } = await supabase
    .from('campaigns')
    .select('id, name, instantly_campaign_id')
    .not('instantly_campaign_id', 'is', null);

  if (error) {
    console.error('Failed to fetch campaigns:', error.message);
    return;
  }

  console.log('Found ' + campaigns.length + ' campaigns to process\n');

  let totalUpdated = 0;
  let totalNotFound = 0;

  for (const campaign of campaigns) {
    console.log('Processing: ' + campaign.name);
    console.log('  Instantly ID: ' + campaign.instantly_campaign_id);

    let skip = 0;
    const limit = 100;
    let campaignUpdated = 0;
    let campaignNotFound = 0;
    let batchNum = 0;

    while (true) {
      batchNum++;
      process.stdout.write('  Batch ' + batchNum + ': fetching...');

      let leads;
      try {
        leads = await fetchLeadsBatch(campaign.instantly_campaign_id, skip, limit);
      } catch (err) {
        console.log(' ERROR: ' + err.message);
        break;
      }

      if (leads.length === 0) {
        console.log(' no more leads');
        break;
      }

      console.log(' got ' + leads.length + ' leads, updating payloads...');

      // Process leads in this batch
      for (const lead of leads) {
        if (!lead.payload || Object.keys(lead.payload).length === 0) {
          continue; // Skip leads without payload
        }

        // Update the metadata.lead_data with the payload + company_domain
        const updateData = {
          metadata: { lead_data: lead.payload }
        };

        // Also update company_domain if available
        if (lead.company_domain) {
          updateData.company_domain = lead.company_domain;
        }

        const { data: result, error: updateError } = await supabase
          .from('leads')
          .update(updateData)
          .eq('campaign_id', campaign.id)
          .eq('email', lead.email)
          .select('id');

        if (result && result.length > 0) {
          campaignUpdated++;
        } else {
          campaignNotFound++;
        }
      }

      skip += limit;

      // Small delay to avoid rate limits
      await new Promise(r => setTimeout(r, 200));

      if (leads.length < limit) {
        break;
      }
    }

    console.log('  Campaign done: updated=' + campaignUpdated + ', not_found=' + campaignNotFound);
    totalUpdated += campaignUpdated;
    totalNotFound += campaignNotFound;
    console.log('');
  }

  console.log('=== COMPLETE ===');
  console.log('Total updated:', totalUpdated);
  console.log('Total not found in DB:', totalNotFound);
}

syncPayloadData().catch(console.error);
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/admin/clients/add-client-dialog.tsx">
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { createClient } from "@/lib/supabase/client";
import { Plus, X, Copy, Check, Mail } from "lucide-react";

interface Invite {
  name: string;
  email: string;
}

interface InviteResult {
  email: string;
  success: boolean;
  loginUrl?: string;
  error?: string;
  emailSent?: boolean;
}

export function AddClientDialog() {
  const [open, setOpen] = useState(false);
  const [step, setStep] = useState<"form" | "results">("form");
  const [name, setName] = useState("");
  const [invites, setInvites] = useState<Invite[]>([{ name: "", email: "" }]);
  const [, startTransition] = useTransition();
  const [isCreating, setIsCreating] = useState(false);
  const [inviteResults, setInviteResults] = useState<InviteResult[]>([]);
  const [copiedIndex, setCopiedIndex] = useState<number | null>(null);
  const router = useRouter();
  const supabase = createClient();

  const addInvite = () => {
    setInvites([...invites, { name: "", email: "" }]);
  };

  const removeInvite = (index: number) => {
    if (invites.length > 1) {
      setInvites(invites.filter((_, i) => i !== index));
    }
  };

  const updateInvite = (index: number, field: "name" | "email", value: string) => {
    const newInvites = [...invites];
    newInvites[index][field] = value;
    setInvites(newInvites);
  };

  const copyToClipboard = async (url: string, index: number) => {
    try {
      await navigator.clipboard.writeText(url);
      setCopiedIndex(index);
      setTimeout(() => setCopiedIndex(null), 2000);
    } catch (err) {
      console.error("Failed to copy:", err);
    }
  };

  const resetForm = () => {
    setName("");
    setInvites([{ name: "", email: "" }]);
    setInviteResults([]);
    setStep("form");
  };

  const handleClose = () => {
    setOpen(false);
    resetForm();
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!name.trim()) return;

    setIsCreating(true);

    try {
      // Create the client
      const { data: newClient, error } = await supabase
        .from("clients")
        .insert({ name: name.trim() })
        .select("id")
        .single();

      if (error || !newClient) {
        console.error("Error creating client:", error);
        setIsCreating(false);
        return;
      }

      // Send invitations for valid entries
      const validInvites = invites.filter((inv) => inv.email.trim());
      const results: InviteResult[] = [];

      for (const invite of validInvites) {
        try {
          const res = await fetch(`/api/clients/${newClient.id}/invitations`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              email: invite.email.trim(),
              name: invite.name.trim(),
            }),
          });

          const data = await res.json();

          if (res.ok) {
            results.push({
              email: invite.email,
              success: true,
              loginUrl: data.loginUrl,
              emailSent: data.emailSent,
            });
          } else {
            results.push({
              email: invite.email,
              success: false,
              error: data.error || "Failed to send invitation",
            });
          }
        } catch (err) {
          results.push({
            email: invite.email,
            success: false,
            error: "Network error",
          });
        }
      }

      setInviteResults(results);

      if (results.length > 0) {
        setStep("results");
      } else {
        handleClose();
      }

      startTransition(() => {
        router.refresh();
      });
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={(isOpen) => {
      if (!isOpen) handleClose();
      else setOpen(true);
    }}>
      <DialogTrigger asChild>
        <Button>Add Client</Button>
      </DialogTrigger>
      <DialogContent className="max-w-lg">
        {step === "form" ? (
          <form onSubmit={handleSubmit}>
            <DialogHeader>
              <DialogTitle>Add New Client</DialogTitle>
              <DialogDescription>
                Create a new client and invite team members to access their dashboard.
              </DialogDescription>
            </DialogHeader>

            <div className="py-4 space-y-4">
              {/* Client Name */}
              <div>
                <Label htmlFor="name">Client Name</Label>
                <Input
                  id="name"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="Acme Corporation"
                  className="mt-1"
                />
              </div>

              {/* Invitations */}
              <div>
                <Label className="flex items-center gap-2">
                  <Mail className="h-4 w-4" />
                  Invite Team Members (optional)
                </Label>
                <p className="text-xs text-muted-foreground mt-1 mb-3">
                  Add people who should have access to this client&apos;s dashboard.
                </p>

                <div className="space-y-3">
                  {invites.map((invite, index) => (
                    <div key={index} className="flex gap-2">
                      <Input
                        value={invite.name}
                        onChange={(e) => updateInvite(index, "name", e.target.value)}
                        placeholder="Name"
                        className="flex-1"
                      />
                      <Input
                        type="email"
                        value={invite.email}
                        onChange={(e) => updateInvite(index, "email", e.target.value)}
                        placeholder="email@example.com"
                        className="flex-1"
                      />
                      {invites.length > 1 && (
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          onClick={() => removeInvite(index)}
                          className="shrink-0"
                        >
                          <X className="h-4 w-4" />
                        </Button>
                      )}
                    </div>
                  ))}
                </div>

                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={addInvite}
                  className="mt-2"
                >
                  <Plus className="h-4 w-4 mr-1" />
                  Add Another
                </Button>
              </div>
            </div>

            <DialogFooter>
              <Button type="button" variant="outline" onClick={handleClose}>
                Cancel
              </Button>
              <Button type="submit" disabled={isCreating || !name.trim()}>
                {isCreating ? "Creating..." : "Create Client"}
              </Button>
            </DialogFooter>
          </form>
        ) : (
          <>
            <DialogHeader>
              <DialogTitle>Client Created Successfully</DialogTitle>
              <DialogDescription>
                Share these invitation links with your team members so they can access the dashboard.
              </DialogDescription>
            </DialogHeader>

            <div className="py-4 space-y-3">
              {inviteResults.map((result, index) => (
                <div
                  key={index}
                  className={`p-3 rounded-lg border ${
                    result.success
                      ? "bg-green-50 dark:bg-green-950 border-green-200 dark:border-green-800"
                      : "bg-red-50 dark:bg-red-950 border-red-200 dark:border-red-800"
                  }`}
                >
                  <div className="flex items-center justify-between mb-2">
                    <span className="font-medium text-sm">{result.email}</span>
                    {result.success ? (
                      <span className="text-xs text-green-600 dark:text-green-400">
                        {result.emailSent ? "Email sent" : "Invited (share link)"}
                      </span>
                    ) : (
                      <span className="text-xs text-red-600 dark:text-red-400">{result.error}</span>
                    )}
                  </div>
                  {result.success && result.loginUrl && !result.emailSent && (
                    <div className="flex items-center gap-2">
                      <code className="flex-1 text-xs bg-white dark:bg-gray-900 px-2 py-1 rounded border truncate">
                        {result.loginUrl}
                      </code>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => copyToClipboard(result.loginUrl!, index)}
                        className="shrink-0"
                      >
                        {copiedIndex === index ? (
                          <Check className="h-4 w-4 text-green-500" />
                        ) : (
                          <Copy className="h-4 w-4" />
                        )}
                      </Button>
                    </div>
                  )}
                  {result.success && result.emailSent && (
                    <p className="text-xs text-muted-foreground">
                      The invitation email has been sent. They can click the link in the email to access the dashboard.
                    </p>
                  )}
                </div>
              ))}
            </div>

            <DialogFooter>
              <Button onClick={handleClose}>Done</Button>
            </DialogFooter>
          </>
        )}
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/app/admin/instantly/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Checkbox } from "@/components/ui/checkbox";
import Link from "next/link";
import { RefreshCw, Mail, Users, BarChart3, AlertCircle, CheckCircle2, ChevronDown, ChevronRight } from "lucide-react";

interface InstantlyStatus {
  configured: boolean;
  connected: boolean;
  error?: string;
}

interface Campaign {
  id: string;
  name: string;
  instantly_campaign_id: string | null;
  is_active: boolean;
}

interface Client {
  id: string;
  name: string;
  campaigns: Campaign[];
}

interface SyncProgress {
  clientId: string;
  clientName: string;
  status: "pending" | "syncing" | "done" | "error";
  result?: {
    campaigns: { imported: number; updated: number; failed: number };
    leads: { imported: number; updated: number; failed: number } | null;
  };
  error?: string;
}

export default function InstantlyDashboard() {
  const [status, setStatus] = useState<InstantlyStatus | null>(null);
  const [loading, setLoading] = useState(true);
  const [clients, setClients] = useState<Client[]>([]);
  const [loadingClients, setLoadingClients] = useState(false);
  const [selectedClients, setSelectedClients] = useState<Set<string>>(new Set());
  const [expandedClients, setExpandedClients] = useState<Set<string>>(new Set());
  const [syncing, setSyncing] = useState(false);
  const [syncProgress, setSyncProgress] = useState<SyncProgress[]>([]);

  const fetchStatus = async () => {
    setLoading(true);
    try {
      const response = await fetch("/api/instantly/status");
      const data = await response.json();

      setStatus({
        configured: data.configured,
        connected: data.connected,
        error: data.error,
      });
    } catch (error) {
      setStatus({
        configured: false,
        connected: false,
        error: error instanceof Error ? error.message : "Failed to connect",
      });
    } finally {
      setLoading(false);
    }
  };

  const fetchClients = async () => {
    setLoadingClients(true);
    try {
      const response = await fetch("/api/clients");
      const data = await response.json();
      if (data.clients) {
        setClients(data.clients);
      }
    } catch (error) {
      console.error("Failed to fetch clients:", error);
    } finally {
      setLoadingClients(false);
    }
  };

  useEffect(() => {
    fetchStatus();
    fetchClients();
  }, []);

  const toggleClientSelection = (clientId: string) => {
    const newSelected = new Set(selectedClients);
    if (newSelected.has(clientId)) {
      newSelected.delete(clientId);
    } else {
      newSelected.add(clientId);
    }
    setSelectedClients(newSelected);
  };

  const toggleAllClients = () => {
    if (selectedClients.size === clients.length) {
      setSelectedClients(new Set());
    } else {
      setSelectedClients(new Set(clients.map(c => c.id)));
    }
  };

  const toggleClientExpand = (clientId: string) => {
    const newExpanded = new Set(expandedClients);
    if (newExpanded.has(clientId)) {
      newExpanded.delete(clientId);
    } else {
      newExpanded.add(clientId);
    }
    setExpandedClients(newExpanded);
  };

  const handleSync = async () => {
    if (selectedClients.size === 0) return;

    setSyncing(true);
    const clientsToSync = clients.filter(c => selectedClients.has(c.id));

    // Initialize progress
    const initialProgress: SyncProgress[] = clientsToSync.map(c => ({
      clientId: c.id,
      clientName: c.name,
      status: "pending",
    }));
    setSyncProgress(initialProgress);

    // Sync each client sequentially
    for (let i = 0; i < clientsToSync.length; i++) {
      const client = clientsToSync[i];

      // Update status to syncing
      setSyncProgress(prev => prev.map(p =>
        p.clientId === client.id ? { ...p, status: "syncing" } : p
      ));

      try {
        const response = await fetch("/api/instantly/sync", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ client_id: client.id, sync_leads: true }),
        });
        const data = await response.json();

        if (data.success) {
          setSyncProgress(prev => prev.map(p =>
            p.clientId === client.id ? {
              ...p,
              status: "done",
              result: {
                campaigns: data.campaigns,
                leads: data.leads,
              }
            } : p
          ));
        } else {
          setSyncProgress(prev => prev.map(p =>
            p.clientId === client.id ? {
              ...p,
              status: "error",
              error: data.error,
            } : p
          ));
        }
      } catch (error) {
        setSyncProgress(prev => prev.map(p =>
          p.clientId === client.id ? {
            ...p,
            status: "error",
            error: error instanceof Error ? error.message : "Unknown error",
          } : p
        ));
      }
    }

    setSyncing(false);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <RefreshCw className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold">Instantly Integration</h1>
          <p className="text-gray-500">Manage your Instantly email campaigns and accounts</p>
        </div>
        <Button onClick={fetchStatus} variant="outline" size="sm">
          <RefreshCw className="h-4 w-4 mr-2" />
          Refresh
        </Button>
      </div>

      {/* Connection Status */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            API Connection
            {status?.connected ? (
              <Badge variant="default" className="bg-green-500">
                <CheckCircle2 className="h-3 w-3 mr-1" />
                Connected
              </Badge>
            ) : status?.configured ? (
              <Badge variant="destructive">
                <AlertCircle className="h-3 w-3 mr-1" />
                Connection Error
              </Badge>
            ) : (
              <Badge variant="secondary">
                <AlertCircle className="h-3 w-3 mr-1" />
                Not Configured
              </Badge>
            )}
          </CardTitle>
        </CardHeader>
        <CardContent>
          {status?.connected ? (
            <p className="text-sm text-gray-600">
              Your Instantly API is connected and ready to use.
            </p>
          ) : status?.configured ? (
            <div className="space-y-2">
              <p className="text-sm text-red-600">
                Error: {status.error}
              </p>
            </div>
          ) : (
            <div className="space-y-2">
              <p className="text-sm text-gray-600">
                Add your Instantly API key to connect.
              </p>
              <code className="block bg-gray-100 p-2 rounded text-sm">
                INSTANTLY_API_KEY=your_api_key_here
              </code>
            </div>
          )}
        </CardContent>
      </Card>

      {status?.connected && (
        <>
          {/* Quick Stats */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <Link href="/admin/instantly/campaigns">
              <Card className="hover:shadow-md transition-shadow cursor-pointer">
                <CardHeader className="flex flex-row items-center justify-between pb-2">
                  <CardTitle className="text-sm font-medium text-gray-500">
                    Campaigns
                  </CardTitle>
                  <Mail className="h-4 w-4 text-gray-400" />
                </CardHeader>
                <CardContent>
                  <div className="text-2xl font-bold">View All</div>
                  <p className="text-xs text-gray-500">Manage campaigns</p>
                </CardContent>
              </Card>
            </Link>

            <Link href="/admin/instantly/accounts">
              <Card className="hover:shadow-md transition-shadow cursor-pointer">
                <CardHeader className="flex flex-row items-center justify-between pb-2">
                  <CardTitle className="text-sm font-medium text-gray-500">
                    Email Accounts
                  </CardTitle>
                  <Users className="h-4 w-4 text-gray-400" />
                </CardHeader>
                <CardContent>
                  <div className="text-2xl font-bold">View All</div>
                  <p className="text-xs text-gray-500">Manage accounts & warmup</p>
                </CardContent>
              </Card>
            </Link>

            <Link href="/admin/instantly/analytics">
              <Card className="hover:shadow-md transition-shadow cursor-pointer">
                <CardHeader className="flex flex-row items-center justify-between pb-2">
                  <CardTitle className="text-sm font-medium text-gray-500">
                    Analytics
                  </CardTitle>
                  <BarChart3 className="h-4 w-4 text-gray-400" />
                </CardHeader>
                <CardContent>
                  <div className="text-2xl font-bold">View</div>
                  <p className="text-xs text-gray-500">Campaign performance</p>
                </CardContent>
              </Card>
            </Link>
          </div>

          {/* Sync Section */}
          <Card>
            <CardHeader>
              <CardTitle>Sync from Instantly</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <p className="text-sm text-gray-500">
                Select clients to sync their campaigns and leads from Instantly. This will import new campaigns and update existing leads with the latest status.
              </p>

              {loadingClients ? (
                <div className="flex items-center justify-center py-4">
                  <RefreshCw className="h-5 w-5 animate-spin text-gray-400" />
                </div>
              ) : clients.length === 0 ? (
                <p className="text-sm text-gray-500 py-4">No clients found. Create a client first.</p>
              ) : (
                <div className="border rounded-lg divide-y">
                  {/* Select All Header */}
                  <div className="flex items-center gap-3 p-3 bg-gray-50 dark:bg-gray-800">
                    <Checkbox
                      checked={selectedClients.size === clients.length && clients.length > 0}
                      onCheckedChange={toggleAllClients}
                    />
                    <span className="font-medium text-sm">
                      Select All ({clients.length} clients)
                    </span>
                  </div>

                  {/* Client List */}
                  {clients.map(client => (
                    <div key={client.id} className="divide-y">
                      <div className="flex items-center gap-3 p-3 hover:bg-gray-50 dark:hover:bg-gray-800">
                        <Checkbox
                          checked={selectedClients.has(client.id)}
                          onCheckedChange={() => toggleClientSelection(client.id)}
                        />
                        <button
                          onClick={() => toggleClientExpand(client.id)}
                          className="flex items-center gap-2 flex-1 text-left"
                        >
                          {expandedClients.has(client.id) ? (
                            <ChevronDown className="h-4 w-4 text-gray-400" />
                          ) : (
                            <ChevronRight className="h-4 w-4 text-gray-400" />
                          )}
                          <span className="font-medium">{client.name}</span>
                          <Badge variant="secondary" className="ml-2">
                            {client.campaigns.length} campaigns
                          </Badge>
                        </button>

                        {/* Show sync progress for this client */}
                        {syncProgress.find(p => p.clientId === client.id) && (
                          <div className="flex items-center gap-2">
                            {syncProgress.find(p => p.clientId === client.id)?.status === "pending" && (
                              <Badge variant="secondary">Pending</Badge>
                            )}
                            {syncProgress.find(p => p.clientId === client.id)?.status === "syncing" && (
                              <Badge className="bg-blue-500">
                                <RefreshCw className="h-3 w-3 mr-1 animate-spin" />
                                Syncing
                              </Badge>
                            )}
                            {syncProgress.find(p => p.clientId === client.id)?.status === "done" && (
                              <Badge className="bg-green-500">
                                <CheckCircle2 className="h-3 w-3 mr-1" />
                                Done
                              </Badge>
                            )}
                            {syncProgress.find(p => p.clientId === client.id)?.status === "error" && (
                              <Badge variant="destructive">
                                <AlertCircle className="h-3 w-3 mr-1" />
                                Error
                              </Badge>
                            )}
                          </div>
                        )}
                      </div>

                      {/* Expanded Campaign List */}
                      {expandedClients.has(client.id) && client.campaigns.length > 0 && (
                        <div className="bg-gray-50 dark:bg-gray-800/50 px-10 py-2">
                          <ul className="space-y-1 text-sm">
                            {client.campaigns.map(campaign => (
                              <li key={campaign.id} className="flex items-center gap-2">
                                <Mail className="h-3 w-3 text-gray-400" />
                                <span>{campaign.name}</span>
                                {campaign.is_active && (
                                  <Badge variant="outline" className="text-xs">Active</Badge>
                                )}
                                {campaign.instantly_campaign_id && (
                                  <Badge variant="secondary" className="text-xs">Linked</Badge>
                                )}
                              </li>
                            ))}
                          </ul>
                        </div>
                      )}

                      {/* Show sync results if done */}
                      {syncProgress.find(p => p.clientId === client.id)?.status === "done" && (
                        <div className="bg-green-50 dark:bg-green-900/20 px-10 py-2 text-sm">
                          {(() => {
                            const result = syncProgress.find(p => p.clientId === client.id)?.result;
                            if (!result) return null;
                            return (
                              <div className="space-y-1">
                                <p>
                                  Campaigns: {result.campaigns.imported} imported, {result.campaigns.updated} updated
                                  {result.campaigns.failed > 0 && `, ${result.campaigns.failed} failed`}
                                </p>
                                {result.leads && (
                                  <p>
                                    Leads: {result.leads.imported} imported, {result.leads.updated} updated
                                    {result.leads.failed > 0 && `, ${result.leads.failed} failed`}
                                  </p>
                                )}
                              </div>
                            );
                          })()}
                        </div>
                      )}

                      {/* Show error if failed */}
                      {syncProgress.find(p => p.clientId === client.id)?.status === "error" && (
                        <div className="bg-red-50 dark:bg-red-900/20 px-10 py-2 text-sm text-red-600">
                          {syncProgress.find(p => p.clientId === client.id)?.error}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}

              <div className="flex justify-end pt-2">
                <Button
                  onClick={handleSync}
                  disabled={syncing || selectedClients.size === 0}
                  size="lg"
                >
                  {syncing ? (
                    <>
                      <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                      Syncing {selectedClients.size} client{selectedClients.size !== 1 ? "s" : ""}...
                    </>
                  ) : (
                    <>
                      <RefreshCw className="h-4 w-4 mr-2" />
                      Sync {selectedClients.size > 0 ? `${selectedClients.size} client${selectedClients.size !== 1 ? "s" : ""}` : "Selected"}
                    </>
                  )}
                </Button>
              </div>
            </CardContent>
          </Card>
        </>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/leads/page.tsx">
import { createClient } from "@/lib/supabase/server";
import { AdminLeadsView } from "./admin-leads-view";

interface PageProps {
  searchParams: Promise<{
    status?: string;
    positive?: string;
    client?: string;
    page?: string;
  }>;
}

const PAGE_SIZE = 100;

export default async function AdminLeadsPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const supabase = await createClient();

  const page = parseInt(params.page || "1", 10);
  const offset = (page - 1) * PAGE_SIZE;

  // Build query with server-side filters
  let query = supabase
    .from("leads")
    .select("*, client_id, client_name, campaign_name, campaigns(name, client_id, clients(name))", { count: "exact" });

  // Apply filters
  if (params.client && params.client !== "all") {
    query = query.eq("client_id", params.client);
  }

  if (params.status && params.status !== "all") {
    query = query.eq("status", params.status);
  }

  if (params.positive === "true") {
    query = query.eq("is_positive_reply", true);
  }

  // Apply ordering and pagination
  const { data: leads, count } = await query
    .order("updated_at", { ascending: false })
    .range(offset, offset + PAGE_SIZE - 1);

  // Get all clients for filtering
  const { data: clients } = await supabase
    .from("clients")
    .select("id, name")
    .order("name");

  // Get total counts for export options
  const { count: totalLeads } = await supabase
    .from("leads")
    .select("*", { count: "exact", head: true });

  const { count: positiveCount } = await supabase
    .from("leads")
    .select("*", { count: "exact", head: true })
    .eq("is_positive_reply", true);

  const { count: repliedCount } = await supabase
    .from("leads")
    .select("*", { count: "exact", head: true })
    .eq("status", "replied");

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl font-bold">All Leads</h1>
        <p className="text-muted-foreground mt-1">
          Manage and track all leads across your campaigns
        </p>
      </div>

      <AdminLeadsView
        leads={leads || []}
        clients={clients || []}
        totalCount={count || 0}
        totalLeads={totalLeads || 0}
        positiveCount={positiveCount || 0}
        repliedCount={repliedCount || 0}
        currentPage={page}
        pageSize={PAGE_SIZE}
        initialStatus={params.status}
        initialClient={params.client}
        initialPositive={params.positive === "true"}
      />
    </div>
  );
}
</file>

<file path="src/app/admin/subscriptions/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  ArrowLeft,
  CreditCard,
  Plus,
  ExternalLink,
  Eye,
  EyeOff,
  Copy,
  Check,
  Pencil,
  Trash2,
  AlertCircle,
  Loader2,
} from "lucide-react";
import Link from "next/link";
import type { Subscription, BillingCycle } from "@/types/database";

const BILLING_CYCLES: { value: BillingCycle; label: string }[] = [
  { value: "monthly", label: "Monthly" },
  { value: "yearly", label: "Yearly" },
  { value: "quarterly", label: "Quarterly" },
  { value: "weekly", label: "Weekly" },
  { value: "custom", label: "Custom" },
];

const CATEGORIES = [
  "Email Outreach",
  "Lead Generation",
  "Data Enrichment",
  "CRM",
  "Analytics",
  "Infrastructure",
  "Other",
];

function formatCurrency(amount: number): string {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount);
}

function formatDate(date: string | null): string {
  if (!date) return "-";
  return new Date(date).toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
}

function isRenewingSoon(date: string | null): boolean {
  if (!date) return false;
  const renewalDate = new Date(date);
  const today = new Date();
  const diffDays = Math.ceil((renewalDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
  return diffDays <= 7 && diffDays >= 0;
}

function getCycleMultiplier(cycle: BillingCycle): number {
  switch (cycle) {
    case "yearly": return 1 / 12;
    case "quarterly": return 1 / 3;
    case "weekly": return 4.33;
    case "monthly":
    case "custom":
    default: return 1;
  }
}

export default function SubscriptionsPage() {
  const [subscriptions, setSubscriptions] = useState<Subscription[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Dialog states
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editingSubscription, setEditingSubscription] = useState<Subscription | null>(null);
  const [isSaving, setIsSaving] = useState(false);

  // Form state
  const [formData, setFormData] = useState({
    name: "",
    url: "",
    username: "",
    password: "",
    cost: "",
    billing_cycle: "monthly" as BillingCycle,
    renewal_date: "",
    credits_balance: "",
    credits_limit: "",
    category: "",
    notes: "",
  });

  // UI states
  const [visiblePasswords, setVisiblePasswords] = useState<Set<string>>(new Set());
  const [copiedId, setCopiedId] = useState<string | null>(null);
  const [deleteConfirmId, setDeleteConfirmId] = useState<string | null>(null);

  useEffect(() => {
    fetchSubscriptions();
  }, []);

  async function fetchSubscriptions() {
    try {
      setLoading(true);
      const res = await fetch("/api/admin/subscriptions");
      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.error || "Failed to fetch subscriptions");
      }

      setSubscriptions(data.subscriptions);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to fetch subscriptions");
    } finally {
      setLoading(false);
    }
  }

  function resetForm() {
    setFormData({
      name: "",
      url: "",
      username: "",
      password: "",
      cost: "",
      billing_cycle: "monthly",
      renewal_date: "",
      credits_balance: "",
      credits_limit: "",
      category: "",
      notes: "",
    });
    setEditingSubscription(null);
  }

  function openAddDialog() {
    resetForm();
    setDialogOpen(true);
  }

  function openEditDialog(subscription: Subscription) {
    setEditingSubscription(subscription);
    setFormData({
      name: subscription.name,
      url: subscription.url || "",
      username: subscription.username || "",
      password: subscription.password || "",
      cost: subscription.cost.toString(),
      billing_cycle: subscription.billing_cycle,
      renewal_date: subscription.renewal_date || "",
      credits_balance: subscription.credits_balance.toString(),
      credits_limit: subscription.credits_limit.toString(),
      category: subscription.category || "",
      notes: subscription.notes || "",
    });
    setDialogOpen(true);
  }

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!formData.name.trim()) return;

    setIsSaving(true);
    try {
      const url = editingSubscription
        ? `/api/admin/subscriptions/${editingSubscription.id}`
        : "/api/admin/subscriptions";

      const res = await fetch(url, {
        method: editingSubscription ? "PUT" : "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to save subscription");
      }

      await fetchSubscriptions();
      setDialogOpen(false);
      resetForm();
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to save subscription");
    } finally {
      setIsSaving(false);
    }
  }

  async function handleDelete(id: string) {
    try {
      const res = await fetch(`/api/admin/subscriptions/${id}`, {
        method: "DELETE",
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to delete subscription");
      }

      await fetchSubscriptions();
      setDeleteConfirmId(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to delete subscription");
    }
  }

  function togglePasswordVisibility(id: string) {
    setVisiblePasswords((prev) => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  }

  async function copyToClipboard(text: string, id: string) {
    try {
      await navigator.clipboard.writeText(text);
      setCopiedId(id);
      setTimeout(() => setCopiedId(null), 2000);
    } catch (err) {
      console.error("Failed to copy:", err);
    }
  }

  // Calculate totals
  const totalMonthly = subscriptions.reduce((sum, sub) => {
    return sum + sub.cost * getCycleMultiplier(sub.billing_cycle);
  }, 0);

  const totalCredits = subscriptions.reduce((sum, sub) => sum + sub.credits_balance, 0);
  const totalCreditsLimit = subscriptions.reduce((sum, sub) => sum + sub.credits_limit, 0);

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-start justify-between">
        <div>
          <Link
            href="/admin"
            className="text-sm text-muted-foreground hover:text-foreground flex items-center gap-1 mb-2"
          >
            <ArrowLeft className="h-4 w-4" />
            Back to Command Center
          </Link>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <CreditCard className="h-6 w-6" />
            Subscriptions
          </h1>
          <p className="text-muted-foreground">
            Track your agency SaaS tools, costs, and credits
          </p>
        </div>
        <Button onClick={openAddDialog}>
          <Plus className="h-4 w-4 mr-2" />
          Add Subscription
        </Button>
      </div>

      {/* Error Message */}
      {error && (
        <div className="bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 rounded-lg p-4 flex items-center gap-2 text-red-700 dark:text-red-400">
          <AlertCircle className="h-5 w-5" />
          {error}
          <Button
            variant="ghost"
            size="sm"
            className="ml-auto"
            onClick={() => setError(null)}
          >
            Dismiss
          </Button>
        </div>
      )}

      {/* Main Table */}
      <Card>
        <CardContent className="p-0">
          {loading ? (
            <div className="flex items-center justify-center py-12">
              <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          ) : subscriptions.length === 0 ? (
            <div className="text-center py-12">
              <CreditCard className="h-12 w-12 mx-auto text-muted-foreground opacity-50" />
              <h3 className="mt-4 text-lg font-medium">No subscriptions yet</h3>
              <p className="text-muted-foreground mt-1">
                Add your first subscription to start tracking expenses
              </p>
              <Button className="mt-4" onClick={openAddDialog}>
                <Plus className="h-4 w-4 mr-2" />
                Add Subscription
              </Button>
            </div>
          ) : (
            <div className="overflow-x-auto">
              <Table>
                <TableHeader>
                  <TableRow className="bg-muted/50">
                    <TableHead className="font-semibold">Tool</TableHead>
                    <TableHead className="font-semibold">Category</TableHead>
                    <TableHead className="font-semibold text-right">Cost</TableHead>
                    <TableHead className="font-semibold">Cycle</TableHead>
                    <TableHead className="font-semibold">Renews</TableHead>
                    <TableHead className="font-semibold">Credits</TableHead>
                    <TableHead className="font-semibold">Login</TableHead>
                    <TableHead className="font-semibold w-[100px]">Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {subscriptions.map((sub) => {
                    const creditsPercent = sub.credits_limit > 0
                      ? (sub.credits_balance / sub.credits_limit) * 100
                      : 0;
                    const isLowCredits = creditsPercent < 20 && sub.credits_limit > 0;
                    const renewingSoon = isRenewingSoon(sub.renewal_date);

                    return (
                      <TableRow key={sub.id} className="group">
                        <TableCell className="font-medium">
                          <div className="flex items-center gap-2">
                            {sub.name}
                            {sub.url && (
                              <a
                                href={sub.url}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="text-muted-foreground hover:text-foreground"
                              >
                                <ExternalLink className="h-3.5 w-3.5" />
                              </a>
                            )}
                          </div>
                          {sub.notes && (
                            <p className="text-xs text-muted-foreground truncate max-w-[200px]">
                              {sub.notes}
                            </p>
                          )}
                        </TableCell>
                        <TableCell>
                          {sub.category ? (
                            <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300">
                              {sub.category}
                            </span>
                          ) : (
                            <span className="text-muted-foreground">-</span>
                          )}
                        </TableCell>
                        <TableCell className="text-right font-mono">
                          {formatCurrency(sub.cost)}
                        </TableCell>
                        <TableCell className="capitalize">{sub.billing_cycle}</TableCell>
                        <TableCell>
                          <span className={renewingSoon ? "text-amber-600 dark:text-amber-400 font-medium" : ""}>
                            {formatDate(sub.renewal_date)}
                            {renewingSoon && " (soon)"}
                          </span>
                        </TableCell>
                        <TableCell>
                          {sub.credits_limit > 0 ? (
                            <div className="space-y-1">
                              <div className="flex items-center gap-2 text-sm">
                                <span className={isLowCredits ? "text-red-600 dark:text-red-400 font-medium" : ""}>
                                  {sub.credits_balance.toLocaleString()}
                                </span>
                                <span className="text-muted-foreground">/</span>
                                <span className="text-muted-foreground">
                                  {sub.credits_limit.toLocaleString()}
                                </span>
                              </div>
                              <div className="w-24 h-1.5 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                                <div
                                  className={`h-full rounded-full transition-all ${
                                    isLowCredits
                                      ? "bg-red-500"
                                      : creditsPercent < 50
                                      ? "bg-amber-500"
                                      : "bg-green-500"
                                  }`}
                                  style={{ width: `${Math.min(creditsPercent, 100)}%` }}
                                />
                              </div>
                            </div>
                          ) : (
                            <span className="text-muted-foreground">-</span>
                          )}
                        </TableCell>
                        <TableCell>
                          {sub.username ? (
                            <div className="flex items-center gap-1">
                              <span className="text-xs text-muted-foreground truncate max-w-[80px]">
                                {sub.username}
                              </span>
                              {sub.password && (
                                <>
                                  <button
                                    onClick={() => togglePasswordVisibility(sub.id)}
                                    className="p-1 hover:bg-gray-100 dark:hover:bg-gray-800 rounded"
                                  >
                                    {visiblePasswords.has(sub.id) ? (
                                      <EyeOff className="h-3.5 w-3.5 text-muted-foreground" />
                                    ) : (
                                      <Eye className="h-3.5 w-3.5 text-muted-foreground" />
                                    )}
                                  </button>
                                  <button
                                    onClick={() => copyToClipboard(sub.password!, `pwd-${sub.id}`)}
                                    className="p-1 hover:bg-gray-100 dark:hover:bg-gray-800 rounded"
                                  >
                                    {copiedId === `pwd-${sub.id}` ? (
                                      <Check className="h-3.5 w-3.5 text-green-500" />
                                    ) : (
                                      <Copy className="h-3.5 w-3.5 text-muted-foreground" />
                                    )}
                                  </button>
                                </>
                              )}
                            </div>
                          ) : (
                            <span className="text-muted-foreground">-</span>
                          )}
                          {visiblePasswords.has(sub.id) && sub.password && (
                            <div className="text-xs font-mono bg-gray-100 dark:bg-gray-800 px-1.5 py-0.5 rounded mt-1">
                              {sub.password}
                            </div>
                          )}
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                            <Button
                              variant="ghost"
                              size="icon"
                              className="h-8 w-8"
                              onClick={() => openEditDialog(sub)}
                            >
                              <Pencil className="h-4 w-4" />
                            </Button>
                            {deleteConfirmId === sub.id ? (
                              <Button
                                variant="destructive"
                                size="sm"
                                className="h-8"
                                onClick={() => handleDelete(sub.id)}
                              >
                                Confirm
                              </Button>
                            ) : (
                              <Button
                                variant="ghost"
                                size="icon"
                                className="h-8 w-8 text-red-500 hover:text-red-600 hover:bg-red-50 dark:hover:bg-red-950"
                                onClick={() => setDeleteConfirmId(sub.id)}
                              >
                                <Trash2 className="h-4 w-4" />
                              </Button>
                            )}
                          </div>
                        </TableCell>
                      </TableRow>
                    );
                  })}

                  {/* Summary Row */}
                  <TableRow className="bg-muted/30 font-medium border-t-2">
                    <TableCell>Total ({subscriptions.length} tools)</TableCell>
                    <TableCell></TableCell>
                    <TableCell className="text-right font-mono">
                      {formatCurrency(totalMonthly)}/mo
                    </TableCell>
                    <TableCell></TableCell>
                    <TableCell></TableCell>
                    <TableCell>
                      {totalCreditsLimit > 0 && (
                        <span>
                          {totalCredits.toLocaleString()} / {totalCreditsLimit.toLocaleString()}
                        </span>
                      )}
                    </TableCell>
                    <TableCell></TableCell>
                    <TableCell></TableCell>
                  </TableRow>
                </TableBody>
              </Table>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Add/Edit Dialog */}
      <Dialog open={dialogOpen} onOpenChange={(open) => {
        if (!open) {
          setDialogOpen(false);
          resetForm();
        }
      }}>
        <DialogContent className="max-w-lg max-h-[90vh] overflow-y-auto">
          <form onSubmit={handleSubmit}>
            <DialogHeader>
              <DialogTitle>
                {editingSubscription ? "Edit Subscription" : "Add Subscription"}
              </DialogTitle>
              <DialogDescription>
                {editingSubscription
                  ? "Update the details for this subscription"
                  : "Add a new SaaS tool to track"}
              </DialogDescription>
            </DialogHeader>

            <div className="py-4 space-y-4">
              {/* Name */}
              <div>
                <Label htmlFor="name">Tool Name *</Label>
                <Input
                  id="name"
                  value={formData.name}
                  onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  placeholder="e.g., Instantly, Clay, Smartlead"
                  className="mt-1"
                />
              </div>

              {/* Category */}
              <div>
                <Label htmlFor="category">Category</Label>
                <Select
                  value={formData.category}
                  onValueChange={(value) => setFormData({ ...formData, category: value })}
                >
                  <SelectTrigger className="mt-1">
                    <SelectValue placeholder="Select a category" />
                  </SelectTrigger>
                  <SelectContent>
                    {CATEGORIES.map((cat) => (
                      <SelectItem key={cat} value={cat}>
                        {cat}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {/* URL */}
              <div>
                <Label htmlFor="url">Login URL</Label>
                <Input
                  id="url"
                  type="url"
                  value={formData.url}
                  onChange={(e) => setFormData({ ...formData, url: e.target.value })}
                  placeholder="https://app.instantly.ai"
                  className="mt-1"
                />
              </div>

              {/* Credentials */}
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="username">Username/Email</Label>
                  <Input
                    id="username"
                    value={formData.username}
                    onChange={(e) => setFormData({ ...formData, username: e.target.value })}
                    placeholder="your@email.com"
                    className="mt-1"
                  />
                </div>
                <div>
                  <Label htmlFor="password">Password</Label>
                  <Input
                    id="password"
                    type="text"
                    value={formData.password}
                    onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                    placeholder="Password"
                    className="mt-1"
                  />
                </div>
              </div>

              {/* Cost & Billing */}
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="cost">Cost ($)</Label>
                  <Input
                    id="cost"
                    type="number"
                    step="0.01"
                    value={formData.cost}
                    onChange={(e) => setFormData({ ...formData, cost: e.target.value })}
                    placeholder="99.00"
                    className="mt-1"
                  />
                </div>
                <div>
                  <Label htmlFor="billing_cycle">Billing Cycle</Label>
                  <Select
                    value={formData.billing_cycle}
                    onValueChange={(value) => setFormData({ ...formData, billing_cycle: value as BillingCycle })}
                  >
                    <SelectTrigger className="mt-1">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      {BILLING_CYCLES.map((cycle) => (
                        <SelectItem key={cycle.value} value={cycle.value}>
                          {cycle.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>

              {/* Renewal Date */}
              <div>
                <Label htmlFor="renewal_date">Next Renewal Date</Label>
                <Input
                  id="renewal_date"
                  type="date"
                  value={formData.renewal_date}
                  onChange={(e) => setFormData({ ...formData, renewal_date: e.target.value })}
                  className="mt-1"
                />
              </div>

              {/* Credits */}
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="credits_balance">Current Credits</Label>
                  <Input
                    id="credits_balance"
                    type="number"
                    value={formData.credits_balance}
                    onChange={(e) => setFormData({ ...formData, credits_balance: e.target.value })}
                    placeholder="0"
                    className="mt-1"
                  />
                </div>
                <div>
                  <Label htmlFor="credits_limit">Credit Limit</Label>
                  <Input
                    id="credits_limit"
                    type="number"
                    value={formData.credits_limit}
                    onChange={(e) => setFormData({ ...formData, credits_limit: e.target.value })}
                    placeholder="10000"
                    className="mt-1"
                  />
                </div>
              </div>

              {/* Notes */}
              <div>
                <Label htmlFor="notes">Notes</Label>
                <Textarea
                  id="notes"
                  value={formData.notes}
                  onChange={(e) => setFormData({ ...formData, notes: e.target.value })}
                  placeholder="Any additional notes..."
                  className="mt-1"
                  rows={2}
                />
              </div>
            </div>

            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => setDialogOpen(false)}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSaving || !formData.name.trim()}>
                {isSaving ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    Saving...
                  </>
                ) : editingSubscription ? (
                  "Update"
                ) : (
                  "Add Subscription"
                )}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>
    </div>
  );
}
</file>

<file path="src/app/api/admin/invitations/route.ts">
import { createClient } from "@/lib/supabase/server";
import { createClient as createServiceClient } from "@supabase/supabase-js";
import { NextResponse } from "next/server";

// Create a Supabase client with service role for admin operations
function getServiceSupabase() {
  return createServiceClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// POST - Send an invitation to a client
export async function POST(request: Request) {
  try {
    const supabase = await createClient();
    const serviceSupabase = getServiceSupabase();

    // Verify admin access
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    if (profile?.role !== "admin") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const body = await request.json();
    const { client_id, email, first_name } = body;

    if (!client_id || !email) {
      return NextResponse.json(
        { error: "client_id and email are required" },
        { status: 400 }
      );
    }

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return NextResponse.json(
        { error: "Invalid email format" },
        { status: 400 }
      );
    }

    // Get client name for the invitation
    const { data: client } = await serviceSupabase
      .from("clients")
      .select("name")
      .eq("id", client_id)
      .single();

    if (!client) {
      return NextResponse.json(
        { error: "Client not found" },
        { status: 404 }
      );
    }

    // Generate invitation token
    const token = crypto.randomUUID();
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // 7 days expiry

    // Store invitation in database
    const { data: invitation, error: insertError } = await serviceSupabase
      .from("client_invitations")
      .insert({
        client_id,
        email: email.toLowerCase().trim(),
        first_name: first_name?.trim() || null,
        token,
        expires_at: expiresAt.toISOString(),
        invited_by: user.id,
      })
      .select()
      .single();

    if (insertError) {
      // Table might not exist, create it
      if (insertError.code === "42P01") {
        return NextResponse.json(
          { error: "Invitations table not set up. Please run database migration." },
          { status: 500 }
        );
      }
      console.error("Error creating invitation:", insertError);
      return NextResponse.json({ error: insertError.message }, { status: 500 });
    }

    // Send invitation email using Supabase Auth
    // This sends a magic link that allows the user to sign in
    const baseUrl = request.headers.get("origin") || "http://localhost:3000";
    const inviteUrl = `${baseUrl}/auth/invite?token=${token}`;

    // Check if user already exists
    const { data: existingUsers } = await serviceSupabase.auth.admin.listUsers();
    const existingUser = existingUsers?.users?.find(
      (u) => u.email?.toLowerCase() === email.toLowerCase()
    );

    if (existingUser) {
      // User already exists - update their metadata with new client_id and link them
      console.log("[Invitation] User already exists, updating metadata and linking:", existingUser.id);

      // Update user metadata to point to new client
      const { error: updateError } = await serviceSupabase.auth.admin.updateUserById(
        existingUser.id,
        {
          user_metadata: {
            ...existingUser.user_metadata,
            client_id: client_id,
            first_name: first_name || existingUser.user_metadata?.first_name || "",
            invited: true,
          },
        }
      );

      if (updateError) {
        console.error("[Invitation] Error updating user metadata:", updateError);
      }

      // Ensure profile exists
      const { data: existingProfile } = await serviceSupabase
        .from("profiles")
        .select("id")
        .eq("id", existingUser.id)
        .single();

      if (!existingProfile) {
        await serviceSupabase.from("profiles").insert({
          id: existingUser.id,
          email: existingUser.email,
          first_name: first_name || existingUser.user_metadata?.first_name || null,
          role: "client",
        });
        console.log("[Invitation] Created profile for existing user");
      }

      // Link them to the client
      const { error: linkError } = await serviceSupabase
        .from("client_users")
        .upsert({
          client_id: client_id,
          user_id: existingUser.id,
          role: "viewer",
        }, { onConflict: "client_id,user_id" });

      if (linkError) {
        console.error("[Invitation] Error linking existing user:", linkError);
      }

      // Update invitation as already accepted
      await serviceSupabase
        .from("client_invitations")
        .update({ accepted_at: new Date().toISOString() })
        .eq("id", invitation.id);

      // Send notification email to existing user using magic link
      // This lets them know they have access to a new client
      console.log("[Invitation] Sending notification email to existing user:", email);
      const { error: magicLinkError } = await serviceSupabase.auth.signInWithOtp({
        email: email,
        options: {
          emailRedirectTo: `${baseUrl}/auth/callback?next=/admin/clients/${client_id}`,
          data: {
            client_id: client_id,
            client_name: client.name,
          },
        },
      });

      if (magicLinkError) {
        console.error("[Invitation] Error sending magic link to existing user:", magicLinkError);
      } else {
        console.log("[Invitation] Magic link sent to existing user");
      }

      return NextResponse.json({
        success: true,
        invitation,
        invite_url: inviteUrl,
        email_sent: !magicLinkError,
        user_linked: true,
        message: "User already exists and has been linked to the client. Notification email sent.",
      });
    }

    // New user - send invite email
    console.log("[Invitation] Sending invite email to:", email);
    const { data: inviteData, error: inviteError } = await serviceSupabase.auth.admin.inviteUserByEmail(email, {
      redirectTo: `${baseUrl}/auth/callback?next=/dashboard&client_id=${client_id}`,
      data: {
        first_name: first_name || "",
        client_id: client_id,
        invited: true,
      },
    });

    console.log("[Invitation] Invite result:", { inviteData, inviteError });

    if (inviteError) {
      console.error("[Invitation] Error sending invite email:", inviteError);
      return NextResponse.json({
        success: true,
        invitation,
        invite_url: inviteUrl,
        email_sent: false,
        email_error: inviteError.message,
      });
    }

    console.log("[Invitation] Email sent successfully to:", email);
    return NextResponse.json({
      success: true,
      invitation,
      invite_url: inviteUrl,
      email_sent: true,
      user_created: inviteData?.user?.id,
    });
  } catch (error) {
    console.error("Error in invitations POST:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// GET - List invitations for a client
export async function GET(request: Request) {
  try {
    const supabase = await createClient();

    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const clientId = searchParams.get("client_id");

    if (!clientId) {
      return NextResponse.json(
        { error: "client_id is required" },
        { status: 400 }
      );
    }

    const { data: invitations, error } = await supabase
      .from("client_invitations")
      .select("*")
      .eq("client_id", clientId)
      .order("created_at", { ascending: false });

    if (error) {
      console.error("Error fetching invitations:", error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ invitations });
  } catch (error) {
    console.error("Error in invitations GET:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/leads/export/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { searchParams } = new URL(request.url);

    const exportType = searchParams.get("export") || "all";
    const clientFilter = searchParams.get("client");
    const statusFilter = searchParams.get("status");
    const positiveFilter = searchParams.get("positive") === "true";

    // Build query based on export type - select all fields
    let query = supabase
      .from("leads")
      .select("*, client_id, client_name, campaign_name, campaigns(name, client_id, clients(name))");

    switch (exportType) {
      case "current":
        // Apply current filters
        if (clientFilter && clientFilter !== "all") {
          query = query.eq("client_id", clientFilter);
        }
        if (statusFilter && statusFilter !== "all") {
          query = query.eq("status", statusFilter);
        }
        if (positiveFilter) {
          query = query.eq("is_positive_reply", true);
        }
        break;

      case "positive":
        // Only positive replies
        query = query.eq("is_positive_reply", true);
        break;

      case "replied":
        // All leads that replied
        query = query.eq("status", "replied");
        break;

      case "no_response":
        // Leads that were contacted but didn't reply
        query = query.in("status", ["contacted", "opened", "clicked"]);
        break;

      case "all":
        // No filters - get all leads
        break;
    }

    // Execute query with ordering
    const { data: leads, error } = await query.order("updated_at", { ascending: false });

    if (error) {
      console.error("Export query error:", error);
      return NextResponse.json({ error: "Failed to fetch leads" }, { status: 500 });
    }

    // Generate CSV with ALL fields
    const headers = [
      // Basic Info
      "Lead ID",
      "Email",
      "First Name",
      "Last Name",
      // Company Info
      "Company Name",
      "Company Domain",
      // Contact Info
      "Phone",
      "LinkedIn URL",
      // Personalization
      "Personalization",
      // Status & Sales
      "Status",
      "Is Positive Reply",
      "Deal Value",
      "Next Action",
      "Next Action Date",
      // Email Stats
      "Email Open Count",
      "Email Click Count",
      "Email Reply Count",
      "Last Contacted At",
      // Instantly Integration
      "Instantly Lead ID",
      "Instantly Created At",
      // Notes
      "Notes",
      // Organization
      "Client ID",
      "Client Name",
      "Campaign ID",
      "Campaign Name",
      // Timestamps
      "Created At",
      "Updated At",
    ];

    const escapeCSV = (value: string | number | boolean | null | undefined): string => {
      if (value === null || value === undefined) return "";
      const str = String(value);
      // Escape quotes and wrap in quotes if contains comma, quote, or newline
      if (str.includes(",") || str.includes('"') || str.includes("\n") || str.includes("\r")) {
        return `"${str.replace(/"/g, '""')}"`;
      }
      return str;
    };

    const formatDate = (dateStr: string | null | undefined): string => {
      if (!dateStr) return "";
      try {
        return new Date(dateStr).toISOString();
      } catch {
        return "";
      }
    };

    const rows = (leads || []).map((lead) => {
      const clientName = lead.campaigns?.clients?.name || lead.client_name || "";
      const campaignName = lead.campaigns?.name || lead.campaign_name || "";

      return [
        // Basic Info
        escapeCSV(lead.id),
        escapeCSV(lead.email),
        escapeCSV(lead.first_name),
        escapeCSV(lead.last_name),
        // Company Info
        escapeCSV(lead.company_name),
        escapeCSV(lead.company_domain),
        // Contact Info
        escapeCSV(lead.phone),
        escapeCSV(lead.linkedin_url),
        // Personalization
        escapeCSV(lead.personalization),
        // Status & Sales
        escapeCSV(lead.status),
        escapeCSV(lead.is_positive_reply ? "Yes" : "No"),
        escapeCSV(lead.deal_value),
        escapeCSV(lead.next_action),
        escapeCSV(lead.next_action_date),
        // Email Stats
        escapeCSV(lead.email_open_count || 0),
        escapeCSV(lead.email_click_count || 0),
        escapeCSV(lead.email_reply_count || 0),
        escapeCSV(formatDate(lead.last_contacted_at)),
        // Instantly Integration
        escapeCSV(lead.instantly_lead_id),
        escapeCSV(formatDate(lead.instantly_created_at)),
        // Notes
        escapeCSV(lead.notes),
        // Organization
        escapeCSV(lead.client_id),
        escapeCSV(clientName),
        escapeCSV(lead.campaign_id),
        escapeCSV(campaignName),
        // Timestamps
        escapeCSV(formatDate(lead.created_at)),
        escapeCSV(formatDate(lead.updated_at)),
      ].join(",");
    });

    const csvContent = [headers.join(","), ...rows].join("\n");

    // Return CSV as downloadable file
    return new NextResponse(csvContent, {
      headers: {
        "Content-Type": "text/csv; charset=utf-8",
        "Content-Disposition": `attachment; filename="${exportType}_leads_${new Date().toISOString().split("T")[0]}.csv"`,
      },
    });
  } catch (error) {
    console.error("Export error:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Export failed" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/campaigns/[campaignId]/sequences/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { fetchInstantlyCampaignDetails } from "@/lib/instantly/campaigns";

// Use service role key for admin operations
function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET: Fetch sequences for a campaign (from DB, or sync from Instantly if needed)
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ campaignId: string }> }
) {
  const { campaignId } = await params;
  const supabase = getSupabase();

  try {
    // First, try to get sequences from database
    const { data: sequences, error: dbError } = await supabase
      .from("campaign_sequences")
      .select("*")
      .eq("campaign_id", campaignId)
      .order("sequence_index")
      .order("step_number")
      .order("variant");

    if (dbError) {
      console.error("DB error fetching sequences:", dbError);
      // If table doesn't exist yet, return empty array
      if (dbError.code === "42P01") {
        return NextResponse.json({ sequences: [], needsSync: true });
      }
      throw dbError;
    }

    // Get campaign to check if we need to sync
    const { data: campaign } = await supabase
      .from("campaigns")
      .select("instantly_campaign_id, last_synced_at")
      .eq("id", campaignId)
      .single();

    const needsSync = !sequences || sequences.length === 0;

    return NextResponse.json({
      sequences: sequences || [],
      needsSync,
      lastSyncedAt: campaign?.last_synced_at,
    });
  } catch (error) {
    console.error("Error fetching sequences:", error);
    return NextResponse.json(
      { error: "Failed to fetch sequences" },
      { status: 500 }
    );
  }
}

// POST: Sync sequences from Instantly
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ campaignId: string }> }
) {
  const { campaignId } = await params;
  const supabase = getSupabase();

  try {
    // Get campaign to find Instantly campaign ID
    const { data: campaign, error: campaignError } = await supabase
      .from("campaigns")
      .select("id, instantly_campaign_id, name")
      .eq("id", campaignId)
      .single();

    if (campaignError || !campaign) {
      return NextResponse.json(
        { error: "Campaign not found" },
        { status: 404 }
      );
    }

    if (!campaign.instantly_campaign_id) {
      return NextResponse.json(
        { error: "Campaign not linked to Instantly" },
        { status: 400 }
      );
    }

    // Fetch campaign details from Instantly (includes sequences)
    const instantlyDetails = await fetchInstantlyCampaignDetails(
      campaign.instantly_campaign_id
    );

    console.log("Instantly campaign details:", JSON.stringify(instantlyDetails, null, 2));

    if (!instantlyDetails.sequences || instantlyDetails.sequences.length === 0) {
      return NextResponse.json({
        message: "No sequences found in Instantly campaign response",
        synced: 0,
        debug: { hasSequences: false, campaignId: campaign.instantly_campaign_id }
      });
    }

    // Delete existing sequences for this campaign
    await supabase
      .from("campaign_sequences")
      .delete()
      .eq("campaign_id", campaignId);

    // Parse and insert sequences
    const sequencesToInsert: Array<{
      campaign_id: string;
      sequence_index: number;
      step_number: number;
      variant: string;
      subject: string | null;
      body_text: string | null;
      body_html: string | null;
      delay_days: number;
    }> = [];

    // Instantly returns sequences as an array, but only first element is used
    const mainSequence = instantlyDetails.sequences[0];
    console.log("Main sequence:", JSON.stringify(mainSequence, null, 2));

    if (mainSequence && mainSequence.steps) {
      mainSequence.steps.forEach((step: { type?: string; delay?: number; variants?: Array<{ subject?: string; body?: string; v_disabled?: boolean }> }, stepIndex: number) => {
        // Instantly V2 API has variants array inside each step
        // Each variant has subject and body
        if (step.variants && step.variants.length > 0) {
          step.variants.forEach((variant, variantIndex) => {
            if (variant.v_disabled) return; // Skip disabled variants

            const variantLabel = step.variants!.length > 1
              ? String.fromCharCode(65 + variantIndex) // A, B, C...
              : "A";

            sequencesToInsert.push({
              campaign_id: campaignId,
              sequence_index: 0,
              step_number: stepIndex + 1,
              variant: variantLabel,
              subject: variant.subject || null,
              body_text: variant.body || null,
              body_html: variant.body || null,
              delay_days: step.delay || 0,
            });
          });
        }
      });
    }

    console.log("Sequences to insert:", sequencesToInsert.length);

    if (sequencesToInsert.length === 0) {
      // Sequences array exists but couldn't parse any steps
      return NextResponse.json({
        message: "Found sequences but couldn't parse email steps. The campaign may use a different format.",
        synced: 0,
        debug: {
          sequencesCount: instantlyDetails.sequences?.length,
          stepsCount: mainSequence?.steps?.length,
          rawSequenceKeys: mainSequence ? Object.keys(mainSequence) : [],
          firstStepKeys: mainSequence?.steps?.[0] ? Object.keys(mainSequence.steps[0]) : []
        }
      });
    }

    const { error: insertError } = await supabase
      .from("campaign_sequences")
      .insert(sequencesToInsert);

    if (insertError) {
      console.error("Error inserting sequences:", insertError);
      // Check if it's a table doesn't exist error
      if (insertError.code === "42P01") {
        return NextResponse.json({
          error: "Database table 'campaign_sequences' not found. Please run the migration: 20241230_add_email_sequences_and_threads.sql",
          synced: 0,
        }, { status: 500 });
      }
      throw insertError;
    }

    // Update campaign last_synced_at
    await supabase
      .from("campaigns")
      .update({
        last_synced_at: new Date().toISOString(),
        original_name: instantlyDetails.name,
      })
      .eq("id", campaignId);

    return NextResponse.json({
      message: "Sequences synced successfully",
      synced: sequencesToInsert.length,
    });
  } catch (error) {
    console.error("Error syncing sequences:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      { error: `Failed to sync sequences from Instantly: ${errorMessage}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/campaigns/[campaignId]/sync-leads/route.ts">
// Historical Lead Sync Endpoint
// Pulls ALL leads from the provider API and upserts them into Supabase

import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { getProviderForCampaign } from "@/lib/providers";
import type { ProviderLead } from "@/lib/providers/types";

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ campaignId: string }> }
) {
  const { campaignId } = await params;

  // Use service role to bypass RLS
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseServiceKey) {
    return NextResponse.json(
      { error: "Server configuration error" },
      { status: 500 }
    );
  }

  const supabase = createClient(supabaseUrl, supabaseServiceKey);

  try {
    // Fetch campaign details
    const { data: campaign, error: campaignError } = await supabase
      .from("campaigns")
      .select("id, client_id, name, provider_type, provider_campaign_id, instantly_campaign_id")
      .eq("id", campaignId)
      .single();

    if (campaignError || !campaign) {
      return NextResponse.json(
        { error: "Campaign not found" },
        { status: 404 }
      );
    }

    // Get client name for denormalization
    const { data: client } = await supabase
      .from("clients")
      .select("name")
      .eq("id", campaign.client_id)
      .single();

    // Get provider instance
    const provider = await getProviderForCampaign(campaignId);

    // Get the provider campaign ID
    const providerCampaignId =
      campaign.provider_campaign_id || campaign.instantly_campaign_id;

    if (!providerCampaignId) {
      return NextResponse.json(
        { error: "Campaign not linked to provider" },
        { status: 400 }
      );
    }

    console.log(
      `[SyncLeads] Starting sync for campaign ${campaignId} (${provider.providerType})`
    );

    // Fetch ALL leads from provider
    const providerLeads = await provider.fetchAllLeads(providerCampaignId);

    console.log(`[SyncLeads] Fetched ${providerLeads.length} leads from provider`);

    // Get existing leads for this campaign
    const { data: existingLeads } = await supabase
      .from("leads")
      .select("email, provider_lead_id, instantly_lead_id, client_id")
      .eq("campaign_id", campaignId);

    // Fix any leads with missing client_id
    const leadsWithoutClientId = (existingLeads || []).filter(l => !l.client_id);
    if (leadsWithoutClientId.length > 0 && campaign.client_id) {
      console.log(`[SyncLeads] Fixing ${leadsWithoutClientId.length} leads with missing client_id`);
      await supabase
        .from("leads")
        .update({
          client_id: campaign.client_id,
          client_name: client?.name,
          campaign_name: campaign.name
        })
        .eq("campaign_id", campaignId)
        .is("client_id", null);
    }

    const existingByEmail = new Map<string, { provider_lead_id?: string; instantly_lead_id?: string }>();
    const existingByProviderId = new Map<string, boolean>();

    (existingLeads || []).forEach((lead) => {
      existingByEmail.set(lead.email.toLowerCase(), lead);
      if (lead.provider_lead_id) {
        existingByProviderId.set(lead.provider_lead_id, true);
      }
      if (lead.instantly_lead_id) {
        existingByProviderId.set(lead.instantly_lead_id, true);
      }
    });

    // Prepare upsert data
    const leadsToInsert: Array<Record<string, unknown>> = [];
    const leadsToUpdate: Array<{ email: string; data: Record<string, unknown> }> = [];

    for (const lead of providerLeads) {
      const emailLower = lead.email.toLowerCase();
      const existing = existingByEmail.get(emailLower);

      const leadData: Record<string, unknown> = {
        campaign_id: campaignId,
        client_id: campaign.client_id,
        client_name: client?.name,
        campaign_name: campaign.name,
        email: lead.email,
        first_name: lead.firstName,
        last_name: lead.lastName,
        company_name: lead.companyName,
        company_domain: lead.companyDomain,
        phone: lead.phone,
        linkedin_url: lead.linkedinUrl,
        // website field removed - not in leads table schema
        provider_type: provider.providerType,
        provider_lead_id: lead.id,
        email_open_count: lead.emailOpenCount || 0,
        email_click_count: lead.emailClickCount || 0,
        email_reply_count: lead.emailReplyCount || 0,
        updated_at: new Date().toISOString(),
      };

      // NOTE: We do NOT set is_positive_reply here because the Instantly /leads/list endpoint
      // does NOT return interest_status for regular leads. We fetch positive leads separately
      // at the end of this sync using fetchPositiveLeads() which filters by interest_status.
      // Setting is_positive_reply based on non-existent data caused 11k+ false positives.

      // We only set is_positive_reply = false for explicitly negative statuses
      const interestStatus = lead.interestStatus;
      const negativeStatuses = ["not_interested", 2, "2"];

      if (negativeStatuses.includes(interestStatus as string | number)) {
        leadData.is_positive_reply = false;
      }

      // Map status
      if (lead.status) {
        leadData.status = mapLeadStatus(lead.status, lead.interestStatus);
      }

      // For backwards compatibility with Instantly
      if (provider.providerType === "instantly") {
        leadData.instantly_lead_id = lead.id;
      }

      // Store custom fields in metadata
      if (lead.customFields && Object.keys(lead.customFields).length > 0) {
        leadData.metadata = { customFields: lead.customFields };
      }

      if (existing) {
        leadsToUpdate.push({ email: emailLower, data: leadData });
      } else {
        leadData.created_at = lead.createdAt || new Date().toISOString();
        leadsToInsert.push(leadData);
      }
    }

    console.log(
      `[SyncLeads] ${leadsToInsert.length} new leads, ${leadsToUpdate.length} to update`
    );

    // Insert new leads in batches
    let insertedCount = 0;
    const insertBatchSize = 100;
    const totalBatches = Math.ceil(leadsToInsert.length / insertBatchSize);

    console.log(`[SyncLeads] Inserting ${leadsToInsert.length} leads in ${totalBatches} batches...`);

    for (let i = 0; i < leadsToInsert.length; i += insertBatchSize) {
      const batch = leadsToInsert.slice(i, i + insertBatchSize);
      const batchNum = Math.floor(i / insertBatchSize) + 1;

      const { error: insertError } = await supabase.from("leads").insert(batch);

      if (insertError) {
        console.error(`[SyncLeads] Insert batch ${batchNum}/${totalBatches} error:`, insertError);
      } else {
        insertedCount += batch.length;
      }

      // Log progress every 50 batches
      if (batchNum % 50 === 0) {
        console.log(`[SyncLeads] Inserted ${insertedCount}/${leadsToInsert.length} leads...`);
      }
    }

    console.log(`[SyncLeads] Finished inserting ${insertedCount} leads`);

    // Update existing leads in batches
    let updatedCount = 0;

    for (const { email, data } of leadsToUpdate) {
      const { error: updateError } = await supabase
        .from("leads")
        .update(data)
        .eq("campaign_id", campaignId)
        .ilike("email", email);

      if (!updateError) {
        updatedCount++;
      }
    }

    // Update last_lead_sync_at
    await supabase
      .from("campaigns")
      .update({ last_lead_sync_at: new Date().toISOString() })
      .eq("id", campaignId);

    // Also sync campaign analytics from the provider
    let analyticsData = null;
    try {
      const analytics = await provider.fetchCampaignAnalytics(providerCampaignId);
      if (analytics) {
        analyticsData = {
          emails_sent: analytics.emailsSentCount || 0,
          emails_opened: analytics.openCountUnique || 0,
          emails_replied: analytics.replyCount || 0,
          emails_bounced: analytics.bouncedCount || 0,
          total_opportunities: analytics.totalOpportunities || 0,
          leads_count: analytics.leadsCount || 0,
          contacted_count: analytics.contactedCount || 0,
        };

        await supabase
          .from("campaigns")
          .update({
            cached_emails_sent: analytics.emailsSentCount || 0,
            cached_emails_opened: analytics.openCountUnique || 0,
            cached_reply_count: analytics.replyCount || 0,
            cached_emails_bounced: analytics.bouncedCount || 0,
            cached_positive_count: analytics.totalOpportunities || 0,
            cache_updated_at: new Date().toISOString(),
          })
          .eq("id", campaignId);

        console.log(`[SyncLeads] Synced analytics: ${analytics.emailsSentCount} sent, ${analytics.replyCount} replies`);
      }
    } catch (analyticsError) {
      console.warn(`[SyncLeads] Could not sync analytics:`, analyticsError);
    }

    // Sync positive leads specifically (Instantly doesn't return interest_status in regular leads list)
    // IMPORTANT: First reset all is_positive_reply to false, then mark only the truly positive ones
    let positiveLeadsSynced = 0;
    try {
      // Check if provider has fetchPositiveLeads method (Instantly-specific)
      if ('fetchPositiveLeads' in provider && typeof provider.fetchPositiveLeads === 'function') {
        console.log(`[SyncLeads] Resetting is_positive_reply for all leads in this campaign...`);

        // Reset all leads in this campaign to not positive (clean slate)
        const { error: resetError } = await supabase
          .from("leads")
          .update({ is_positive_reply: false })
          .eq("campaign_id", campaignId)
          .eq("is_positive_reply", true);

        if (resetError) {
          console.warn(`[SyncLeads] Error resetting positive leads:`, resetError);
        }

        console.log(`[SyncLeads] Fetching positive leads from provider...`);
        const positiveLeads = await (provider as { fetchPositiveLeads: (id: string) => Promise<ProviderLead[]> }).fetchPositiveLeads(providerCampaignId);

        console.log(`[SyncLeads] Found ${positiveLeads.length} positive leads to sync`);

        for (const lead of positiveLeads) {
          const emailLower = lead.email.toLowerCase();

          // Update existing lead to mark as positive
          const { error: updateError } = await supabase
            .from("leads")
            .update({
              is_positive_reply: true,
              has_replied: true,
              status: "replied",
            })
            .eq("campaign_id", campaignId)
            .ilike("email", emailLower);

          if (!updateError) {
            positiveLeadsSynced++;
          }
        }

        console.log(`[SyncLeads] Marked ${positiveLeadsSynced} leads as positive`);
      }
    } catch (positiveError) {
      console.warn(`[SyncLeads] Could not sync positive leads:`, positiveError);
    }

    console.log(
      `[SyncLeads] Completed: ${insertedCount} inserted, ${updatedCount} updated`
    );

    return NextResponse.json({
      success: true,
      totalFromProvider: providerLeads.length,
      inserted: insertedCount,
      updated: updatedCount,
      skipped: leadsToInsert.length - insertedCount,
      analytics: analyticsData,
    });
  } catch (error) {
    console.error("[SyncLeads] Error:", error);
    return NextResponse.json(
      {
        error:
          error instanceof Error ? error.message : "Failed to sync leads",
      },
      { status: 500 }
    );
  }
}

// Map provider status to our internal status
function mapLeadStatus(
  status?: string,
  interestStatus?: ProviderLead["interestStatus"]
): string {
  // Interest status takes priority (handle both string and numeric)
  const positiveStatuses = ["interested", "meeting_booked", "meeting_completed", "closed", 1, 3, "1", "3"];
  const bookedStatuses = ["meeting_booked", "meeting_completed", 3, "3"];

  if (bookedStatuses.includes(interestStatus as string | number)) {
    return "booked";
  }
  if (positiveStatuses.includes(interestStatus as string | number)) {
    return "replied";
  }

  // Fall back to status
  switch (status) {
    case "contacted":
    case "STARTED":
    case "started":
      return "contacted";
    case "opened":
      return "opened";
    case "clicked":
      return "clicked";
    case "replied":
    case "COMPLETED":
    case "completed":
      return "replied";
    default:
      return "contacted";
  }
}

// GET endpoint to check sync status
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ campaignId: string }> }
) {
  const { campaignId } = await params;

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseServiceKey) {
    return NextResponse.json(
      { error: "Server configuration error" },
      { status: 500 }
    );
  }

  const supabase = createClient(supabaseUrl, supabaseServiceKey);

  const { data: campaign } = await supabase
    .from("campaigns")
    .select("last_lead_sync_at")
    .eq("id", campaignId)
    .single();

  const { count } = await supabase
    .from("leads")
    .select("*", { count: "exact", head: true })
    .eq("campaign_id", campaignId);

  return NextResponse.json({
    lastSyncAt: campaign?.last_lead_sync_at,
    leadCount: count || 0,
  });
}
</file>

<file path="src/app/api/clients/[clientId]/invitations/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { createClient as createServerClient } from "@/lib/supabase/server";
import { sendInvitationEmail } from "@/lib/email";

function getSupabaseAdmin() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - List invited users for a client
export async function GET(
  request: Request,
  { params }: { params: Promise<{ clientId: string }> }
) {
  try {
    const { clientId } = await params;
    const supabase = await createServerClient();

    // Verify user is admin
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    if (profile?.role !== "admin") {
      return NextResponse.json({ error: "Admin access required" }, { status: 403 });
    }

    // Get all client users with their profile info
    const adminSupabase = getSupabaseAdmin();

    const { data: clientUsers, error } = await adminSupabase
      .from("client_users")
      .select(`
        user_id,
        role,
        created_at,
        profiles:user_id (
          id,
          email,
          full_name
        )
      `)
      .eq("client_id", clientId);

    if (error) {
      console.error("Error fetching client users:", error);
      return NextResponse.json({ error: "Failed to fetch users" }, { status: 500 });
    }

    // Get pending invitations
    const { data: invitations } = await adminSupabase
      .from("client_invitations")
      .select("*")
      .eq("client_id", clientId)
      .is("accepted_at", null)
      .gt("expires_at", new Date().toISOString());

    return NextResponse.json({
      users: clientUsers || [],
      pendingInvitations: invitations || [],
    });
  } catch (error) {
    console.error("Error in GET /api/clients/[clientId]/invitations:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch users" },
      { status: 500 }
    );
  }
}

// POST - Invite a user to a client
export async function POST(
  request: Request,
  { params }: { params: Promise<{ clientId: string }> }
) {
  try {
    const { clientId } = await params;
    const body = await request.json();
    const { email, name, role = "owner" } = body as { email: string; name?: string; role?: string };

    if (!email) {
      return NextResponse.json({ error: "Email is required" }, { status: 400 });
    }

    const supabase = await createServerClient();

    // Verify user is admin
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    if (profile?.role !== "admin") {
      return NextResponse.json({ error: "Admin access required" }, { status: 403 });
    }

    const adminSupabase = getSupabaseAdmin();

    // Get client info
    const { data: client } = await adminSupabase
      .from("clients")
      .select("id, name")
      .eq("id", clientId)
      .single();

    if (!client) {
      return NextResponse.json({ error: "Client not found" }, { status: 404 });
    }

    // Check if user already exists
    const { data: existingProfile } = await adminSupabase
      .from("profiles")
      .select("id, email")
      .eq("email", email.toLowerCase())
      .single();

    if (existingProfile) {
      // Check if user is already linked to this client
      const { data: existingLink } = await adminSupabase
        .from("client_users")
        .select("user_id")
        .eq("client_id", clientId)
        .eq("user_id", existingProfile.id)
        .single();

      if (existingLink) {
        return NextResponse.json(
          { error: "User is already a member of this client" },
          { status: 400 }
        );
      }

      // Link existing user to client
      const { error: linkError } = await adminSupabase
        .from("client_users")
        .insert({
          client_id: clientId,
          user_id: existingProfile.id,
          role: role,
        });

      if (linkError) {
        console.error("Error linking user:", linkError);
        return NextResponse.json({ error: "Failed to add user" }, { status: 500 });
      }

      // Generate a login link for the existing user to access their new client
      const appUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
      const dashboardUrl = `${appUrl}/dashboard/${clientId}`;
      const loginUrl = `${appUrl}/login?redirect=${encodeURIComponent(`/dashboard/${clientId}`)}`;

      return NextResponse.json({
        success: true,
        message: `${email} has been added to this client. Share the link so they can access their new dashboard.`,
        isNewUser: false,
        loginUrl,
        dashboardUrl,
      });
    }

    // Check for existing pending invitation
    const { data: existingInvitation } = await adminSupabase
      .from("client_invitations")
      .select("id")
      .eq("client_id", clientId)
      .eq("email", email.toLowerCase())
      .is("accepted_at", null)
      .gt("expires_at", new Date().toISOString())
      .single();

    if (existingInvitation) {
      return NextResponse.json(
        { error: "An invitation is already pending for this email" },
        { status: 400 }
      );
    }

    // Create invitation token
    const token = crypto.randomUUID();
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // 7 days expiry

    // Store invitation
    const { error: inviteError } = await adminSupabase
      .from("client_invitations")
      .insert({
        client_id: clientId,
        email: email.toLowerCase(),
        name: name || null,
        role: role,
        token: token,
        invited_by: user.id,
        expires_at: expiresAt.toISOString(),
      });

    if (inviteError) {
      console.error("Error creating invitation:", inviteError);
      // Table might not exist, try to create a simpler flow
      if (inviteError.code === "42P01") {
        return NextResponse.json(
          { error: "Invitations table not set up. Please run database migrations." },
          { status: 500 }
        );
      }
      return NextResponse.json({ error: "Failed to create invitation" }, { status: 500 });
    }

    // Generate the login URL for this invitation
    const appUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
    const loginUrl = `${appUrl}/login?invite=${token}&email=${encodeURIComponent(email)}`;

    // Try to send the invitation email
    const emailResult = await sendInvitationEmail({
      to: email.toLowerCase(),
      inviteeName: name || email.split("@")[0],
      clientName: client.name,
      loginUrl,
    });

    return NextResponse.json({
      success: true,
      message: emailResult.success
        ? `Invitation email sent to ${email}.`
        : `Invitation created for ${email}. Share the login link with them.`,
      emailSent: emailResult.success,
      emailError: emailResult.error,
      loginUrl,
      isNewUser: true,
    });
  } catch (error) {
    console.error("Error in POST /api/clients/[clientId]/invitations:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to send invitation" },
      { status: 500 }
    );
  }
}

// DELETE - Remove a user or cancel an invitation
export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ clientId: string }> }
) {
  try {
    const { clientId } = await params;
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get("userId");
    const invitationId = searchParams.get("invitationId");

    const supabase = await createServerClient();

    // Verify user is admin
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    if (profile?.role !== "admin") {
      return NextResponse.json({ error: "Admin access required" }, { status: 403 });
    }

    const adminSupabase = getSupabaseAdmin();

    if (userId) {
      // Remove user from client
      const { error } = await adminSupabase
        .from("client_users")
        .delete()
        .eq("client_id", clientId)
        .eq("user_id", userId);

      if (error) {
        return NextResponse.json({ error: "Failed to remove user" }, { status: 500 });
      }

      return NextResponse.json({ success: true, message: "User removed" });
    }

    if (invitationId) {
      // Cancel invitation
      const { error } = await adminSupabase
        .from("client_invitations")
        .delete()
        .eq("id", invitationId)
        .eq("client_id", clientId);

      if (error) {
        return NextResponse.json({ error: "Failed to cancel invitation" }, { status: 500 });
      }

      return NextResponse.json({ success: true, message: "Invitation cancelled" });
    }

    return NextResponse.json({ error: "userId or invitationId required" }, { status: 400 });
  } catch (error) {
    console.error("Error in DELETE /api/clients/[clientId]/invitations:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to remove" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/clients/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// POST - Create a new client
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { name } = body;

    if (!name || typeof name !== "string" || name.trim().length === 0) {
      return NextResponse.json(
        { error: "Client name is required" },
        { status: 400 }
      );
    }

    const supabase = getSupabase();

    const { data: client, error } = await supabase
      .from("clients")
      .insert({ name: name.trim() })
      .select()
      .single();

    if (error) {
      console.error("Error creating client:", error);
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json({ client });
  } catch (error) {
    console.error("Error creating client:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to create client" },
      { status: 500 }
    );
  }
}

// GET - List all clients with their campaigns
export async function GET() {
  try {
    const supabase = getSupabase();

    // Fetch all clients
    const { data: clients, error: clientsError } = await supabase
      .from("clients")
      .select("id, name")
      .order("name");

    if (clientsError) {
      return NextResponse.json(
        { error: clientsError.message },
        { status: 500 }
      );
    }

    // Fetch all campaigns
    const { data: campaigns, error: campaignsError } = await supabase
      .from("campaigns")
      .select("id, name, client_id, instantly_campaign_id, is_active")
      .order("name");

    if (campaignsError) {
      return NextResponse.json(
        { error: campaignsError.message },
        { status: 500 }
      );
    }

    // Group campaigns by client
    const campaignsByClient = new Map<string, typeof campaigns>();
    for (const campaign of campaigns || []) {
      const clientCampaigns = campaignsByClient.get(campaign.client_id) || [];
      clientCampaigns.push(campaign);
      campaignsByClient.set(campaign.client_id, clientCampaigns);
    }

    // Combine clients with their campaigns
    const clientsWithCampaigns = (clients || []).map(client => ({
      ...client,
      campaigns: campaignsByClient.get(client.id) || [],
    }));

    return NextResponse.json({ clients: clientsWithCampaigns });
  } catch (error) {
    console.error("Error fetching clients:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch clients" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/instantly/campaigns/[id]/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import {
  fetchInstantlyCampaign,
  getCampaignAnalytics,
  getCampaignDailyAnalytics,
  activateCampaign,
  pauseCampaign,
  deleteInstantlyCampaign,
  getInstantlyClient,
} from "@/lib/instantly";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

interface RouteParams {
  params: Promise<{ id: string }>;
}

// GET - Get campaign details with analytics
export async function GET(request: Request, { params }: RouteParams) {
  try {
    const { id } = await params;
    const client = getInstantlyClient();

    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    const [campaign, analytics, dailyAnalytics] = await Promise.all([
      fetchInstantlyCampaign(id),
      getCampaignAnalytics({ id }),
      getCampaignDailyAnalytics({ id }),
    ]);

    return NextResponse.json({
      campaign,
      analytics: analytics[0] || null,
      dailyAnalytics,
    });
  } catch (error) {
    console.error("Error fetching campaign:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch campaign" },
      { status: 500 }
    );
  }
}

// POST - Activate or pause campaign
export async function POST(request: Request, { params }: RouteParams) {
  try {
    const { id } = await params;
    const body = await request.json();
    const { action } = body as { action: "activate" | "pause" };

    if (!action || !["activate", "pause"].includes(action)) {
      return NextResponse.json(
        { error: "Invalid action. Use 'activate' or 'pause'" },
        { status: 400 }
      );
    }

    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    const result = action === "activate"
      ? await activateCampaign(id)
      : await pauseCampaign(id);

    return NextResponse.json({
      ...result,
      action,
    });
  } catch (error) {
    console.error("Error updating campaign:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to update campaign" },
      { status: 500 }
    );
  }
}

// DELETE - Delete campaign from Instantly ONLY (does NOT touch local data)
// This is an admin-only action - UI must enforce this restriction
export async function DELETE(request: Request, { params }: RouteParams) {
  try {
    const { id } = await params;

    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    // Delete from Instantly ONLY - local campaign and leads are NOT touched
    const result = await deleteInstantlyCampaign(id);

    return NextResponse.json({
      success: true,
      instantly_deleted: result.success,
      message: "Campaign deleted from Instantly. Local data remains unchanged.",
    });
  } catch (error) {
    console.error("Error deleting campaign from Instantly:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to delete campaign" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/instantly/campaigns/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import {
  fetchAllInstantlyCampaigns,
  getCampaignAnalytics,
  getInstantlyClient,
  createInstantlyCampaignWithDefaults,
} from "@/lib/instantly";
import type { InstantlyCampaignCreatePayload } from "@/lib/instantly";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - List all campaigns from Instantly
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const includeAnalytics = searchParams.get("analytics") === "true";

    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    const campaigns = await fetchAllInstantlyCampaigns();

    // Only fetch analytics if requested (slower)
    if (includeAnalytics) {
      const analytics = await getCampaignAnalytics();
      const analyticsMap = new Map(analytics.map(a => [a.campaign_id, a]));
      const campaignsWithAnalytics = campaigns.map(campaign => ({
        ...campaign,
        analytics: analyticsMap.get(campaign.id) || null,
      }));
      return NextResponse.json({ campaigns: campaignsWithAnalytics });
    }

    return NextResponse.json({ campaigns });
  } catch (error) {
    console.error("Error fetching Instantly campaigns:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch campaigns" },
      { status: 500 }
    );
  }
}

// POST - Sync campaigns from Instantly to local DB
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { client_id, campaign_ids } = body as {
      client_id: string;
      campaign_ids?: string[];
    };

    if (!client_id) {
      return NextResponse.json(
        { error: "client_id is required" },
        { status: 400 }
      );
    }

    const supabase = getSupabase();

    // Fetch campaigns from Instantly
    const instantlyCampaigns = await fetchAllInstantlyCampaigns();

    // Filter if specific campaign_ids provided
    const campaignsToSync = campaign_ids
      ? instantlyCampaigns.filter(c => campaign_ids.includes(c.id))
      : instantlyCampaigns;

    // Get existing campaigns to avoid duplicates
    const { data: existingCampaigns } = await supabase
      .from("campaigns")
      .select("instantly_campaign_id")
      .not("instantly_campaign_id", "is", null);

    const existingIds = new Set(existingCampaigns?.map(c => c.instantly_campaign_id) || []);

    let imported = 0;
    let skipped = 0;
    const errors: string[] = [];

    for (const campaign of campaignsToSync) {
      if (existingIds.has(campaign.id)) {
        skipped++;
        continue;
      }

      const { error } = await supabase.from("campaigns").insert({
        client_id,
        instantly_campaign_id: campaign.id,
        name: campaign.name,
        is_active: campaign.status === "active",
      });

      if (error) {
        errors.push(`Failed to import ${campaign.name}: ${error.message}`);
      } else {
        imported++;
      }
    }

    return NextResponse.json({
      success: true,
      imported,
      skipped,
      errors: errors.length > 0 ? errors : undefined,
    });
  } catch (error) {
    console.error("Error syncing campaigns:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to sync campaigns" },
      { status: 500 }
    );
  }
}

// PUT - Create a new campaign in Instantly and optionally link to local client
export async function PUT(request: Request) {
  try {
    const body = await request.json();
    const {
      name,
      client_id,
      timezone,
      email_accounts,
      daily_limit,
      stop_on_reply,
      auto_link = true, // Automatically create local campaign record
    } = body as {
      name: string;
      client_id?: string;
      timezone?: string;
      email_accounts?: string[];
      daily_limit?: number;
      stop_on_reply?: boolean;
      auto_link?: boolean;
    };

    if (!name) {
      return NextResponse.json(
        { error: "Campaign name is required" },
        { status: 400 }
      );
    }

    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    // Create campaign in Instantly
    const instantlyCampaign = await createInstantlyCampaignWithDefaults(name, {
      timezone,
      emailAccounts: email_accounts,
      dailyLimit: daily_limit,
      stopOnReply: stop_on_reply,
    });

    // Optionally create local campaign record
    let localCampaign = null;
    if (auto_link && client_id) {
      const supabase = getSupabase();
      const { data, error } = await supabase
        .from("campaigns")
        .insert({
          client_id,
          instantly_campaign_id: instantlyCampaign.id,
          name: instantlyCampaign.name,
          is_active: false, // New campaigns start paused
        })
        .select()
        .single();

      if (error) {
        console.error("Failed to create local campaign record:", error);
      } else {
        localCampaign = data;
      }
    }

    return NextResponse.json({
      success: true,
      instantly_campaign: instantlyCampaign,
      local_campaign: localCampaign,
      webhook_url: localCampaign
        ? `/api/webhooks/instantly/${localCampaign.id}`
        : null,
    });
  } catch (error) {
    console.error("Error creating campaign in Instantly:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to create campaign" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/instantly/refresh-status/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { fetchAllLeadsForCampaign, getInstantlyClient } from "@/lib/instantly";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// POST - One-time refresh of lead status from Instantly
// This updates is_positive_reply, status, and email counts for existing leads
// Does NOT delete any leads - preserves all historical data
export async function POST(request: Request) {
  try {
    const body = await request.json().catch(() => ({}));
    const { client_id } = body as { client_id?: string };

    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    const supabase = getSupabase();

    // Get campaigns to refresh (optionally filtered by client)
    let campaignsQuery = supabase
      .from("campaigns")
      .select("id, name, instantly_campaign_id, client_id")
      .not("instantly_campaign_id", "is", null);

    if (client_id) {
      campaignsQuery = campaignsQuery.eq("client_id", client_id);
    }

    const { data: campaigns, error: campaignsError } = await campaignsQuery;

    if (campaignsError) {
      return NextResponse.json(
        { error: "Failed to fetch campaigns: " + campaignsError.message },
        { status: 500 }
      );
    }

    const results = {
      campaigns_processed: 0,
      leads_updated: 0,
      leads_skipped: 0,
      errors: [] as string[],
    };

    for (const campaign of campaigns || []) {
      if (!campaign.instantly_campaign_id) continue;

      try {
        // Fetch all leads from Instantly for this campaign
        const instantlyLeads = await fetchAllLeadsForCampaign(campaign.instantly_campaign_id);
        results.campaigns_processed++;

        for (const lead of instantlyLeads) {
          // Find the existing lead in our database
          const { data: existingLead } = await supabase
            .from("leads")
            .select("id, status, is_positive_reply")
            .eq("campaign_id", campaign.id)
            .eq("email", lead.email)
            .single();

          if (!existingLead) {
            results.leads_skipped++;
            continue;
          }

          // Extract Instantly data
          const instantlyData = lead as {
            email_reply_count?: number;
            email_open_count?: number;
            email_click_count?: number;
            interest_status?: string;
          };

          // Check if lead has replied
          const hasReplied = (instantlyData.email_reply_count || 0) > 0;

          // Check interest_status for manually tagged leads
          // Only these statuses count as "positive" - not just any reply
          const positiveStatuses = ["interested", "meeting_booked", "meeting_completed", "closed"];
          const hasPositiveInterest = positiveStatuses.includes(lead.interest_status || "");

          // Lead is positive ONLY if tagged as interested/meeting/closed in Instantly
          // Just replying doesn't make it positive (could be negative reply)
          const isPositiveReply = hasPositiveInterest;

          // Determine status based on Instantly data
          let newStatus: string | null = null;
          if (lead.interest_status === "meeting_booked") {
            newStatus = "booked";
          } else if (lead.interest_status === "meeting_completed" || lead.interest_status === "closed") {
            newStatus = "won";
          } else if (lead.interest_status === "not_interested" || lead.interest_status === "wrong_person") {
            newStatus = "not_interested";
          } else if (hasReplied || lead.interest_status === "interested") {
            newStatus = "replied";
          }

          // Build update object - only update fields that have new data
          const updateData: Record<string, unknown> = {
            is_positive_reply: isPositiveReply,
            email_open_count: instantlyData.email_open_count || 0,
            email_click_count: instantlyData.email_click_count || 0,
            email_reply_count: instantlyData.email_reply_count || 0,
          };

          // Only update status if we have a more "advanced" status from Instantly
          // Don't downgrade status (e.g., don't change "won" back to "replied")
          const statusPriority: Record<string, number> = {
            contacted: 0,
            opened: 1,
            clicked: 2,
            replied: 3,
            booked: 4,
            won: 5,
            lost: 5,
            not_interested: 3,
          };

          if (newStatus) {
            const currentPriority = statusPriority[existingLead.status] || 0;
            const newPriority = statusPriority[newStatus] || 0;

            // Only update if new status is higher priority or if current is "contacted"
            if (newPriority > currentPriority || existingLead.status === "contacted") {
              updateData.status = newStatus;
            }
          }

          // Update the lead
          const { error: updateError } = await supabase
            .from("leads")
            .update(updateData)
            .eq("id", existingLead.id);

          if (updateError) {
            results.errors.push(`Failed to update ${lead.email}: ${updateError.message}`);
          } else {
            results.leads_updated++;
          }
        }
      } catch (error) {
        results.errors.push(
          `Failed to process campaign ${campaign.name}: ${error instanceof Error ? error.message : "Unknown error"}`
        );
      }
    }

    return NextResponse.json({
      success: true,
      ...results,
    });
  } catch (error) {
    console.error("Error during status refresh:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Refresh failed" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/leads/[leadId]/workflow/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

interface WorkflowUpdate {
  action: "mark_responded" | "schedule_meeting" | "close_won" | "close_lost" | "update_notes" | "revert_status";
  meeting_at?: string;
  notes?: string;
}

// POST - Update lead workflow status
export async function POST(
  request: Request,
  { params }: { params: Promise<{ leadId: string }> }
) {
  try {
    const { leadId } = await params;
    const body: WorkflowUpdate = await request.json();
    const supabase = getSupabase();

    // Get current lead
    const { data: lead, error: leadError } = await supabase
      .from("leads")
      .select("*")
      .eq("id", leadId)
      .single();

    if (leadError || !lead) {
      return NextResponse.json({ error: "Lead not found" }, { status: 404 });
    }

    const now = new Date().toISOString();
    let updateData: Record<string, unknown> = {};

    switch (body.action) {
      case "mark_responded":
        // Mark that we responded to this lead
        updateData = {
          responded_at: now,
          status: lead.status === "contacted" ? "replied" : lead.status,
        };
        break;

      case "schedule_meeting":
        // Schedule a meeting
        if (!body.meeting_at) {
          return NextResponse.json(
            { error: "meeting_at is required" },
            { status: 400 }
          );
        }
        updateData = {
          meeting_at: body.meeting_at,
          status: "booked",
        };
        break;

      case "close_won":
        // Mark as closed won
        updateData = {
          closed_at: now,
          status: "won",
        };
        break;

      case "close_lost":
        // Mark as closed lost
        updateData = {
          closed_at: now,
          status: "lost",
        };
        break;

      case "update_notes":
        // Just update notes
        updateData = {
          notes: body.notes || null,
        };
        break;

      case "revert_status":
        // Revert to previous status (for mistakes)
        // Determine appropriate status based on what data exists
        if (lead.meeting_at) {
          updateData = { status: "booked", closed_at: null };
        } else if (lead.responded_at || lead.has_replied) {
          updateData = { status: "replied", meeting_at: null, closed_at: null };
        } else {
          updateData = { status: "contacted", responded_at: null, meeting_at: null, closed_at: null };
        }
        break;

      default:
        return NextResponse.json(
          { error: "Invalid action" },
          { status: 400 }
        );
    }

    // Update the lead
    const { data: updatedLead, error: updateError } = await supabase
      .from("leads")
      .update(updateData)
      .eq("id", leadId)
      .select()
      .single();

    if (updateError) {
      console.error("Error updating lead:", updateError);
      return NextResponse.json(
        { error: "Failed to update lead" },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      lead: updatedLead,
    });
  } catch (error) {
    console.error("Error in workflow update:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to update workflow" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/dashboard/[clientId]/page.tsx">
import { createClient } from "@/lib/supabase/server";
import { redirect, notFound } from "next/navigation";
import { getClient } from "@/lib/queries/clients";
import { getCampaigns } from "@/lib/queries/campaigns";
import { getClientStats } from "@/lib/queries/stats";
import { StatsCards } from "@/components/layout/stats-cards";
import { ClientLeadsView } from "./client-leads-view";
import { ClientInfoTooltip } from "./client-info-tooltip";

interface PageProps {
  params: Promise<{ clientId: string }>;
}

export default async function ClientDashboardPage({ params }: PageProps) {
  const { clientId } = await params;
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // Fetch client data
  let client;
  try {
    client = await getClient(supabase, clientId);
  } catch {
    notFound();
  }

  // Fetch campaigns and stats
  const [campaigns, stats] = await Promise.all([
    getCampaigns(supabase, clientId),
    getClientStats(supabase, clientId),
  ]);

  // Fetch leads for all campaigns
  const { data: leads } = await supabase
    .from("leads")
    .select("*, campaigns!inner(client_id, name)")
    .eq("campaigns.client_id", clientId)
    .order("updated_at", { ascending: false });

  // Check if client has intelligence data to show
  const hasIntelligence = client.tam || (client.verticals && client.verticals.length > 0);

  return (
    <div className="space-y-6">
      <div>
        <div className="flex items-center gap-2">
          <h1 className="text-2xl font-bold">{client.name}</h1>
          {hasIntelligence && (
            <ClientInfoTooltip
              tam={client.tam}
              verticals={client.verticals}
            />
          )}
        </div>
        <p className="text-gray-500">
          {campaigns.length} campaign{campaigns.length !== 1 ? "s" : ""} active
        </p>
      </div>

      <StatsCards stats={stats} />

      <ClientLeadsView
        leads={leads || []}
        campaigns={campaigns}
        clientId={clientId}
      />
    </div>
  );
}
</file>

<file path="src/app/dashboard/page.tsx">
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import { getClientsForUser } from "@/lib/queries/clients";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import Link from "next/link";
import { AlertCircle, Building2 } from "lucide-react";

interface DashboardPageProps {
  searchParams: Promise<{ error?: string }>;
}

export default async function DashboardPage({ searchParams }: DashboardPageProps) {
  const params = await searchParams;
  const error = params.error;

  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // Get user profile
  const { data: profile } = await supabase
    .from("profiles")
    .select("*")
    .eq("id", user.id)
    .single();

  const isAdmin = profile?.role === "admin";

  // If admin, redirect them to admin dashboard
  if (isAdmin) {
    redirect("/admin");
  }

  // Get clients for regular users
  const clients = await getClientsForUser(supabase, user.id);

  // If user has only one client, redirect directly to their client page (hip UI)
  if (clients.length === 1) {
    redirect(`/admin/clients/${clients[0].id}`);
  }

  return (
    <div className="max-w-4xl mx-auto">
      <div className="mb-8">
        <h1 className="text-2xl font-bold text-gray-900">Welcome back</h1>
        <p className="text-gray-600 mt-1">Select a client to view their dashboard</p>
      </div>

      {/* Error Message */}
      {error && (
        <div className="mb-6 bg-red-50 border border-red-200 rounded-lg p-4 flex items-start gap-3">
          <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0 mt-0.5" />
          <div>
            <p className="text-sm font-medium text-red-800">Access Error</p>
            <p className="text-sm text-red-700">{error}</p>
          </div>
        </div>
      )}

      {clients.length === 0 ? (
        <Card className="border-dashed">
          <CardContent className="py-12 text-center">
            <div className="w-12 h-12 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <Building2 className="h-6 w-6 text-gray-400" />
            </div>
            <h3 className="text-lg font-medium text-gray-900 mb-2">No client access yet</h3>
            <p className="text-gray-500 max-w-sm mx-auto">
              You haven&apos;t been assigned to any clients. Please contact your administrator to request access.
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {clients.map((client) => (
            <Link key={client.id} href={`/admin/clients/${client.id}`}>
              <Card className="hover:shadow-lg hover:border-blue-200 transition-all cursor-pointer group">
                <CardHeader className="pb-2">
                  <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center group-hover:bg-blue-200 transition-colors">
                      <Building2 className="h-5 w-5 text-blue-600" />
                    </div>
                    <CardTitle className="text-lg">{client.name}</CardTitle>
                  </div>
                </CardHeader>
                <CardContent>
                  <p className="text-sm text-gray-500">View campaigns, leads, and analytics</p>
                </CardContent>
              </Card>
            </Link>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/login/login-client.tsx">
"use client";

import { useState, useEffect } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { createClient } from "@/lib/supabase/client";

export function LoginClient() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const inviteToken = searchParams.get("invite");
  const redirectPath = searchParams.get("redirect");
  const errorParam = searchParams.get("error");

  const [loadingProvider, setLoadingProvider] = useState<"google" | "azure" | null>(null);
  const [checkingSession, setCheckingSession] = useState(true);
  const [message, setMessage] = useState<{ type: "success" | "error"; text: string } | null>(null);

  const getRedirectUrl = () => {
    let redirectUrl = `${window.location.origin}/auth/callback`;
    if (inviteToken) {
      redirectUrl = `${window.location.origin}/auth/accept-invite?token=${inviteToken}`;
    } else if (redirectPath) {
      redirectUrl = `${window.location.origin}/auth/callback?redirect=${encodeURIComponent(redirectPath)}`;
    }
    return redirectUrl;
  };

  useEffect(() => {
    const checkSession = async () => {
      const supabase = createClient();
      const { data: { session } } = await supabase.auth.getSession();

      if (session) {
        if (redirectPath) {
          router.push(redirectPath);
        } else {
          router.push("/dashboard");
        }
      } else {
        setCheckingSession(false);
      }
    };

    checkSession();
  }, [redirectPath, router]);

  useEffect(() => {
    if (errorParam) {
      setMessage({ type: "error", text: errorParam });
      const url = new URL(window.location.href);
      url.searchParams.delete("error");
      window.history.replaceState({}, "", url.toString());
    }
  }, [errorParam]);

  const handleGoogleLogin = async () => {
    setLoadingProvider("google");
    setMessage(null);

    const supabase = createClient();
    const { error } = await supabase.auth.signInWithOAuth({
      provider: "google",
      options: {
        redirectTo: getRedirectUrl(),
      },
    });

    if (error) {
      setMessage({ type: "error", text: error.message });
      setLoadingProvider(null);
    }
  };

  const handleMicrosoftLogin = async () => {
    setLoadingProvider("azure");
    setMessage(null);

    const supabase = createClient();
    const { error } = await supabase.auth.signInWithOAuth({
      provider: "azure",
      options: {
        redirectTo: getRedirectUrl(),
        scopes: "email openid profile",
      },
    });

    if (error) {
      setMessage({ type: "error", text: error.message });
      setLoadingProvider(null);
    }
  };

  if (checkingSession) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-[#050508]">
        <div className="flex flex-col items-center gap-4">
          <div className="w-12 h-12 bg-gradient-to-br from-blue-500 to-cyan-400 rounded-2xl flex items-center justify-center animate-pulse">
            <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce [animation-delay:-0.3s]" />
            <div className="w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce [animation-delay:-0.15s]" />
            <div className="w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce" />
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex bg-[#050508] overflow-hidden">
      {/* Left Panel - Client-focused Value Prop */}
      <div className="hidden lg:flex lg:w-[58%] relative">
        {/* Layered gradient background */}
        <div className="absolute inset-0 bg-gradient-to-br from-[#050508] via-[#0a1628] to-[#050508]" />

        {/* Animated orbs */}
        <div className="absolute top-20 -left-20 w-[600px] h-[600px] bg-blue-600/30 rounded-full blur-[150px] animate-pulse" />
        <div className="absolute bottom-20 right-20 w-[500px] h-[500px] bg-cyan-500/20 rounded-full blur-[130px] animate-pulse [animation-delay:1s]" />
        <div className="absolute top-1/2 left-1/3 w-[400px] h-[400px] bg-indigo-500/15 rounded-full blur-[100px] animate-pulse [animation-delay:2s]" />

        {/* Grid pattern */}
        <div
          className="absolute inset-0 opacity-[0.04]"
          style={{
            backgroundImage: `
              radial-gradient(circle at 1px 1px, rgba(255,255,255,0.15) 1px, transparent 0)
            `,
            backgroundSize: '40px 40px'
          }}
        />

        {/* Floating elements */}
        <div className="absolute top-32 right-32 w-20 h-20 border border-blue-500/20 rounded-2xl rotate-12 animate-float" />
        <div className="absolute bottom-40 left-40 w-16 h-16 border border-cyan-500/20 rounded-xl -rotate-12 animate-float [animation-delay:1s]" />
        <div className="absolute top-1/2 right-20 w-3 h-3 bg-blue-400/40 rounded-full animate-float [animation-delay:0.5s]" />
        <div className="absolute top-40 left-1/3 w-2 h-2 bg-cyan-400/40 rounded-full animate-float [animation-delay:1.5s]" />

        {/* Right edge glow line */}
        <div className="absolute right-0 top-0 bottom-0 w-px bg-gradient-to-b from-transparent via-blue-500/30 to-transparent" />

        {/* Content */}
        <div className="relative z-10 flex flex-col justify-between p-12 xl:p-16 w-full">
          {/* Logo */}
          <div className="flex items-center gap-3 group cursor-pointer">
            <div className="w-12 h-12 bg-gradient-to-br from-blue-500 to-cyan-400 rounded-2xl flex items-center justify-center shadow-lg shadow-blue-500/30 group-hover:shadow-blue-500/50 transition-all duration-300 group-hover:scale-105">
              <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M13 10V3L4 14h7v7l9-11h-7z" />
              </svg>
            </div>
            <span className="text-2xl font-bold text-white tracking-tight">Blue Reach</span>
          </div>

          {/* Main Content */}
          <div className="space-y-12 max-w-xl">
            {/* Headline */}
            <div className="space-y-6">
              <div className="inline-flex items-center gap-2 px-4 py-2 bg-emerald-500/10 border border-emerald-500/20 rounded-full">
                <div className="w-2 h-2 bg-emerald-400 rounded-full animate-pulse" />
                <span className="text-sm text-emerald-300 font-medium">Your client portal is ready</span>
              </div>

              <h1 className="text-5xl xl:text-6xl font-bold text-white leading-[1.08] tracking-tight">
                See your outreach
                <span className="block mt-2 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 via-cyan-400 to-emerald-400">
                  results in real-time
                </span>
              </h1>

              <p className="text-xl text-zinc-400 leading-relaxed max-w-lg">
                Track your email campaigns, monitor lead responses, and see your pipeline grow. Full transparency into your outbound performance.
              </p>
            </div>

            {/* Value Props */}
            <div className="flex items-center gap-6 xl:gap-10">
              {[
                { icon: "M13 10V3L4 14h7v7l9-11h-7z", label: "Live updates" },
                { icon: "M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z", label: "Full visibility" },
                { icon: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z", label: "Secure access" },
              ].map((item, i) => (
                <div key={i} className="flex items-center gap-2 text-zinc-400">
                  <svg className="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={item.icon} />
                  </svg>
                  <span className="text-sm font-medium">{item.label}</span>
                </div>
              ))}
            </div>

            {/* Feature Cards - Client focused */}
            <div className="grid grid-cols-2 gap-4">
              {[
                {
                  icon: "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z",
                  title: "Campaign Performance",
                  desc: "Emails sent, opened & replied",
                  color: "blue"
                },
                {
                  icon: "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z",
                  title: "Lead Responses",
                  desc: "Track interested prospects",
                  color: "cyan"
                },
                {
                  icon: "M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z",
                  title: "Meetings Booked",
                  desc: "See your calendar fill up",
                  color: "indigo"
                },
                {
                  icon: "M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z",
                  title: "Pipeline Value",
                  desc: "Track your deal progress",
                  color: "emerald"
                },
              ].map((feature, i) => (
                <div
                  key={i}
                  className="group p-4 rounded-2xl bg-white/[0.02] border border-white/[0.05] hover:bg-white/[0.04] hover:border-white/[0.1] transition-all duration-300 cursor-pointer"
                >
                  <div className={`w-10 h-10 rounded-xl bg-gradient-to-br ${
                    feature.color === 'blue' ? 'from-blue-500/20 to-blue-600/10' :
                    feature.color === 'cyan' ? 'from-cyan-500/20 to-cyan-600/10' :
                    feature.color === 'indigo' ? 'from-indigo-500/20 to-indigo-600/10' :
                    'from-emerald-500/20 to-emerald-600/10'
                  } flex items-center justify-center mb-3 group-hover:scale-110 transition-transform`}>
                    <svg className={`w-5 h-5 ${
                      feature.color === 'blue' ? 'text-blue-400' :
                      feature.color === 'cyan' ? 'text-cyan-400' :
                      feature.color === 'indigo' ? 'text-indigo-400' :
                      'text-emerald-400'
                    }`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d={feature.icon} />
                    </svg>
                  </div>
                  <h3 className="font-semibold text-white text-sm">{feature.title}</h3>
                  <p className="text-xs text-zinc-500 mt-0.5">{feature.desc}</p>
                </div>
              ))}
            </div>
          </div>

          {/* Footer */}
          <div className="flex items-center justify-between">
            <div className="text-zinc-600 text-sm">
              Powered by Blue Reach
            </div>
            <div className="flex items-center gap-6 text-sm text-zinc-600">
              <a href="#" className="hover:text-zinc-400 transition-colors">Privacy</a>
              <a href="#" className="hover:text-zinc-400 transition-colors">Terms</a>
            </div>
          </div>
        </div>
      </div>

      {/* Right Panel - Login Form */}
      <div className="w-full lg:w-[42%] flex items-center justify-center p-6 sm:p-8 relative">
        {/* Background */}
        <div className="absolute inset-0 bg-gradient-to-br from-zinc-900/80 via-[#0a0a10] to-[#050508]" />

        {/* Subtle glow */}
        <div className="absolute top-1/4 right-1/4 w-[300px] h-[300px] bg-blue-500/5 rounded-full blur-[100px]" />

        {/* Left border accent */}
        <div className="absolute left-0 top-0 bottom-0 w-px bg-gradient-to-b from-transparent via-zinc-700/50 to-transparent hidden lg:block" />

        <div className="relative z-10 w-full max-w-[380px] space-y-8">
          {/* Mobile Logo */}
          <div className="lg:hidden flex flex-col items-center gap-4 mb-8">
            <div className="w-14 h-14 bg-gradient-to-br from-blue-500 to-cyan-400 rounded-2xl flex items-center justify-center shadow-lg shadow-blue-500/30">
              <svg className="w-7 h-7 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M13 10V3L4 14h7v7l9-11h-7z" />
              </svg>
            </div>
            <span className="text-2xl font-bold text-white tracking-tight">Blue Reach</span>
          </div>

          {/* Header */}
          <div className="text-center lg:text-left space-y-3">
            <h2 className="text-3xl sm:text-4xl font-bold text-white tracking-tight">
              {inviteToken ? "You're invited!" : "Welcome back"}
            </h2>
            <p className="text-zinc-400 text-lg">
              {inviteToken
                ? "Sign in to access your outreach dashboard"
                : "Sign in to view your campaign results"
              }
            </p>
          </div>

          {/* Invite Banner */}
          {inviteToken && (
            <div className="relative overflow-hidden bg-gradient-to-r from-emerald-500/10 via-cyan-500/10 to-emerald-500/10 border border-emerald-500/20 rounded-2xl p-5">
              <div className="absolute inset-0 bg-gradient-to-r from-emerald-500/5 to-transparent animate-shimmer" />
              <div className="relative flex items-center gap-4">
                <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-emerald-500/30 to-cyan-500/20 flex items-center justify-center flex-shrink-0">
                  <svg className="w-6 h-6 text-emerald-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                </div>
                <div>
                  <p className="font-semibold text-white">Your dashboard is ready</p>
                  <p className="text-sm text-zinc-400">Sign in to see your campaign performance</p>
                </div>
              </div>
            </div>
          )}

          {/* Error Message */}
          {message && message.type === "error" && (
            <div className="bg-amber-500/10 border border-amber-500/20 rounded-2xl p-4 relative">
              <button
                onClick={() => setMessage(null)}
                className="absolute top-3 right-3 p-1 text-amber-400/60 hover:text-amber-300 transition-colors"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
              <div className="flex items-start gap-3 pr-6">
                <div className="w-10 h-10 rounded-xl bg-amber-500/20 flex items-center justify-center flex-shrink-0 mt-0.5">
                  <svg className="w-5 h-5 text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                  </svg>
                </div>
                <div className="flex-1">
                  <p className="font-medium text-amber-300">Sign in interrupted</p>
                  <p className="text-sm text-amber-200/70 mt-1">
                    {message.text === "Could not authenticate"
                      ? "The sign-in was cancelled or timed out. Please try again."
                      : message.text
                    }
                  </p>
                </div>
              </div>
            </div>
          )}

          {/* Sign In Buttons */}
          <div className="space-y-4">
            {/* Google Button */}
            <button
              onClick={handleGoogleLogin}
              disabled={loadingProvider !== null}
              className="group w-full flex items-center justify-center gap-3 px-6 py-4 bg-white hover:bg-zinc-50 rounded-2xl font-semibold text-zinc-900 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed shadow-xl shadow-black/25 hover:shadow-2xl hover:shadow-blue-500/10 hover:-translate-y-1 active:translate-y-0 active:shadow-lg"
            >
              {loadingProvider === "google" ? (
                <>
                  <div className="w-5 h-5 border-2 border-zinc-300 border-t-zinc-600 rounded-full animate-spin" />
                  <span>Signing in...</span>
                </>
              ) : (
                <>
                  <svg className="w-5 h-5 transition-transform group-hover:scale-110" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" />
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" />
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" />
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" />
                  </svg>
                  <span>Continue with Google</span>
                </>
              )}
            </button>

            {/* Divider */}
            <div className="relative flex items-center gap-4">
              <div className="flex-1 h-px bg-gradient-to-r from-transparent via-zinc-700 to-transparent" />
              <span className="text-xs text-zinc-600 uppercase tracking-wider">or</span>
              <div className="flex-1 h-px bg-gradient-to-r from-transparent via-zinc-700 to-transparent" />
            </div>

            {/* Microsoft Button */}
            <button
              onClick={handleMicrosoftLogin}
              disabled={loadingProvider !== null}
              className="group w-full flex items-center justify-center gap-3 px-6 py-4 bg-zinc-800/80 hover:bg-zinc-700/80 rounded-2xl font-semibold text-white transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed border border-zinc-700/50 hover:border-zinc-600 shadow-lg hover:shadow-xl hover:-translate-y-0.5 active:translate-y-0"
            >
              {loadingProvider === "azure" ? (
                <>
                  <div className="w-5 h-5 border-2 border-zinc-500 border-t-white rounded-full animate-spin" />
                  <span>Signing in...</span>
                </>
              ) : (
                <>
                  <svg className="w-5 h-5 transition-transform group-hover:scale-110" viewBox="0 0 23 23">
                    <path fill="#f35325" d="M1 1h10v10H1z" />
                    <path fill="#81bc06" d="M12 1h10v10H12z" />
                    <path fill="#05a6f0" d="M1 12h10v10H1z" />
                    <path fill="#ffba08" d="M12 12h10v10H12z" />
                  </svg>
                  <span>Continue with Microsoft</span>
                </>
              )}
            </button>
          </div>

          {/* Trust Indicators */}
          <div className="pt-6 space-y-5">
            {/* Security badge */}
            <div className="flex items-center justify-center gap-2">
              <div className="flex items-center gap-2 px-4 py-2 bg-emerald-500/10 border border-emerald-500/20 rounded-full">
                <svg className="w-4 h-4 text-emerald-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
                </svg>
                <span className="text-sm text-emerald-400 font-medium">Secure & Encrypted</span>
              </div>
            </div>

            {/* Trust text */}
            <div className="flex items-center justify-center gap-5 text-xs text-zinc-500">
              <div className="flex items-center gap-1.5">
                <svg className="w-3.5 h-3.5 text-zinc-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                </svg>
                <span>SSL Encrypted</span>
              </div>
              <div className="flex items-center gap-1.5">
                <svg className="w-3.5 h-3.5 text-zinc-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span>Real-time data</span>
              </div>
              <div className="flex items-center gap-1.5">
                <svg className="w-3.5 h-3.5 text-zinc-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
                <span>Always up-to-date</span>
              </div>
            </div>
          </div>

          {/* Footer */}
          <div className="text-center text-xs text-zinc-600 pt-4">
            <p>
              By signing in, you agree to our{" "}
              <a href="#" className="text-zinc-400 hover:text-white transition-colors underline underline-offset-2">Terms of Service</a>
              {" "}and{" "}
              <a href="#" className="text-zinc-400 hover:text-white transition-colors underline underline-offset-2">Privacy Policy</a>
            </p>
          </div>

          {/* Mobile footer */}
          <div className="lg:hidden text-center text-xs text-zinc-600 pt-4">
            Powered by Blue Reach
          </div>
        </div>
      </div>

      {/* Global styles for animations */}
      <style jsx global>{`
        @keyframes float {
          0%, 100% { transform: translateY(0px) rotate(var(--rotate, 12deg)); }
          50% { transform: translateY(-20px) rotate(var(--rotate, 12deg)); }
        }
        @keyframes shimmer {
          0% { transform: translateX(-100%); }
          100% { transform: translateX(100%); }
        }
        .animate-float {
          animation: float 6s ease-in-out infinite;
        }
        .animate-shimmer {
          animation: shimmer 2s ease-in-out infinite;
        }
      `}</style>
    </div>
  );
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src/components/admin/delete-customer-dialog.tsx">
"use client";

import { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { AlertTriangle, Trash2, Users, Mail, BarChart3, CheckCircle2, Shield } from "lucide-react";

interface DeleteCustomerDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  customerName: string;
  onConfirm: () => Promise<void>;
}

export function DeleteCustomerDialog({
  open,
  onOpenChange,
  customerName,
  onConfirm,
}: DeleteCustomerDialogProps) {
  const [confirmText, setConfirmText] = useState("");
  const [isDeleting, setIsDeleting] = useState(false);

  const isConfirmValid = confirmText.toLowerCase() === customerName.toLowerCase();

  const handleConfirm = async () => {
    if (!isConfirmValid) return;

    setIsDeleting(true);
    try {
      await onConfirm();
      onOpenChange(false);
      setConfirmText("");
    } catch (error) {
      console.error("Delete failed:", error);
    } finally {
      setIsDeleting(false);
    }
  };

  const handleClose = () => {
    if (!isDeleting) {
      setConfirmText("");
      onOpenChange(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader className="space-y-4">
          <div className="mx-auto w-14 h-14 rounded-full bg-red-100 dark:bg-red-950 flex items-center justify-center">
            <AlertTriangle className="h-7 w-7 text-red-600 dark:text-red-400" />
          </div>
          <DialogTitle className="text-center text-xl">
            Delete Customer
          </DialogTitle>
          <DialogDescription className="text-center space-y-2">
            <span className="block">
              You are about to permanently delete{" "}
              <span className="font-semibold text-foreground">{customerName}</span>
            </span>
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* What will be preserved */}
          <div className="bg-green-50 dark:bg-green-950/50 border border-green-200 dark:border-green-900 rounded-lg p-4 space-y-3">
            <p className="text-sm font-medium text-green-800 dark:text-green-300 flex items-center gap-2">
              <Shield className="h-4 w-4" />
              Your data is safe
            </p>
            <div className="space-y-2">
              <div className="flex items-center gap-2 text-sm text-green-700 dark:text-green-400">
                <CheckCircle2 className="h-4 w-4" />
                <span>All leads preserved with full history</span>
              </div>
              <div className="flex items-center gap-2 text-sm text-green-700 dark:text-green-400">
                <CheckCircle2 className="h-4 w-4" />
                <span>Positive replies and email threads kept</span>
              </div>
              <div className="flex items-center gap-2 text-sm text-green-700 dark:text-green-400">
                <CheckCircle2 className="h-4 w-4" />
                <span>Analytics and performance data retained</span>
              </div>
            </div>
          </div>

          {/* What will be deleted */}
          <div className="bg-muted/50 border border-border rounded-lg p-4 space-y-3">
            <p className="text-sm font-medium text-muted-foreground">
              Will be removed:
            </p>
            <div className="space-y-2">
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <BarChart3 className="h-4 w-4" />
                <span>Campaign configurations</span>
              </div>
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <Users className="h-4 w-4" />
                <span>Client user access</span>
              </div>
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <Mail className="h-4 w-4" />
                <span>Pending invitations</span>
              </div>
            </div>
          </div>

          {/* Confirmation input */}
          <div className="space-y-2">
            <label className="text-sm text-muted-foreground">
              Type <span className="font-mono font-semibold text-foreground">{customerName}</span> to confirm
            </label>
            <Input
              value={confirmText}
              onChange={(e) => setConfirmText(e.target.value)}
              placeholder="Enter customer name"
              className="font-mono"
              disabled={isDeleting}
            />
          </div>
        </div>

        <DialogFooter className="flex gap-2 sm:gap-2">
          <Button
            variant="outline"
            onClick={handleClose}
            disabled={isDeleting}
            className="flex-1"
          >
            Cancel
          </Button>
          <Button
            variant="destructive"
            onClick={handleConfirm}
            disabled={!isConfirmValid || isDeleting}
            className="flex-1"
          >
            {isDeleting ? (
              <>
                <span className="h-4 w-4 border-2 border-white/30 border-t-white rounded-full animate-spin mr-2" />
                Deleting...
              </>
            ) : (
              <>
                <Trash2 className="h-4 w-4 mr-2" />
                Delete Forever
              </>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/layout/header.tsx">
"use client";

import { createClient } from "@/lib/supabase/client";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { ChevronDown, LogOut, User, LayoutDashboard, Settings } from "lucide-react";

interface HeaderProps {
  email?: string;
  fullName?: string;
  isAdmin?: boolean;
}

export function Header({ email, fullName, isAdmin }: HeaderProps) {
  const router = useRouter();
  const supabase = createClient();

  const handleLogout = async () => {
    await supabase.auth.signOut();
    router.push("/login");
    router.refresh();
  };

  const initials = fullName
    ? fullName
        .split(" ")
        .map((n) => n[0])
        .join("")
        .toUpperCase()
        .slice(0, 2)
    : email?.[0]?.toUpperCase() || "U";

  return (
    <header className="h-16 border-b bg-white px-6 flex items-center justify-between">
      <div className="flex items-center gap-4">
        {isAdmin && (
          <span className="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded-full font-medium">
            Admin
          </span>
        )}
      </div>

      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" className="flex items-center gap-2 h-10">
            <div className="w-8 h-8 rounded-full bg-slate-900 flex items-center justify-center">
              <span className="text-xs font-medium text-white">{initials}</span>
            </div>
            <div className="text-left hidden sm:block">
              <p className="text-sm font-medium text-slate-900">
                {fullName || "User"}
              </p>
              <p className="text-xs text-slate-500">{email}</p>
            </div>
            <ChevronDown className="h-4 w-4 text-slate-400" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end" className="w-56">
          <div className="px-2 py-1.5">
            <p className="text-sm font-medium">{fullName || "User"}</p>
            <p className="text-xs text-slate-500">{email}</p>
          </div>
          <DropdownMenuSeparator />
          {isAdmin ? (
            <DropdownMenuItem asChild>
              <a href="/dashboard" className="flex items-center gap-2">
                <LayoutDashboard className="h-4 w-4" />
                Switch to Client View
              </a>
            </DropdownMenuItem>
          ) : (
            <DropdownMenuItem asChild>
              <a href="/admin" className="flex items-center gap-2">
                <LayoutDashboard className="h-4 w-4" />
                Switch to Admin View
              </a>
            </DropdownMenuItem>
          )}
          <DropdownMenuItem asChild>
            <a href="/profile" className="flex items-center gap-2">
              <User className="h-4 w-4" />
              Profile
            </a>
          </DropdownMenuItem>
          {isAdmin && (
            <DropdownMenuItem asChild>
              <a href="/admin/settings" className="flex items-center gap-2">
                <Settings className="h-4 w-4" />
                Settings
              </a>
            </DropdownMenuItem>
          )}
          <DropdownMenuSeparator />
          <DropdownMenuItem
            onClick={handleLogout}
            className="text-red-600 focus:text-red-600"
          >
            <LogOut className="h-4 w-4 mr-2" />
            Sign out
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </header>
  );
}
</file>

<file path="src/components/leads/lead-table.tsx">
"use client";

import { useState } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { StickyNote } from "lucide-react";
import { LeadDetailPanel } from "./lead-detail-panel";
import type { Lead, LeadStatus } from "@/types/database";

interface LeadTableProps {
  leads: Lead[];
  onStatusChange: (leadId: string, status: LeadStatus) => Promise<void>;
  onNotesChange: (leadId: string, notes: string) => Promise<void>;
}

const statusColors: Record<LeadStatus, string> = {
  contacted: "bg-gray-100 text-gray-700",
  opened: "bg-yellow-100 text-yellow-700",
  clicked: "bg-orange-100 text-orange-700",
  replied: "bg-blue-100 text-blue-700",
  booked: "bg-green-100 text-green-700",
  won: "bg-purple-100 text-purple-700",
  lost: "bg-red-100 text-red-700",
  not_interested: "bg-slate-100 text-slate-700",
};

export function LeadTable({ leads, onStatusChange, onNotesChange }: LeadTableProps) {
  const [selectedLead, setSelectedLead] = useState<Lead | null>(null);
  const [isPanelOpen, setIsPanelOpen] = useState(false);

  const handleRowClick = (lead: Lead) => {
    setSelectedLead(lead);
    setIsPanelOpen(true);
  };

  const handleStatusChange = async (leadId: string, status: LeadStatus) => {
    await onStatusChange(leadId, status);
    if (selectedLead?.id === leadId) {
      setSelectedLead({ ...selectedLead, status });
    }
  };

  const handleNotesChange = async (leadId: string, notes: string) => {
    await onNotesChange(leadId, notes);
    if (selectedLead?.id === leadId) {
      setSelectedLead({ ...selectedLead, notes });
    }
  };

  return (
    <>
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Email</TableHead>
              <TableHead>Name</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Notes</TableHead>
              <TableHead>Last Updated</TableHead>
              <TableHead className="w-[100px]">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {leads.length === 0 ? (
              <TableRow>
                <TableCell colSpan={6} className="text-center text-gray-500 py-8">
                  No leads yet
                </TableCell>
              </TableRow>
            ) : (
              leads.map((lead) => (
                <TableRow
                  key={lead.id}
                  className="cursor-pointer hover:bg-gray-50"
                  onClick={() => handleRowClick(lead)}
                >
                  <TableCell className="font-medium">{lead.email}</TableCell>
                  <TableCell>{lead.first_name || "-"}</TableCell>
                  <TableCell>
                    <Badge className={statusColors[lead.status]}>
                      {lead.status}
                    </Badge>
                  </TableCell>
                  <TableCell className="max-w-[200px]">
                    {lead.notes ? (
                      <div className="flex items-start gap-1.5">
                        <StickyNote className="h-3.5 w-3.5 text-amber-500 shrink-0 mt-0.5" />
                        <span className="text-sm text-muted-foreground line-clamp-2" title={lead.notes}>
                          {lead.notes}
                        </span>
                      </div>
                    ) : (
                      <span className="text-muted-foreground text-sm">-</span>
                    )}
                  </TableCell>
                  <TableCell>
                    {new Date(lead.updated_at).toLocaleDateString()}
                  </TableCell>
                  <TableCell>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleRowClick(lead);
                      }}
                    >
                      View
                    </Button>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      <LeadDetailPanel
        lead={selectedLead}
        open={isPanelOpen}
        onClose={() => setIsPanelOpen(false)}
        onStatusChange={handleStatusChange}
        onNotesChange={handleNotesChange}
      />
    </>
  );
}
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border border-border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="src/lib/instantly/emails.ts">
// Instantly Emails API Functions (Unibox)

import { getInstantlyClient } from "./client";
import type { InstantlyEmail, InstantlyEmailListParams } from "./types";

interface EmailsListResponse {
  items?: InstantlyEmail[];
  data?: InstantlyEmail[];
}

// Fetch emails from Instantly V2 API - GET /emails
export async function fetchInstantlyEmails(
  params?: InstantlyEmailListParams
): Promise<InstantlyEmail[]> {
  const client = getInstantlyClient();

  // Build query params for V2 API
  // Note: V2 API uses 'search' parameter for filtering by lead email
  // 'lead' parameter expects a lead ID, not email address
  const queryParams: Record<string, string | number | boolean | undefined> = {
    limit: params?.limit || 100,
  };

  // Add optional filters
  if (params?.campaign_id) queryParams.campaign_id = params.campaign_id;
  // V2 API uses 'search' parameter to filter by lead email address
  if (params?.lead_email) queryParams.search = params.lead_email;
  if (params?.eaccount) queryParams.eaccount = params.eaccount;
  if (params?.is_unread !== undefined) queryParams.is_unread = params.is_unread;

  console.log("[Instantly] Fetching emails with params:", queryParams);

  const response = await client.get<EmailsListResponse>("/emails", queryParams);

  console.log("[Instantly] Email response:", JSON.stringify(response).slice(0, 500));

  // API may return items or data array or direct array
  if (Array.isArray(response)) {
    return response;
  }
  return response.items || response.data || [];
}

// Fetch all emails for a specific lead, optionally filtered by campaign
export async function fetchEmailsForLead(
  leadEmail: string,
  campaignId?: string
): Promise<InstantlyEmail[]> {
  console.log(`[Instantly] Fetching emails for lead: ${leadEmail}, campaign: ${campaignId || 'all'}`);

  // For now, just do a single request - pagination can be added later if needed
  const emails = await fetchInstantlyEmails({
    lead_email: leadEmail,
    campaign_id: campaignId,
    limit: 100,
  });

  console.log(`[Instantly] Total emails found for ${leadEmail}: ${emails.length}`);

  // Sort by timestamp (oldest first for conversation order)
  return emails.sort((a, b) => {
    const aTime = a.timestamp_email || a.timestamp_created || "";
    const bTime = b.timestamp_email || b.timestamp_created || "";
    return aTime.localeCompare(bTime);
  });
}

// Fetch all emails for a campaign
export async function fetchEmailsForCampaign(campaignId: string): Promise<InstantlyEmail[]> {
  console.log(`[Instantly] Fetching emails for campaign: ${campaignId}`);

  // For now, just do a single request with max limit
  const emails = await fetchInstantlyEmails({
    campaign_id: campaignId,
    limit: 100,
  });

  console.log(`[Instantly] Total emails found for campaign ${campaignId}: ${emails.length}`);
  return emails;
}

// Fetch a single email by ID - V2 API uses GET /emails/{id}
export async function fetchInstantlyEmail(emailId: string): Promise<InstantlyEmail> {
  const client = getInstantlyClient();
  return client.get<InstantlyEmail>(`/emails/${emailId}`);
}

// Mark email thread as read - V2 API uses POST /emails/threads/{id}/mark-as-read
export async function markThreadAsRead(threadId: string): Promise<{ success: boolean }> {
  const client = getInstantlyClient();
  return client.post<{ success: boolean }>(`/emails/threads/${threadId}/mark-as-read`);
}

// Get unread email count - V2 API
export async function getUnreadEmailCount(): Promise<{ count: number }> {
  const client = getInstantlyClient();
  // V2 API may not have a direct endpoint for this - fetch with is_unread filter and count
  const emails = await fetchInstantlyEmails({ is_unread: true, limit: 1 });
  // For now just return a rough count - proper implementation would need API support
  return { count: emails.length > 0 ? 1 : 0 };
}
</file>

<file path="src/lib/instantly/index.ts">
// Instantly API - Main exports

export * from "./types";
export * from "./client";
export * from "./campaigns";
export * from "./leads";
export * from "./accounts";
export * from "./analytics";
export * from "./emails";
</file>

<file path="src/lib/providers/index.ts">
// Provider Factory and Exports
// Central entry point for multi-provider support

import { createClient } from "@supabase/supabase-js";
import type { EmailCampaignProvider, ProviderType } from "./types";
import { ProviderError } from "./types";
import { InstantlyProvider } from "./instantly";
import { SmartleadProvider } from "./smartlead";

// Re-export types
export * from "./types";

// Re-export providers
export { InstantlyProvider } from "./instantly";
export { SmartleadProvider } from "./smartlead";

// ============================================
// PROVIDER FACTORY
// ============================================

/**
 * Create a provider instance with the given API key
 */
export function createProvider(
  providerType: ProviderType,
  apiKey: string
): EmailCampaignProvider {
  switch (providerType) {
    case "instantly":
      return new InstantlyProvider(apiKey);
    case "smartlead":
      return new SmartleadProvider(apiKey);
    case "lemlist":
      throw new ProviderError(
        "Lemlist integration not yet implemented",
        "lemlist"
      );
    case "apollo":
      throw new ProviderError(
        "Apollo integration not yet implemented",
        "apollo"
      );
    default:
      throw new ProviderError(
        `Unsupported provider: ${providerType}`,
        providerType as ProviderType
      );
  }
}

// ============================================
// CAMPAIGN PROVIDER HELPERS
// ============================================

/**
 * Get provider for a specific campaign by fetching its config from database
 */
export async function getProviderForCampaign(
  campaignId: string
): Promise<EmailCampaignProvider> {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseServiceKey) {
    throw new Error("Supabase configuration missing");
  }

  const supabase = createClient(supabaseUrl, supabaseServiceKey);

  const { data: campaign, error } = await supabase
    .from("campaigns")
    .select("provider_type, api_key_encrypted")
    .eq("id", campaignId)
    .single();

  if (error || !campaign) {
    throw new Error(`Campaign not found: ${campaignId}`);
  }

  if (!campaign.api_key_encrypted) {
    throw new Error(
      "Campaign API key not configured. Please add an API key in campaign settings."
    );
  }

  // For now, we store the API key as plain text (api_key_encrypted is the field name)
  // In production, you'd want to decrypt this
  const apiKey = campaign.api_key_encrypted;

  return createProvider(campaign.provider_type as ProviderType, apiKey);
}

/**
 * Get campaign details including provider type
 */
export async function getCampaignWithProvider(
  campaignId: string
): Promise<{
  campaign: {
    id: string;
    provider_type: ProviderType;
    provider_campaign_id: string | null;
    api_key_encrypted: string | null;
    webhook_secret: string | null;
  };
  provider: EmailCampaignProvider | null;
}> {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseServiceKey) {
    throw new Error("Supabase configuration missing");
  }

  const supabase = createClient(supabaseUrl, supabaseServiceKey);

  const { data: campaign, error } = await supabase
    .from("campaigns")
    .select("id, provider_type, provider_campaign_id, api_key_encrypted, webhook_secret")
    .eq("id", campaignId)
    .single();

  if (error || !campaign) {
    throw new Error(`Campaign not found: ${campaignId}`);
  }

  let provider: EmailCampaignProvider | null = null;
  if (campaign.api_key_encrypted) {
    try {
      provider = createProvider(
        campaign.provider_type as ProviderType,
        campaign.api_key_encrypted
      );
    } catch {
      // Provider not available, return null
    }
  }

  return {
    campaign: campaign as {
      id: string;
      provider_type: ProviderType;
      provider_campaign_id: string | null;
      api_key_encrypted: string | null;
      webhook_secret: string | null;
    },
    provider,
  };
}

// ============================================
// VALIDATION HELPERS
// ============================================

/**
 * Validate an API key for a specific provider
 */
export async function validateProviderApiKey(
  providerType: ProviderType,
  apiKey: string
): Promise<boolean> {
  try {
    const provider = createProvider(providerType, apiKey);
    return await provider.validateApiKey();
  } catch {
    return false;
  }
}

/**
 * Get supported providers
 */
export function getSupportedProviders(): { type: ProviderType; name: string; available: boolean }[] {
  return [
    { type: "instantly", name: "Instantly", available: true },
    { type: "smartlead", name: "Smartlead", available: true },
    { type: "lemlist", name: "Lemlist", available: false },
    { type: "apollo", name: "Apollo", available: false },
  ];
}
</file>

<file path="src/lib/supabase/middleware.ts">
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) =>
            request.cookies.set(name, value)
          );
          supabaseResponse = NextResponse.next({
            request,
          });
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          );
        },
      },
    }
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  const pathname = request.nextUrl.pathname;

  // Protected routes
  const isProtectedRoute =
    pathname.startsWith("/dashboard") ||
    pathname.startsWith("/admin");

  if (isProtectedRoute && !user) {
    const url = request.nextUrl.clone();
    url.pathname = "/login";
    url.searchParams.set("redirect", pathname);
    return NextResponse.redirect(url);
  }

  // Admin route protection - check user role and permissions
  if (user && pathname.startsWith("/admin")) {
    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    const isAdmin = profile?.role === "admin";

    // Check if this is a client-specific route that client users can access
    const clientRouteMatch = pathname.match(/^\/admin\/clients\/([a-f0-9-]+)/);

    if (!isAdmin) {
      if (clientRouteMatch) {
        // Client user trying to access a client page - verify they have access
        const clientId = clientRouteMatch[1];
        const { data: clientAccess } = await supabase
          .from("client_users")
          .select("client_id")
          .eq("user_id", user.id)
          .eq("client_id", clientId)
          .single();

        if (!clientAccess) {
          console.log("[Middleware] Client user blocked - no access to client:", clientId);
          const url = request.nextUrl.clone();
          url.pathname = "/dashboard";
          url.searchParams.set("error", "Access denied to this client");
          return NextResponse.redirect(url);
        }
        // Client user has access to this specific client - allow
        console.log("[Middleware] Client user allowed access to client:", clientId);
      } else {
        // Non-admin trying to access other admin routes - block
        console.log("[Middleware] Non-admin user blocked from admin route:", pathname);
        const url = request.nextUrl.clone();
        url.pathname = "/dashboard";
        url.searchParams.set("error", "Access denied");
        return NextResponse.redirect(url);
      }
    }
  }

  // Redirect logged-in users away from login page based on role
  if (pathname === "/login" && user) {
    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    const url = request.nextUrl.clone();
    if (profile?.role === "admin") {
      url.pathname = "/admin";
    } else {
      url.pathname = "/dashboard";
    }
    return NextResponse.redirect(url);
  }

  return supabaseResponse;
}
</file>

<file path="supabase/migrations/20241230_add_email_sequences_and_threads.sql">
-- ============================================
-- Migration: Add Email Sequences and Threads
-- Date: 2024-12-30
-- Purpose: Store campaign email templates and lead email threads
-- ============================================

-- ============================================
-- 1. API PROVIDERS TABLE (for multi-provider support)
-- ============================================
CREATE TABLE IF NOT EXISTS api_providers (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id uuid REFERENCES clients(id) ON DELETE CASCADE,
  provider_type text NOT NULL CHECK (provider_type IN ('instantly', 'smartlead', 'lemlist', 'apollo')),
  api_key text NOT NULL,
  workspace_id text, -- Some providers have workspace concepts
  is_active boolean DEFAULT true,
  label text, -- Optional friendly name like "Main Account", "EU Account"
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(client_id, provider_type, api_key)
);

-- Add index for quick lookups
CREATE INDEX IF NOT EXISTS idx_api_providers_client ON api_providers(client_id);
CREATE INDEX IF NOT EXISTS idx_api_providers_type ON api_providers(provider_type);

-- ============================================
-- 2. UPDATE CAMPAIGNS TABLE
-- ============================================
-- Add provider reference (optional - NULL means use global/default key)
ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS provider_type text DEFAULT 'instantly';
ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS provider_campaign_id text; -- Alias for instantly_campaign_id for multi-provider
ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS original_name text; -- Store original name from provider
ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS last_synced_at timestamptz;
ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS copy_body text; -- Store email copy/body for reference

-- Migrate existing data: copy instantly_campaign_id to provider_campaign_id
UPDATE campaigns
SET provider_campaign_id = instantly_campaign_id,
    original_name = name
WHERE instantly_campaign_id IS NOT NULL AND provider_campaign_id IS NULL;

-- Add index for provider lookups
CREATE INDEX IF NOT EXISTS idx_campaigns_provider ON campaigns(provider_type, provider_campaign_id);

-- ============================================
-- 3. CAMPAIGN SEQUENCES TABLE (Email Templates/Steps)
-- ============================================
CREATE TABLE IF NOT EXISTS campaign_sequences (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  campaign_id uuid NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,

  -- Sequence identification
  sequence_index integer NOT NULL DEFAULT 0, -- 0 = main sequence, 1+ = subsequences
  step_number integer NOT NULL, -- 1, 2, 3... within the sequence
  variant text DEFAULT 'A', -- A, B, C for A/B testing variants

  -- Email content
  subject text,
  body_text text,
  body_html text,

  -- Timing
  delay_days integer DEFAULT 0, -- Days after previous step (0 for first step)
  delay_hours integer DEFAULT 0,
  send_time_start text, -- e.g., "09:00"
  send_time_end text, -- e.g., "17:00"

  -- Metadata
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),

  -- Unique constraint: one step per position per variant
  UNIQUE(campaign_id, sequence_index, step_number, variant)
);

-- Add indexes for quick lookups
CREATE INDEX IF NOT EXISTS idx_campaign_sequences_campaign ON campaign_sequences(campaign_id);
CREATE INDEX IF NOT EXISTS idx_campaign_sequences_step ON campaign_sequences(campaign_id, sequence_index, step_number);

-- ============================================
-- 4. LEAD EMAILS TABLE (Actual Sent/Received Emails)
-- ============================================
CREATE TABLE IF NOT EXISTS lead_emails (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  lead_id uuid NOT NULL REFERENCES leads(id) ON DELETE CASCADE,
  campaign_id uuid REFERENCES campaigns(id) ON DELETE SET NULL,

  -- Provider identification
  provider_email_id text, -- ID from Instantly/Smartlead
  provider_thread_id text, -- Thread ID from provider

  -- Email metadata
  direction text NOT NULL CHECK (direction IN ('outbound', 'inbound')),
  from_email text NOT NULL,
  to_email text NOT NULL,
  cc_emails text[], -- Array of CC addresses
  bcc_emails text[], -- Array of BCC addresses

  -- Email content
  subject text,
  body_text text,
  body_html text,

  -- Tracking
  sequence_step integer, -- Which step in the sequence this was (for outbound)
  is_auto_reply boolean DEFAULT false, -- Auto-reply detection

  -- Timestamps
  sent_at timestamptz,
  opened_at timestamptz,
  clicked_at timestamptz,
  replied_at timestamptz,

  -- Metadata
  raw_headers jsonb,
  metadata jsonb DEFAULT '{}',
  created_at timestamptz DEFAULT now(),

  -- Unique constraint on provider email ID
  UNIQUE(provider_email_id)
);

-- Add indexes for quick lookups
CREATE INDEX IF NOT EXISTS idx_lead_emails_lead ON lead_emails(lead_id);
CREATE INDEX IF NOT EXISTS idx_lead_emails_campaign ON lead_emails(campaign_id);
CREATE INDEX IF NOT EXISTS idx_lead_emails_thread ON lead_emails(provider_thread_id);
CREATE INDEX IF NOT EXISTS idx_lead_emails_sent_at ON lead_emails(sent_at DESC);
CREATE INDEX IF NOT EXISTS idx_lead_emails_direction ON lead_emails(direction);

-- ============================================
-- 5. UPDATE FUNCTIONS
-- ============================================

-- Trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply triggers
DROP TRIGGER IF EXISTS update_api_providers_updated_at ON api_providers;
CREATE TRIGGER update_api_providers_updated_at
    BEFORE UPDATE ON api_providers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_campaign_sequences_updated_at ON campaign_sequences;
CREATE TRIGGER update_campaign_sequences_updated_at
    BEFORE UPDATE ON campaign_sequences
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- 6. ROW LEVEL SECURITY
-- ============================================

-- Enable RLS on new tables
ALTER TABLE api_providers ENABLE ROW LEVEL SECURITY;
ALTER TABLE campaign_sequences ENABLE ROW LEVEL SECURITY;
ALTER TABLE lead_emails ENABLE ROW LEVEL SECURITY;

-- API Providers policies (admin only)
CREATE POLICY "Admin can manage api_providers" ON api_providers
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
    )
  );

-- Campaign Sequences policies
CREATE POLICY "Admin can manage campaign_sequences" ON campaign_sequences
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
    )
  );

CREATE POLICY "Clients can view own campaign_sequences" ON campaign_sequences
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM campaigns c
      JOIN client_users cu ON cu.client_id = c.client_id
      WHERE c.id = campaign_sequences.campaign_id
      AND cu.user_id = auth.uid()
    )
  );

-- Lead Emails policies
CREATE POLICY "Admin can manage lead_emails" ON lead_emails
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
    )
  );

CREATE POLICY "Clients can view own lead_emails" ON lead_emails
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM leads l
      JOIN campaigns c ON c.id = l.campaign_id
      JOIN client_users cu ON cu.client_id = c.client_id
      WHERE l.id = lead_emails.lead_id
      AND cu.user_id = auth.uid()
    )
  );

-- ============================================
-- 7. HELPFUL VIEWS
-- ============================================

-- View: Campaign with sequence count
CREATE OR REPLACE VIEW campaign_with_sequences AS
SELECT
  c.*,
  COUNT(DISTINCT cs.id) as sequence_count,
  COUNT(DISTINCT cs.variant) as variant_count,
  MAX(cs.step_number) as max_steps
FROM campaigns c
LEFT JOIN campaign_sequences cs ON cs.campaign_id = c.id
GROUP BY c.id;

-- View: Lead with email thread summary
CREATE OR REPLACE VIEW lead_email_summary AS
SELECT
  l.id as lead_id,
  l.email as lead_email,
  l.campaign_id,
  COUNT(le.id) as total_emails,
  COUNT(CASE WHEN le.direction = 'outbound' THEN 1 END) as emails_sent,
  COUNT(CASE WHEN le.direction = 'inbound' THEN 1 END) as emails_received,
  MIN(le.sent_at) as first_email_at,
  MAX(le.sent_at) as last_email_at,
  MAX(CASE WHEN le.direction = 'inbound' THEN le.sent_at END) as last_reply_at
FROM leads l
LEFT JOIN lead_emails le ON le.lead_id = l.id
GROUP BY l.id, l.email, l.campaign_id;

-- ============================================
-- 8. COMMENTS FOR DOCUMENTATION
-- ============================================
COMMENT ON TABLE api_providers IS 'Stores API keys for different email providers (Instantly, Smartlead, etc.) per client';
COMMENT ON TABLE campaign_sequences IS 'Stores email template steps and A/B variants for each campaign';
COMMENT ON TABLE lead_emails IS 'Stores the actual email messages sent to and received from leads';

COMMENT ON COLUMN campaigns.provider_campaign_id IS 'The campaign ID from the provider (Instantly, Smartlead, etc.)';
COMMENT ON COLUMN campaigns.original_name IS 'The original campaign name from the provider, preserved for reference';
COMMENT ON COLUMN campaigns.name IS 'User-editable display name, can be changed without breaking provider association';

COMMENT ON COLUMN campaign_sequences.sequence_index IS '0 = main sequence, 1+ = subsequences/follow-ups';
COMMENT ON COLUMN campaign_sequences.variant IS 'A/B testing variant identifier (A, B, C, etc.)';

COMMENT ON COLUMN lead_emails.direction IS 'outbound = sent to lead, inbound = received from lead';
COMMENT ON COLUMN lead_emails.sequence_step IS 'Which step in the campaign sequence this email was (for outbound only)';
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.env.local
</file>

<file path="supabase-schema.sql">
-- Agency Client Portal Database Schema
-- Run this in your Supabase SQL Editor

-- ============================================
-- HELPER FUNCTION: Auto-update updated_at
-- ============================================
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = timezone('utc'::text, now());
  return new;
end;
$$ language plpgsql;

-- ============================================
-- 1. Profiles (Internal users/Clients)
-- ============================================
create table if not exists profiles (
  id uuid references auth.users on delete cascade primary key,
  email text,
  role text check (role in ('admin', 'client')) default 'client',
  full_name text,
  avatar_url text,
  phone text,
  timezone text default 'UTC',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create trigger profiles_updated_at
  before update on profiles
  for each row execute procedure update_updated_at_column();

-- ============================================
-- 2. Clients (The companies you serve)
-- ============================================
create table if not exists clients (
  id uuid default gen_random_uuid() primary key,
  name text not null,
  logo_url text,
  website text,
  notes text,
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create trigger clients_updated_at
  before update on clients
  for each row execute procedure update_updated_at_column();

-- ============================================
-- 3. Campaigns (Linked to Instantly/Smartlead IDs)
-- ============================================
create table if not exists campaigns (
  id uuid default gen_random_uuid() primary key,
  client_id uuid references clients(id) on delete cascade,
  instantly_campaign_id text unique,
  smartlead_campaign_id text unique,
  name text not null,
  copy_body text,
  status text check (status in ('draft', 'active', 'paused', 'completed')) default 'draft',
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create trigger campaigns_updated_at
  before update on campaigns
  for each row execute procedure update_updated_at_column();

-- ============================================
-- 4. Leads (The data your clients interact with)
-- ============================================
create table if not exists leads (
  id uuid default gen_random_uuid() primary key,
  campaign_id uuid references campaigns(id) on delete cascade,
  email text not null,
  first_name text,
  last_name text,
  company_name text,
  phone text,
  website text,
  linkedin_url text,
  job_title text,
  -- Pipeline status (internal tracking)
  status text check (status in ('new', 'contacted', 'replied', 'interested', 'meeting_scheduled', 'meeting_completed', 'proposal_sent', 'won', 'lost', 'unqualified')) default 'new',
  -- Instantly interest status (from email tool)
  interest_status text check (interest_status in ('interested', 'not_interested', 'neutral', 'wrong_person', 'out_of_office')),
  -- External IDs
  instantly_lead_id text,
  smartlead_lead_id text,
  -- Additional data
  lead_data jsonb default '{}'::jsonb,
  notes text,
  -- Email engagement tracking
  emails_sent integer default 0,
  emails_opened integer default 0,
  last_contacted_at timestamp with time zone,
  last_replied_at timestamp with time zone,
  -- Timestamps
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create trigger leads_updated_at
  before update on leads
  for each row execute procedure update_updated_at_column();

-- ============================================
-- 5. Client-User junction table (for multi-tenant access)
-- ============================================
create table if not exists client_users (
  client_id uuid references clients(id) on delete cascade,
  user_id uuid references profiles(id) on delete cascade,
  role text check (role in ('viewer', 'editor', 'owner')) default 'viewer',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (client_id, user_id)
);

-- Create unique constraint for lead upsert (email + campaign_id)
create unique index if not exists leads_campaign_email_unique on leads(campaign_id, email);

-- ============================================
-- 6. Campaign Analytics (Historical metrics from Instantly/Smartlead)
-- ============================================
create table if not exists campaign_analytics (
  id uuid default gen_random_uuid() primary key,
  campaign_id uuid references campaigns(id) on delete cascade not null,
  date date not null,
  -- Email metrics
  emails_sent integer default 0,
  emails_delivered integer default 0,
  emails_opened integer default 0,
  unique_opens integer default 0,
  emails_replied integer default 0,
  emails_bounced integer default 0,
  -- Lead metrics
  new_leads integer default 0,
  leads_contacted integer default 0,
  -- Calculated rates (stored for quick access)
  open_rate numeric(5,2) default 0,
  reply_rate numeric(5,2) default 0,
  bounce_rate numeric(5,2) default 0,
  -- Metadata
  source text check (source in ('instantly', 'smartlead', 'manual')) default 'instantly',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  -- One record per campaign per day
  unique (campaign_id, date)
);

create trigger campaign_analytics_updated_at
  before update on campaign_analytics
  for each row execute procedure update_updated_at_column();

-- ============================================
-- 7. Activity Log (Audit trail)
-- ============================================
create table if not exists activity_log (
  id uuid default gen_random_uuid() primary key,
  -- Who performed the action
  user_id uuid references profiles(id) on delete set null,
  -- What was affected
  entity_type text not null, -- 'lead', 'campaign', 'client', etc.
  entity_id uuid not null,
  -- What happened
  action text not null, -- 'created', 'updated', 'deleted', 'status_changed', etc.
  -- Details of the change
  old_values jsonb,
  new_values jsonb,
  metadata jsonb default '{}'::jsonb,
  -- When it happened
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Index for quick lookups by entity
create index idx_activity_log_entity on activity_log(entity_type, entity_id);
create index idx_activity_log_user on activity_log(user_id);
create index idx_activity_log_created on activity_log(created_at desc);

-- ============================================
-- 8. Email Threads (Optional: Store email history)
-- ============================================
create table if not exists email_threads (
  id uuid default gen_random_uuid() primary key,
  lead_id uuid references leads(id) on delete cascade not null,
  campaign_id uuid references campaigns(id) on delete cascade,
  instantly_thread_id text,
  subject text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create trigger email_threads_updated_at
  before update on email_threads
  for each row execute procedure update_updated_at_column();

create table if not exists emails (
  id uuid default gen_random_uuid() primary key,
  thread_id uuid references email_threads(id) on delete cascade not null,
  instantly_email_id text,
  from_email text not null,
  to_email text not null,
  subject text,
  body_preview text, -- First 500 chars
  is_reply boolean default false,
  is_inbound boolean default false, -- true = from lead, false = from us
  sent_at timestamp with time zone,
  opened_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- ============================================
-- PERFORMANCE INDEXES
-- ============================================
create index if not exists idx_leads_campaign_id on leads(campaign_id);
create index if not exists idx_leads_status on leads(status);
create index if not exists idx_leads_interest_status on leads(interest_status);
create index if not exists idx_leads_created_at on leads(created_at desc);
create index if not exists idx_campaigns_client_id on campaigns(client_id);
create index if not exists idx_campaigns_status on campaigns(status);
create index if not exists idx_client_users_user_id on client_users(user_id);
create index if not exists idx_campaign_analytics_date on campaign_analytics(date desc);
create index if not exists idx_emails_thread_id on emails(thread_id);

-- ============================================
-- ROW LEVEL SECURITY
-- ============================================

-- Enable Row Level Security
alter table profiles enable row level security;
alter table clients enable row level security;
alter table campaigns enable row level security;
alter table leads enable row level security;
alter table client_users enable row level security;
alter table campaign_analytics enable row level security;
alter table activity_log enable row level security;
alter table email_threads enable row level security;
alter table emails enable row level security;

-- RLS Policies

-- Profiles: Users can only read their own profile
create policy "Users can view own profile"
  on profiles for select
  using (auth.uid() = id);

create policy "Users can update own profile"
  on profiles for update
  using (auth.uid() = id);

-- Admins can do anything with profiles
create policy "Admins can manage all profiles"
  on profiles for all
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

-- Clients: Admins see all, users see only linked clients
create policy "Admins can manage all clients"
  on clients for all
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

create policy "Users can view linked clients"
  on clients for select
  using (
    exists (
      select 1 from client_users
      where client_id = clients.id and user_id = auth.uid()
    )
  );

-- Campaigns: Access through client permissions
create policy "Admins can manage all campaigns"
  on campaigns for all
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

create policy "Users can view campaigns of linked clients"
  on campaigns for select
  using (
    exists (
      select 1 from client_users
      where client_id = campaigns.client_id and user_id = auth.uid()
    )
  );

-- Leads: Access through campaign -> client permissions
create policy "Admins can manage all leads"
  on leads for all
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

create policy "Users can view leads of linked clients"
  on leads for select
  using (
    exists (
      select 1 from campaigns c
      join client_users cu on cu.client_id = c.client_id
      where c.id = leads.campaign_id and cu.user_id = auth.uid()
    )
  );

create policy "Users can update leads of linked clients"
  on leads for update
  using (
    exists (
      select 1 from campaigns c
      join client_users cu on cu.client_id = c.client_id
      where c.id = leads.campaign_id and cu.user_id = auth.uid()
    )
  );

-- Client Users: Admins can manage, users can view their own links
create policy "Admins can manage client_users"
  on client_users for all
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

create policy "Users can view own client links"
  on client_users for select
  using (user_id = auth.uid());

-- Campaign Analytics: Access through campaign -> client permissions
create policy "Admins can manage all campaign_analytics"
  on campaign_analytics for all
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

create policy "Users can view analytics of linked clients"
  on campaign_analytics for select
  using (
    exists (
      select 1 from campaigns c
      join client_users cu on cu.client_id = c.client_id
      where c.id = campaign_analytics.campaign_id and cu.user_id = auth.uid()
    )
  );

-- Activity Log: Admins can see all, users can see activity for their clients
create policy "Admins can manage activity_log"
  on activity_log for all
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

create policy "Users can view own activity"
  on activity_log for select
  using (user_id = auth.uid());

-- Email Threads: Access through lead -> campaign -> client permissions
create policy "Admins can manage all email_threads"
  on email_threads for all
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

create policy "Users can view email_threads of linked clients"
  on email_threads for select
  using (
    exists (
      select 1 from leads l
      join campaigns c on c.id = l.campaign_id
      join client_users cu on cu.client_id = c.client_id
      where l.id = email_threads.lead_id and cu.user_id = auth.uid()
    )
  );

-- Emails: Access through thread -> lead -> campaign -> client permissions
create policy "Admins can manage all emails"
  on emails for all
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

create policy "Users can view emails of linked clients"
  on emails for select
  using (
    exists (
      select 1 from email_threads et
      join leads l on l.id = et.lead_id
      join campaigns c on c.id = l.campaign_id
      join client_users cu on cu.client_id = c.client_id
      where et.id = emails.thread_id and cu.user_id = auth.uid()
    )
  );

-- ============================================
-- FUNCTIONS & TRIGGERS
-- ============================================

-- Function to automatically create profile on user signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, role, full_name)
  values (
    new.id,
    new.email,
    'client',
    new.raw_user_meta_data->>'full_name'
  );
  return new;
end;
$$ language plpgsql security definer;

-- Trigger for new user signup
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Add cached analytics columns to campaigns table
ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS cached_emails_sent integer;
ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS cached_emails_bounced integer;
ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS cached_emails_opened integer;
ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS cached_reply_count integer;
ALTER TABLE campaigns ADD COLUMN IF NOT EXISTS cache_updated_at timestamp with time zone;
</file>

<file path="src/app/admin/clients/[clientId]/campaigns/page.tsx">
import { createClient } from "@/lib/supabase/server";
import { notFound } from "next/navigation";
import { getClient } from "@/lib/queries/clients";
import { getCampaigns } from "@/lib/queries/campaigns";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { AddCampaignDialog } from "./add-campaign-dialog";
import { SyncButton } from "./sync-button";
import Link from "next/link";

interface PageProps {
  params: Promise<{ clientId: string }>;
}

export default async function CampaignsPage({ params }: PageProps) {
  const { clientId } = await params;
  const supabase = await createClient();

  let client;
  try {
    client = await getClient(supabase, clientId);
  } catch {
    notFound();
  }

  const campaigns = await getCampaigns(supabase, clientId);

  // Get lead counts for each campaign
  const { data: leadCounts } = await supabase
    .from("leads")
    .select("campaign_id")
    .in(
      "campaign_id",
      campaigns.map((c) => c.id)
    );

  const countByCampaign = leadCounts?.reduce(
    (acc, lead) => {
      acc[lead.campaign_id] = (acc[lead.campaign_id] || 0) + 1;
      return acc;
    },
    {} as Record<string, number>
  );

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <Link
            href="/admin/clients"
            className="text-sm text-blue-600 hover:underline"
          >
            &larr; Back to Clients
          </Link>
          <h1 className="text-2xl font-bold mt-2">{client.name}</h1>
          <p className="text-gray-500">Manage campaigns for this client</p>
        </div>
        <AddCampaignDialog clientId={clientId} />
      </div>

      {campaigns.length === 0 ? (
        <Card>
          <CardContent className="py-8 text-center text-gray-500">
            <p>No campaigns yet. Add a campaign to start receiving leads.</p>
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {campaigns.map((campaign) => (
            <Card key={campaign.id}>
              <CardHeader className="flex flex-row items-start justify-between">
                <div>
                  <CardTitle className="flex items-center gap-2">
                    {campaign.name}
                    <Badge variant={campaign.is_active ? "default" : "secondary"}>
                      {campaign.is_active ? "Active" : "Inactive"}
                    </Badge>
                  </CardTitle>
                  <p className="text-sm text-gray-500 mt-1">
                    {countByCampaign?.[campaign.id] || 0} leads
                  </p>
                </div>
              </CardHeader>
              <CardContent>
                {campaign.instantly_campaign_id && (
                  <div className="mb-3">
                    <p className="text-xs text-gray-500">Instantly Campaign ID</p>
                    <code className="text-xs bg-gray-100 px-2 py-1 rounded">
                      {campaign.instantly_campaign_id}
                    </code>
                  </div>
                )}
                {campaign.copy_body && (
                  <div>
                    <p className="text-xs text-gray-500 mb-1">Email Copy</p>
                    <p className="text-sm text-gray-700 line-clamp-3">
                      {campaign.copy_body}
                    </p>
                  </div>
                )}
                <div className="mt-4 pt-3 border-t">
                  <SyncButton
                    campaignId={campaign.id}
                    leadsCount={countByCampaign?.[campaign.id] || 0}
                    providerLeadsCount={campaign.cached_emails_sent || 0}
                  />
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/clients/[clientId]/campaigns/sync-button.tsx">
"use client";

import { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { RefreshCw, Check, AlertCircle } from "lucide-react";

interface SyncButtonProps {
  campaignId: string;
  leadsCount?: number; // Local leads count from database
  providerLeadsCount?: number; // Leads count from provider (Instantly)
  onSyncComplete?: () => void;
}

// Calculate estimated sync time based on lead count
function estimateSyncTime(leadsCount: number): number {
  if (!leadsCount || leadsCount <= 0) return 30;
  const pages = Math.ceil(leadsCount / 100);
  const batches = Math.ceil(pages / 5); // 5 concurrent
  const apiTime = batches * 1.2; // ~1.2s per batch (including delay)
  const dbTime = leadsCount / 500; // DB insert time estimate
  return Math.ceil(apiTime + dbTime);
}

function formatTime(seconds: number): string {
  if (seconds < 60) return `~${seconds}s`;
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return secs > 0 ? `~${mins}m ${secs}s` : `~${mins}m`;
}

export function SyncButton({ campaignId, leadsCount = 0, providerLeadsCount = 0, onSyncComplete }: SyncButtonProps) {
  const [syncing, setSyncing] = useState(false);
  const [elapsed, setElapsed] = useState(0);
  const [result, setResult] = useState<{
    success: boolean;
    message: string;
  } | null>(null);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  // Use provider count for estimate, fall back to local count
  const estimatedTime = estimateSyncTime(providerLeadsCount || leadsCount);

  // Check if already synced (local count is within 5% of provider count)
  const isAlreadySynced = providerLeadsCount > 0 && leadsCount > 0 &&
    Math.abs(leadsCount - providerLeadsCount) / providerLeadsCount < 0.05;

  // Timer to show elapsed time during sync
  useEffect(() => {
    if (syncing) {
      setElapsed(0);
      timerRef.current = setInterval(() => {
        setElapsed((prev) => prev + 1);
      }, 1000);
    } else {
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
    }
    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, [syncing]);

  const handleSync = async () => {
    setSyncing(true);
    setResult(null);

    try {
      // Add timeout to prevent infinite waiting
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 300000); // 5 min timeout

      const res = await fetch(`/api/campaigns/${campaignId}/sync-leads`, {
        method: "POST",
        signal: controller.signal,
      });
      clearTimeout(timeoutId);

      const data = await res.json();

      if (data.error) {
        setResult({ success: false, message: data.error });
        setSyncing(false);
      } else {
        setResult({
          success: true,
          message: `Synced ${data.inserted} new, ${data.updated} updated`,
        });
        setSyncing(false);
        onSyncComplete?.();
        // Refresh the page to show updated counts
        setTimeout(() => window.location.reload(), 1000);
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        setResult({
          success: false,
          message: "Sync timed out after 5 minutes. Check server logs.",
        });
      } else {
        setResult({
          success: false,
          message: error instanceof Error ? error.message : "Sync failed",
        });
      }
      setSyncing(false);
    }
  };

  const progress = estimatedTime > 0 ? Math.min((elapsed / estimatedTime) * 100, 95) : 0;

  return (
    <div className="flex flex-col gap-2">
      <div className="flex items-center gap-2">
        <Button
          variant="outline"
          size="sm"
          onClick={handleSync}
          disabled={syncing}
        >
          {syncing ? (
            <>
              <RefreshCw className="h-4 w-4 mr-1 animate-spin" />
              Syncing...
            </>
          ) : (
            <>
              <RefreshCw className="h-4 w-4 mr-1" />
              Sync Leads
            </>
          )}
        </Button>
        {!syncing && !result && (
          isAlreadySynced ? (
            <span className="text-xs text-green-600 flex items-center gap-1">
              <Check className="h-3 w-3" />
              Synced ({leadsCount.toLocaleString()} leads)
            </span>
          ) : providerLeadsCount > 0 ? (
            <span className="text-xs text-muted-foreground">
              {providerLeadsCount.toLocaleString()} leads ({formatTime(estimatedTime)})
            </span>
          ) : leadsCount > 0 ? (
            <span className="text-xs text-muted-foreground">
              {leadsCount.toLocaleString()} local leads
            </span>
          ) : null
        )}
        {result && (
          <span
            className={`text-xs flex items-center gap-1 ${
              result.success ? "text-green-600" : "text-red-600"
            }`}
          >
            {result.success ? (
              <Check className="h-3 w-3" />
            ) : (
              <AlertCircle className="h-3 w-3" />
            )}
            {result.message}
          </span>
        )}
      </div>
      {syncing && (
        <div className="flex items-center gap-2">
          <div className="flex-1 h-1.5 bg-muted rounded-full overflow-hidden">
            <div
              className="h-full bg-blue-500 transition-all duration-1000 ease-linear"
              style={{ width: `${progress}%` }}
            />
          </div>
          <span className="text-xs text-muted-foreground min-w-[80px]">
            {elapsed}s / {formatTime(estimatedTime)}
          </span>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/infrastructure/page.tsx">
import { Suspense } from "react";
import { createClient } from "@/lib/supabase/server";
import { InfrastructureView } from "./infrastructure-view";

interface PageProps {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}

async function fetchInfrastructureData(params: Record<string, string | string[] | undefined>) {
  const supabase = await createClient();
  const page = Number(params.page) || 1;
  const limit = 20;
  const offset = (page - 1) * limit;

  // Fetch accounts
  const { data: accounts, count: totalAccounts } = await supabase
    .from("email_accounts")
    .select("*", { count: "exact" })
    .range(offset, offset + limit - 1)
    .order("email");

  // Fetch clients for dropdown
  const { data: clients } = await supabase
    .from("clients")
    .select("id, name, created_at")
    .eq("is_active", true)
    .order("name");

  // Calculate stats
  const { data: allAccounts } = await supabase
    .from("email_accounts")
    .select("status, warmup_reputation, provider_type, client_id");

  const byProvider: Record<string, number> = {};
  const byStatus: Record<string, number> = {};
  let assignedCount = 0;

  (allAccounts || []).forEach((a) => {
    byProvider[a.provider_type] = (byProvider[a.provider_type] || 0) + 1;
    byStatus[a.status] = (byStatus[a.status] || 0) + 1;
    if (a.client_id) assignedCount++;
  });

  const stats = {
    total_accounts: allAccounts?.length || 0,
    by_provider: byProvider,
    by_status: byStatus,
    assigned_accounts: assignedCount,
    unassigned_accounts: (allAccounts?.length || 0) - assignedCount,
    avg_warmup_reputation:
      allAccounts && allAccounts.length > 0
        ? Math.round(
            allAccounts.reduce((sum, a) => sum + (a.warmup_reputation || 0), 0) / allAccounts.length
          )
        : 0,
    domains_count: new Set(accounts?.map((a) => a.domain).filter(Boolean)).size,
    domains_checked: 0,
    domains_healthy: 0,
    domains_issues: 0,
  };

  // Fetch domain health with proper DomainSummary type
  const domains =
    accounts?.map((a) => a.domain).filter((d): d is string => Boolean(d)) || [];
  const uniqueDomains = [...new Set(domains)];

  const { data: domainHealth } = await supabase
    .from("domain_health")
    .select("*")
    .in("domain", uniqueDomains);

  // Build domain summary with proper types
  const domainSummary = (domainHealth || []).map((health) => ({
    ...health,
    account_count: accounts?.filter((a) => a.domain === health.domain).length || 0,
    client_count: 0, // Would need separate query to calculate
  }));

  // Update stats with domain health info
  stats.domains_checked = domainSummary.length;
  stats.domains_healthy = domainSummary.filter((d) => d.health_score >= 80).length;
  stats.domains_issues = domainSummary.filter((d) => d.health_score < 80).length;

  return {
    accounts: accounts || [],
    clients: clients || [],
    stats,
    domains: domainSummary,
    totalAccounts: totalAccounts || 0,
    currentPage: page,
  };
}

export default async function InfrastructurePage({ searchParams }: PageProps) {
  const params = await searchParams;

  // Try to fetch data, provide defaults if tables don't exist yet
  let data;
  try {
    data = await fetchInfrastructureData(params);
  } catch {
    // Tables may not exist yet
    data = {
      accounts: [],
      clients: [],
      stats: {
        total_accounts: 0,
        by_provider: {},
        by_status: {},
        assigned_accounts: 0,
        unassigned_accounts: 0,
        avg_warmup_reputation: 0,
        domains_count: 0,
        domains_checked: 0,
        domains_healthy: 0,
        domains_issues: 0,
      },
      domains: [],
      totalAccounts: 0,
      currentPage: 1,
    };
  }

  return (
    <Suspense fallback={<InfrastructureLoadingSkeleton />}>
      <InfrastructureView
        initialAccounts={data.accounts}
        initialClients={data.clients}
        initialStats={data.stats}
        initialDomains={data.domains}
        totalAccounts={data.totalAccounts}
        currentPage={data.currentPage}
      />
    </Suspense>
  );
}

function InfrastructureLoadingSkeleton() {
  return (
    <div className="space-y-6">
      <div>
        <div className="h-4 w-40 bg-muted animate-pulse rounded mb-2" />
        <div className="h-8 w-64 bg-muted animate-pulse rounded mb-1" />
        <div className="h-4 w-80 bg-muted animate-pulse rounded" />
      </div>

      {/* Stats Cards Skeleton */}
      <div className="grid gap-4 grid-cols-2 lg:grid-cols-4">
        {[1, 2, 3, 4].map((i) => (
          <div key={i} className="border rounded-lg p-6">
            <div className="h-4 w-24 bg-muted animate-pulse rounded mb-2" />
            <div className="h-8 w-16 bg-muted animate-pulse rounded" />
          </div>
        ))}
      </div>

      {/* Table Skeleton */}
      <div className="border rounded-lg">
        <div className="p-4 border-b">
          <div className="h-6 w-40 bg-muted animate-pulse rounded" />
        </div>
        <div className="p-4 space-y-4">
          {[1, 2, 3, 4, 5].map((i) => (
            <div key={i} className="h-12 bg-muted animate-pulse rounded" />
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/admin/leads/admin-leads-view.tsx">
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent } from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { LeadDetailPanel } from "@/components/leads/lead-detail-panel";
import { createClient } from "@/lib/supabase/client";
import {
  Download,
  ChevronDown,
  Search,
  Users,
  ThumbsUp,
  MessageSquare,
  Filter,
  X,
  Mail,
  Building2,
  ChevronLeft,
  ChevronRight,
  CheckCircle2,
} from "lucide-react";
import type { Lead, LeadStatus } from "@/types/database";

interface LeadWithRelations extends Lead {
  client_id?: string | null;
  client_name?: string | null;
  campaign_name?: string | null;
  campaigns: {
    name: string;
    client_id: string;
    clients: { name: string } | null;
  } | null;
}

interface AdminLeadsViewProps {
  leads: LeadWithRelations[];
  clients: Array<{ id: string; name: string }>;
  totalCount: number;
  totalLeads: number;
  positiveCount: number;
  repliedCount: number;
  currentPage: number;
  pageSize: number;
  initialStatus?: string;
  initialClient?: string;
  initialPositive?: boolean;
}

const statusConfig: Record<LeadStatus, { label: string; color: string; icon?: string }> = {
  contacted: { label: "Contacted", color: "bg-slate-100 text-slate-700 dark:bg-slate-800 dark:text-slate-300" },
  opened: { label: "Opened", color: "bg-amber-100 text-amber-700 dark:bg-amber-900 dark:text-amber-300" },
  clicked: { label: "Clicked", color: "bg-orange-100 text-orange-700 dark:bg-orange-900 dark:text-orange-300" },
  replied: { label: "Replied", color: "bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300" },
  booked: { label: "Booked", color: "bg-emerald-100 text-emerald-700 dark:bg-emerald-900 dark:text-emerald-300" },
  won: { label: "Won", color: "bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300" },
  lost: { label: "Lost", color: "bg-red-100 text-red-700 dark:bg-red-900 dark:text-red-300" },
  not_interested: { label: "Not Interested", color: "bg-gray-100 text-gray-600 dark:bg-gray-800 dark:text-gray-400" },
};

export function AdminLeadsView({
  leads,
  clients,
  totalCount,
  totalLeads,
  positiveCount,
  repliedCount,
  currentPage,
  pageSize,
  initialStatus,
  initialClient,
  initialPositive,
}: AdminLeadsViewProps) {
  const [selectedClient, setSelectedClient] = useState<string>(initialClient || "all");
  const [selectedStatus, setSelectedStatus] = useState<string>(initialStatus || "all");
  const [showPositiveOnly, setShowPositiveOnly] = useState<boolean>(initialPositive || false);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedLead, setSelectedLead] = useState<Lead | null>(null);
  const [isPanelOpen, setIsPanelOpen] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [, startTransition] = useTransition();
  const router = useRouter();
  const supabase = createClient();

  const totalPages = Math.ceil(totalCount / pageSize);
  const hasActiveFilters = selectedClient !== "all" || selectedStatus !== "all" || showPositiveOnly;

  const updateFilters = (updates: { client?: string; status?: string; positive?: boolean; page?: number }) => {
    const params = new URLSearchParams();

    const newClient = updates.client !== undefined ? updates.client : selectedClient;
    const newStatus = updates.status !== undefined ? updates.status : selectedStatus;
    const newPositive = updates.positive !== undefined ? updates.positive : showPositiveOnly;
    const newPage = updates.page !== undefined ? updates.page : 1;

    if (newClient && newClient !== "all") params.set("client", newClient);
    if (newStatus && newStatus !== "all") params.set("status", newStatus);
    if (newPositive) params.set("positive", "true");
    if (newPage > 1) params.set("page", String(newPage));

    const queryString = params.toString();
    router.push(`/admin/leads${queryString ? `?${queryString}` : ""}`);
  };

  // Client-side search filter
  const filteredLeads = searchQuery
    ? leads.filter(lead =>
        lead.email?.toLowerCase().includes(searchQuery.toLowerCase()) ||
        lead.first_name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
        lead.last_name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
        lead.company_name?.toLowerCase().includes(searchQuery.toLowerCase())
      )
    : leads;

  const getClientName = (lead: LeadWithRelations) => {
    return lead.campaigns?.clients?.name || lead.client_name || "Unknown";
  };

  const getCampaignName = (lead: LeadWithRelations) => {
    return lead.campaigns?.name || lead.campaign_name || "Unknown";
  };

  const handleExport = async (type: "current" | "positive" | "replied" | "no_response" | "all") => {
    setIsExporting(true);
    try {
      const params = new URLSearchParams();
      params.set("export", type);
      if (type === "current") {
        if (selectedClient !== "all") params.set("client", selectedClient);
        if (selectedStatus !== "all") params.set("status", selectedStatus);
        if (showPositiveOnly) params.set("positive", "true");
      }

      const res = await fetch(`/api/admin/leads/export?${params.toString()}`);
      if (!res.ok) throw new Error("Export failed");

      const blob = await res.blob();
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `${type}_leads_${new Date().toISOString().split("T")[0]}.csv`;
      link.click();
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error("Export error:", error);
      alert("Failed to export. Please try again.");
    } finally {
      setIsExporting(false);
    }
  };

  const handleStatusChange = async (leadId: string, status: LeadStatus) => {
    await supabase
      .from("leads")
      .update({ status, updated_at: new Date().toISOString() })
      .eq("id", leadId);

    if (selectedLead?.id === leadId) {
      setSelectedLead({ ...selectedLead, status });
    }

    startTransition(() => {
      router.refresh();
    });
  };

  const handleNotesChange = async (leadId: string, notes: string) => {
    await supabase
      .from("leads")
      .update({ notes, updated_at: new Date().toISOString() })
      .eq("id", leadId);

    if (selectedLead?.id === leadId) {
      setSelectedLead({ ...selectedLead, notes });
    }

    startTransition(() => {
      router.refresh();
    });
  };

  const clearFilters = () => {
    setSelectedClient("all");
    setSelectedStatus("all");
    setShowPositiveOnly(false);
    setSearchQuery("");
    router.push("/admin/leads");
  };

  return (
    <div className="space-y-6">
      {/* Stats Cards */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <Card className="bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-900 dark:to-slate-800 border-slate-200 dark:border-slate-700">
          <CardContent className="p-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-slate-200 dark:bg-slate-700 rounded-lg">
                <Users className="h-5 w-5 text-slate-600 dark:text-slate-300" />
              </div>
              <div>
                <p className="text-2xl font-bold text-slate-900 dark:text-slate-100">{totalLeads.toLocaleString()}</p>
                <p className="text-xs text-slate-500 dark:text-slate-400">Total Leads</p>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card className="bg-gradient-to-br from-blue-50 to-blue-100 dark:from-blue-950 dark:to-blue-900 border-blue-200 dark:border-blue-800">
          <CardContent className="p-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-blue-200 dark:bg-blue-800 rounded-lg">
                <MessageSquare className="h-5 w-5 text-blue-600 dark:text-blue-300" />
              </div>
              <div>
                <p className="text-2xl font-bold text-blue-900 dark:text-blue-100">{repliedCount.toLocaleString()}</p>
                <p className="text-xs text-blue-600 dark:text-blue-400">Replied</p>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card className="bg-gradient-to-br from-green-50 to-green-100 dark:from-green-950 dark:to-green-900 border-green-200 dark:border-green-800">
          <CardContent className="p-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-green-200 dark:bg-green-800 rounded-lg">
                <ThumbsUp className="h-5 w-5 text-green-600 dark:text-green-300" />
              </div>
              <div>
                <p className="text-2xl font-bold text-green-900 dark:text-green-100">{positiveCount.toLocaleString()}</p>
                <p className="text-xs text-green-600 dark:text-green-400">Positive Replies</p>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card className="bg-gradient-to-br from-purple-50 to-purple-100 dark:from-purple-950 dark:to-purple-900 border-purple-200 dark:border-purple-800">
          <CardContent className="p-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-purple-200 dark:bg-purple-800 rounded-lg">
                <CheckCircle2 className="h-5 w-5 text-purple-600 dark:text-purple-300" />
              </div>
              <div>
                <p className="text-2xl font-bold text-purple-900 dark:text-purple-100">
                  {totalLeads > 0 ? ((positiveCount / totalLeads) * 100).toFixed(1) : 0}%
                </p>
                <p className="text-xs text-purple-600 dark:text-purple-400">Conversion Rate</p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Filters Row */}
      <div className="flex flex-col sm:flex-row gap-4">
        {/* Search */}
        <div className="relative flex-1 max-w-md">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search by email, name, or company..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-9"
          />
        </div>

        {/* Filters */}
        <div className="flex flex-wrap items-center gap-2">
          <div className="flex items-center gap-1 text-sm text-muted-foreground">
            <Filter className="h-4 w-4" />
            <span className="hidden sm:inline">Filters:</span>
          </div>

          <Select
            value={selectedClient}
            onValueChange={(value) => {
              setSelectedClient(value);
              updateFilters({ client: value });
            }}
          >
            <SelectTrigger className="w-[160px] h-9">
              <SelectValue placeholder="All Clients" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Clients</SelectItem>
              {clients.map((client) => (
                <SelectItem key={client.id} value={client.id}>
                  {client.name}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Select
            value={selectedStatus}
            onValueChange={(value) => {
              setSelectedStatus(value);
              updateFilters({ status: value });
            }}
          >
            <SelectTrigger className="w-[150px] h-9">
              <SelectValue placeholder="All Statuses" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Statuses</SelectItem>
              {Object.entries(statusConfig).map(([key, config]) => (
                <SelectItem key={key} value={key}>
                  {config.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Button
            variant={showPositiveOnly ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setShowPositiveOnly(!showPositiveOnly);
              updateFilters({ positive: !showPositiveOnly });
            }}
            className={showPositiveOnly ? "bg-green-600 hover:bg-green-700" : ""}
          >
            <ThumbsUp className="h-4 w-4 mr-1" />
            Positive Only
          </Button>

          {hasActiveFilters && (
            <Button
              variant="ghost"
              size="sm"
              onClick={clearFilters}
              className="text-muted-foreground hover:text-foreground"
            >
              <X className="h-4 w-4 mr-1" />
              Clear
            </Button>
          )}
        </div>

        {/* Export Button */}
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="outline" size="sm" disabled={isExporting} className="ml-auto">
              <Download className="h-4 w-4 mr-2" />
              {isExporting ? "Exporting..." : "Export"}
              <ChevronDown className="h-4 w-4 ml-1" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end" className="w-56">
            <DropdownMenuItem onClick={() => handleExport("current")}>
              <span className="flex-1">Current View</span>
              <span className="text-muted-foreground text-xs">{totalCount.toLocaleString()}</span>
            </DropdownMenuItem>
            <DropdownMenuItem onClick={() => handleExport("positive")}>
              <span className="flex-1">Positive Replies</span>
              <span className="text-muted-foreground text-xs">{positiveCount.toLocaleString()}</span>
            </DropdownMenuItem>
            <DropdownMenuItem onClick={() => handleExport("replied")}>
              <span className="flex-1">All Replies</span>
              <span className="text-muted-foreground text-xs">{repliedCount.toLocaleString()}</span>
            </DropdownMenuItem>
            <DropdownMenuItem onClick={() => handleExport("all")}>
              <span className="flex-1">All Leads</span>
              <span className="text-muted-foreground text-xs">{totalLeads.toLocaleString()}</span>
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </div>

      {/* Results Count */}
      <div className="flex items-center justify-between text-sm">
        <p className="text-muted-foreground">
          Showing <span className="font-medium text-foreground">{filteredLeads.length}</span> of{" "}
          <span className="font-medium text-foreground">{totalCount.toLocaleString()}</span> leads
          {searchQuery && " (filtered by search)"}
        </p>
        {totalPages > 1 && (
          <p className="text-muted-foreground">
            Page {currentPage} of {totalPages}
          </p>
        )}
      </div>

      {/* Table */}
      <div className="rounded-lg border bg-card overflow-hidden">
        <Table>
          <TableHeader>
            <TableRow className="bg-muted/50 hover:bg-muted/50">
              <TableHead className="font-semibold">Lead</TableHead>
              <TableHead className="font-semibold">Client</TableHead>
              <TableHead className="font-semibold hidden lg:table-cell">Campaign</TableHead>
              <TableHead className="font-semibold">Status</TableHead>
              <TableHead className="font-semibold text-center">Positive</TableHead>
              <TableHead className="font-semibold text-right">Updated</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredLeads.length === 0 ? (
              <TableRow>
                <TableCell colSpan={6} className="text-center py-12">
                  <div className="flex flex-col items-center gap-2 text-muted-foreground">
                    <Users className="h-8 w-8 opacity-50" />
                    <p>No leads found</p>
                    {hasActiveFilters && (
                      <Button variant="link" size="sm" onClick={clearFilters}>
                        Clear filters
                      </Button>
                    )}
                  </div>
                </TableCell>
              </TableRow>
            ) : (
              filteredLeads.map((lead) => (
                <TableRow
                  key={lead.id}
                  className="cursor-pointer hover:bg-muted/50 transition-colors"
                  onClick={() => {
                    setSelectedLead(lead);
                    setIsPanelOpen(true);
                  }}
                >
                  <TableCell>
                    <div className="flex items-center gap-3">
                      <div className="w-9 h-9 rounded-full bg-primary/10 flex items-center justify-center shrink-0">
                        <Mail className="h-4 w-4 text-primary" />
                      </div>
                      <div className="min-w-0">
                        <p className="font-medium truncate max-w-[200px] sm:max-w-[280px]" title={lead.email}>
                          {lead.email}
                        </p>
                        {(lead.first_name || lead.company_name) && (
                          <p className="text-xs text-muted-foreground truncate max-w-[200px] sm:max-w-[280px]">
                            {lead.first_name && lead.last_name
                              ? `${lead.first_name} ${lead.last_name}`
                              : lead.first_name}
                            {lead.first_name && lead.company_name && "  "}
                            {lead.company_name}
                          </p>
                        )}
                      </div>
                    </div>
                  </TableCell>
                  <TableCell>
                    <div className="flex items-center gap-2">
                      <Building2 className="h-4 w-4 text-muted-foreground shrink-0" />
                      <span className="truncate max-w-[120px]" title={getClientName(lead)}>
                        {getClientName(lead)}
                      </span>
                    </div>
                  </TableCell>
                  <TableCell className="hidden lg:table-cell">
                    <span className="text-sm text-muted-foreground truncate block max-w-[200px]" title={getCampaignName(lead)}>
                      {getCampaignName(lead)}
                    </span>
                  </TableCell>
                  <TableCell>
                    <Badge className={`${statusConfig[lead.status]?.color || "bg-gray-100"} font-medium`}>
                      {statusConfig[lead.status]?.label || lead.status}
                    </Badge>
                  </TableCell>
                  <TableCell className="text-center">
                    {lead.is_positive_reply ? (
                      <div className="inline-flex items-center justify-center w-7 h-7 rounded-full bg-green-100 dark:bg-green-900">
                        <ThumbsUp className="h-4 w-4 text-green-600 dark:text-green-400" />
                      </div>
                    ) : (
                      <span className="text-muted-foreground">-</span>
                    )}
                  </TableCell>
                  <TableCell className="text-right text-sm text-muted-foreground">
                    {new Date(lead.updated_at).toLocaleDateString()}
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between">
          <p className="text-sm text-muted-foreground">
            Showing {(currentPage - 1) * pageSize + 1}-{Math.min(currentPage * pageSize, totalCount)} of {totalCount.toLocaleString()}
          </p>
          <div className="flex items-center gap-1">
            <Button
              variant="outline"
              size="sm"
              disabled={currentPage <= 1}
              onClick={() => updateFilters({ page: currentPage - 1 })}
            >
              <ChevronLeft className="h-4 w-4" />
              <span className="hidden sm:inline ml-1">Previous</span>
            </Button>

            {/* Page numbers */}
            <div className="hidden sm:flex items-center gap-1">
              {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                let pageNum: number;
                if (totalPages <= 5) {
                  pageNum = i + 1;
                } else if (currentPage <= 3) {
                  pageNum = i + 1;
                } else if (currentPage >= totalPages - 2) {
                  pageNum = totalPages - 4 + i;
                } else {
                  pageNum = currentPage - 2 + i;
                }

                return (
                  <Button
                    key={pageNum}
                    variant={pageNum === currentPage ? "default" : "outline"}
                    size="sm"
                    className="w-9"
                    onClick={() => updateFilters({ page: pageNum })}
                  >
                    {pageNum}
                  </Button>
                );
              })}
            </div>

            {/* Mobile: current page indicator */}
            <span className="sm:hidden text-sm text-muted-foreground px-2">
              {currentPage} / {totalPages}
            </span>

            <Button
              variant="outline"
              size="sm"
              disabled={currentPage >= totalPages}
              onClick={() => updateFilters({ page: currentPage + 1 })}
            >
              <span className="hidden sm:inline mr-1">Next</span>
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )}

      <LeadDetailPanel
        lead={selectedLead}
        open={isPanelOpen}
        onClose={() => setIsPanelOpen(false)}
        onStatusChange={handleStatusChange}
        onNotesChange={handleNotesChange}
      />
    </div>
  );
}
</file>

<file path="src/app/admin/layout.tsx">
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import Link from "next/link";
import Image from "next/image";
import { ThemeToggle } from "@/components/theme-toggle";

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // Check if user is admin and get profile info
  const { data: profile } = await supabase
    .from("profiles")
    .select("role, full_name")
    .eq("id", user.id)
    .single();

  const isAdmin = profile?.role === "admin";

  // Non-admins can only access their specific client pages
  // The middleware handles the detailed access control

  return (
    <div className="min-h-screen bg-background">
      {/* Simple top nav */}
      <header className="bg-card border-b border-border sticky top-0 z-10">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex items-center justify-between h-16">
            <Link href="/admin" className="flex items-center gap-2">
              <Image
                src="/logo.png"
                alt="BlueReach"
                width={140}
                height={40}
                className="h-8 w-auto"
                priority
              />
            </Link>
            <div className="flex items-center gap-4">
              <ThemeToggle />
              <span className="text-sm text-muted-foreground">{user.email}</span>
              <form action="/auth/signout" method="post">
                <button
                  type="submit"
                  className="text-sm text-muted-foreground hover:text-foreground"
                >
                  Sign out
                </button>
              </form>
            </div>
          </div>
        </div>
      </header>
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {children}
      </main>
    </div>
  );
}
</file>

<file path="src/app/api/admin/analytics/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// Helper to get date range based on period
function getDateRange(period: string): { startDate: Date; endDate: Date } | null {
  if (period === "all_time") {
    return null; // No date filtering
  }

  const now = new Date();
  const endDate = new Date(now);
  endDate.setHours(23, 59, 59, 999);

  let startDate: Date;

  switch (period) {
    case "this_week": {
      // Start of current week (Monday)
      startDate = new Date(now);
      const day = startDate.getDay();
      const diff = startDate.getDate() - day + (day === 0 ? -6 : 1);
      startDate.setDate(diff);
      startDate.setHours(0, 0, 0, 0);
      break;
    }
    case "this_month": {
      // Start of current month
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      startDate.setHours(0, 0, 0, 0);
      break;
    }
    case "this_quarter": {
      // Start of current quarter
      const quarter = Math.floor(now.getMonth() / 3);
      startDate = new Date(now.getFullYear(), quarter * 3, 1);
      startDate.setHours(0, 0, 0, 0);
      break;
    }
    default:
      return null; // Default to all time
  }

  return { startDate, endDate };
}

// GET - Get analytics from database
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const period = searchParams.get("period") || "all_time";

    const supabase = getSupabase();
    const dateRange = getDateRange(period);

    // Build query for total leads (contacted)
    let leadsQuery = supabase.from("leads").select("*", { count: "exact", head: true });

    // Build query for replies - simple boolean check
    let repliesQuery = supabase
      .from("leads")
      .select("*", { count: "exact", head: true })
      .eq("has_replied", true);

    // Build query for positive replies
    let positiveQuery = supabase.from("leads").select("*", { count: "exact", head: true }).eq("is_positive_reply", true);

    // Apply date filter if not all_time
    if (dateRange) {
      const startDateStr = dateRange.startDate.toISOString();
      const endDateStr = dateRange.endDate.toISOString();

      leadsQuery = leadsQuery.gte("created_at", startDateStr).lte("created_at", endDateStr);
      repliesQuery = repliesQuery.gte("created_at", startDateStr).lte("created_at", endDateStr);
      positiveQuery = positiveQuery.gte("created_at", startDateStr).lte("created_at", endDateStr);
    }

    // Execute all queries in parallel
    const [leadsResult, repliesResult, positiveResult] = await Promise.all([
      leadsQuery,
      repliesQuery,
      positiveQuery,
    ]);

    const leadsContacted = leadsResult.count || 0;
    const replies = repliesResult.count || 0;
    const opportunities = positiveResult.count || 0;

    // For emails sent, we'll use leads contacted as a proxy
    // (each lead represents at least one email sent)
    // Could also sum email counts if you want total emails including follow-ups
    const emailsSent = leadsContacted;

    // Calculate reply rate
    const replyRate = leadsContacted > 0 ? (replies / leadsContacted) * 100 : 0;

    return NextResponse.json({
      period,
      start_date: dateRange?.startDate.toISOString().split("T")[0] || null,
      end_date: dateRange?.endDate.toISOString().split("T")[0] || null,
      leads_contacted: leadsContacted,
      emails_sent: emailsSent,
      replies,
      opportunities,
      reply_rate: Number(replyRate.toFixed(2)),
    });
  } catch (error) {
    console.error("Error fetching analytics:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch analytics" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/admin/customers/[customerId]/route.ts">
import { createClient } from "@/lib/supabase/server";
import { createClient as createServiceClient } from "@supabase/supabase-js";
import { NextResponse } from "next/server";

// Service role client for operations that bypass RLS
function getServiceSupabase() {
  return createServiceClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

export async function GET(
  request: Request,
  { params }: { params: Promise<{ customerId: string }> }
) {
  try {
    const { customerId } = await params;
    const supabase = await createClient();

    // Verify admin access
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    if (profile?.role !== "admin") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const { data: client, error } = await supabase
      .from("clients")
      .select(`
        *,
        campaigns(*)
      `)
      .eq("id", customerId)
      .single();

    if (error) {
      return NextResponse.json({ error: "Customer not found" }, { status: 404 });
    }

    return NextResponse.json({ customer: client });
  } catch (error) {
    console.error("Error in customer GET:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

export async function PATCH(
  request: Request,
  { params }: { params: Promise<{ customerId: string }> }
) {
  try {
    const { customerId } = await params;
    const supabase = await createClient();

    // Verify admin access
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    if (profile?.role !== "admin") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const body = await request.json();
    const updates: Record<string, unknown> = {};

    if (typeof body.name === "string") {
      updates.name = body.name.trim();
    }
    if (typeof body.is_active === "boolean") {
      updates.is_active = body.is_active;
    }
    if (typeof body.website === "string") {
      updates.website = body.website;
    }
    if (typeof body.notes === "string") {
      updates.notes = body.notes;
    }

    if (Object.keys(updates).length === 0) {
      return NextResponse.json(
        { error: "No valid fields to update" },
        { status: 400 }
      );
    }

    const { data: client, error } = await supabase
      .from("clients")
      .update(updates)
      .eq("id", customerId)
      .select()
      .single();

    if (error) {
      console.error("Error updating client:", error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ customer: client });
  } catch (error) {
    console.error("Error in customer PATCH:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ customerId: string }> }
) {
  try {
    const { customerId } = await params;
    const supabase = await createClient();

    // Verify admin access
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    if (profile?.role !== "admin") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // Use service role client for cleanup operations
    const serviceSupabase = getServiceSupabase();

    // Get all users linked to this client
    const { data: clientUsers } = await serviceSupabase
      .from("client_users")
      .select("user_id")
      .eq("client_id", customerId);

    // For each linked user, check if they're linked to other clients
    // If not, delete their profile (they only had access to this client)
    if (clientUsers && clientUsers.length > 0) {
      for (const clientUser of clientUsers) {
        const { data: otherLinks } = await serviceSupabase
          .from("client_users")
          .select("client_id")
          .eq("user_id", clientUser.user_id)
          .neq("client_id", customerId);

        // If user is not linked to any other client, delete their profile
        if (!otherLinks || otherLinks.length === 0) {
          // Check if this user is an admin - don't delete admin profiles
          const { data: userProfile } = await serviceSupabase
            .from("profiles")
            .select("role")
            .eq("id", clientUser.user_id)
            .single();

          if (userProfile?.role !== "admin") {
            console.log(`[Customer Delete] Deleting profile for user: ${clientUser.user_id}`);

            // Delete the profile
            await serviceSupabase
              .from("profiles")
              .delete()
              .eq("id", clientUser.user_id);

            // Delete the auth user (requires admin API)
            await serviceSupabase.auth.admin.deleteUser(clientUser.user_id);
          }
        }
      }
    }

    // Delete client invitations
    await serviceSupabase
      .from("client_invitations")
      .delete()
      .eq("client_id", customerId);

    // Get all campaigns for this client
    const { data: campaigns } = await serviceSupabase
      .from("campaigns")
      .select("id")
      .eq("client_id", customerId);

    // PRESERVE LEADS: Unlink leads from campaigns (set campaign_id to NULL)
    // The denormalized fields (client_id, client_name, campaign_name) are preserved
    if (campaigns && campaigns.length > 0) {
      const campaignIds = campaigns.map(c => c.id);

      console.log(`[Customer Delete] Preserving leads for ${campaignIds.length} campaigns`);

      // Unlink leads from campaigns - they keep their denormalized data
      await serviceSupabase
        .from("leads")
        .update({ campaign_id: null })
        .in("campaign_id", campaignIds);

      // Delete lead_emails campaign reference (preserve the emails themselves)
      await serviceSupabase
        .from("lead_emails")
        .update({ campaign_id: null })
        .in("campaign_id", campaignIds);

      // Delete campaign sequences
      await serviceSupabase
        .from("campaign_sequences")
        .delete()
        .in("campaign_id", campaignIds);

      // Delete campaigns
      await serviceSupabase
        .from("campaigns")
        .delete()
        .eq("client_id", customerId);
    }

    // Delete client_users links
    await serviceSupabase
      .from("client_users")
      .delete()
      .eq("client_id", customerId);

    // Delete the client
    const { error } = await serviceSupabase
      .from("clients")
      .delete()
      .eq("id", customerId);

    if (error) {
      console.error("Error deleting client:", error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error in customer DELETE:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/campaigns/[campaignId]/details/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { getProviderForCampaign } from "@/lib/providers";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

interface RouteParams {
  params: Promise<{ campaignId: string }>;
}

// Check if cache is stale (older than 1 hour)
function isCacheStale(cacheUpdatedAt: string | null): boolean {
  if (!cacheUpdatedAt) return true;
  const cacheTime = new Date(cacheUpdatedAt).getTime();
  const oneHourAgo = Date.now() - 60 * 60 * 1000;
  return cacheTime < oneHourAgo;
}

// GET - Get campaign details with analytics (CACHE-FIRST approach)
export async function GET(request: Request, { params }: RouteParams) {
  try {
    const { campaignId } = await params;
    const { searchParams } = new URL(request.url);
    const forceRefresh = searchParams.get("refresh") === "true";

    const supabase = getSupabase();

    // Get campaign from local DB
    const { data: campaign, error } = await supabase
      .from("campaigns")
      .select("*")
      .eq("id", campaignId)
      .single();

    if (error || !campaign) {
      return NextResponse.json(
        { error: "Campaign not found" },
        { status: 404 }
      );
    }

    // Build analytics from cached values (ALWAYS read from cache first)
    const hasCachedData = campaign.cached_emails_sent !== null;
    let analytics = hasCachedData ? {
      emails_sent: campaign.cached_emails_sent || 0,
      emails_opened: campaign.cached_emails_opened || 0,
      emails_replied: campaign.cached_reply_count || 0,
      emails_bounced: campaign.cached_emails_bounced || 0,
      open_rate:
        campaign.cached_emails_sent > 0
          ? (campaign.cached_emails_opened || 0) / campaign.cached_emails_sent
          : 0,
      reply_rate:
        campaign.cached_emails_sent > 0
          ? (campaign.cached_reply_count || 0) / campaign.cached_emails_sent
          : 0,
      bounce_rate:
        campaign.cached_emails_sent > 0
          ? (campaign.cached_emails_bounced || 0) / campaign.cached_emails_sent
          : 0,
      leads_count: campaign.cached_emails_sent || 0, // Fallback estimate
      contacted_count: campaign.cached_emails_sent || 0,
      total_opportunities: campaign.cached_positive_count || 0,
    } : null;

    // Get accurate leads_count from database
    const { count: leadsCount } = await supabase
      .from("leads")
      .select("*", { count: "exact", head: true })
      .eq("campaign_id", campaignId);

    if (analytics) {
      analytics.leads_count = leadsCount || 0;
    }

    let updatedCampaign = campaign;
    const providerCampaignId = campaign.provider_campaign_id || campaign.instantly_campaign_id;
    const shouldRefresh = forceRefresh || isCacheStale(campaign.cache_updated_at);

    // Only fetch from provider if cache is stale or forced refresh
    if (providerCampaignId && shouldRefresh) {
      try {
        const provider = await getProviderForCampaign(campaignId);

        // Fetch campaign status from provider
        try {
          const providerCampaign = await provider.fetchCampaign(providerCampaignId);
          const isActive = providerCampaign.status === "active";

          // Update local DB if status changed
          if (campaign.is_active !== isActive) {
            const { data: updated } = await supabase
              .from("campaigns")
              .update({ is_active: isActive })
              .eq("id", campaignId)
              .select()
              .single();

            if (updated) {
              updatedCampaign = updated;
            }
          }
        } catch (e) {
          console.error("Failed to fetch campaign status:", e);
        }

        // Fetch analytics from provider and update cache
        try {
          const providerAnalytics = await provider.fetchCampaignAnalytics(providerCampaignId);

          analytics = {
            emails_sent: providerAnalytics.emailsSentCount || 0,
            emails_opened: providerAnalytics.openCountUnique || 0,
            emails_replied: providerAnalytics.replyCount || 0,
            emails_bounced: providerAnalytics.bouncedCount || 0,
            open_rate:
              providerAnalytics.emailsSentCount > 0
                ? (providerAnalytics.openCountUnique || 0) / providerAnalytics.emailsSentCount
                : 0,
            reply_rate:
              providerAnalytics.emailsSentCount > 0
                ? (providerAnalytics.replyCount || 0) / providerAnalytics.emailsSentCount
                : 0,
            bounce_rate:
              providerAnalytics.emailsSentCount > 0
                ? (providerAnalytics.bouncedCount || 0) / providerAnalytics.emailsSentCount
                : 0,
            leads_count: providerAnalytics.leadsCount || leadsCount || 0,
            contacted_count: providerAnalytics.contactedCount || 0,
            total_opportunities: providerAnalytics.totalOpportunities || 0,
          };

          // Update cache in database
          await supabase
            .from("campaigns")
            .update({
              cached_emails_sent: providerAnalytics.emailsSentCount || 0,
              cached_emails_opened: providerAnalytics.openCountUnique || 0,
              cached_reply_count: providerAnalytics.replyCount || 0,
              cached_emails_bounced: providerAnalytics.bouncedCount || 0,
              cached_positive_count: providerAnalytics.totalOpportunities || 0,
              cache_updated_at: new Date().toISOString(),
            })
            .eq("id", campaignId);

          console.log(`[Campaign Details] Refreshed analytics cache for ${campaignId}`);
        } catch (e) {
          console.error("Failed to fetch analytics from provider:", e);
          // Keep using cached analytics if provider fetch fails
        }
      } catch (e) {
        console.error("Failed to get provider for campaign:", e);
        // Keep using cached analytics if provider is unavailable
      }
    }

    return NextResponse.json({
      campaign: updatedCampaign,
      analytics,
      cacheInfo: {
        isCached: !shouldRefresh,
        lastUpdated: campaign.cache_updated_at,
        refreshedNow: shouldRefresh && providerCampaignId,
      },
    });
  } catch (error) {
    console.error("Error fetching campaign details:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch campaign" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/campaigns/[campaignId]/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

interface RouteParams {
  params: Promise<{ campaignId: string }>;
}

// GET - Fetch campaign details
export async function GET(request: Request, { params }: RouteParams) {
  try {
    const { campaignId } = await params;
    const supabase = getSupabase();

    const { data: campaign, error } = await supabase
      .from("campaigns")
      .select(`
        *,
        clients (id, name)
      `)
      .eq("id", campaignId)
      .single();

    if (error || !campaign) {
      return NextResponse.json(
        { error: "Campaign not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ campaign });
  } catch (error) {
    console.error("Error fetching campaign:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch campaign" },
      { status: 500 }
    );
  }
}

// PATCH - Update campaign (name, etc.) - Safe update preserving associations
export async function PATCH(request: Request, { params }: RouteParams) {
  try {
    const { campaignId } = await params;
    const supabase = getSupabase();
    const body = await request.json();
    const { name, is_active } = body;

    // Build update object with only allowed fields
    // CRITICAL: Never allow updating instantly_campaign_id
    // This preserves the association with Instantly
    const updateData: Record<string, unknown> = {};

    if (name !== undefined) {
      updateData.name = name;
    }

    if (is_active !== undefined) {
      updateData.is_active = is_active;
    }

    if (Object.keys(updateData).length === 0) {
      return NextResponse.json(
        { error: "No valid fields to update" },
        { status: 400 }
      );
    }

    // Get current campaign to preserve original_name if not set
    const { data: currentCampaign } = await supabase
      .from("campaigns")
      .select("original_name, name")
      .eq("id", campaignId)
      .single();

    // If this is the first name change and original_name is not set, preserve the original
    if (name && currentCampaign && !currentCampaign.original_name) {
      updateData.original_name = currentCampaign.name;
    }

    const { data: campaign, error } = await supabase
      .from("campaigns")
      .update(updateData)
      .eq("id", campaignId)
      .select()
      .single();

    if (error) {
      console.error("Error updating campaign:", error);
      throw error;
    }

    return NextResponse.json({
      campaign,
      message: "Campaign updated successfully",
    });
  } catch (error) {
    console.error("Error updating campaign:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to update campaign" },
      { status: 500 }
    );
  }
}

// DELETE - Delete a campaign (preserves lead data)
export async function DELETE(request: Request, { params }: RouteParams) {
  try {
    const { campaignId } = await params;
    const supabase = getSupabase();

    // First, update leads to preserve campaign name before deletion
    const { data: campaign } = await supabase
      .from("campaigns")
      .select("name, client_id, clients(name)")
      .eq("id", campaignId)
      .single();

    if (campaign) {
      // Update leads with denormalized campaign/client info before deleting
      await supabase
        .from("leads")
        .update({
          campaign_name: campaign.name,
          client_id: campaign.client_id,
          client_name: (campaign.clients as unknown as { name: string } | null)?.name || null,
        })
        .eq("campaign_id", campaignId);
    }

    // Delete the campaign (leads are preserved with denormalized data)
    const { error } = await supabase
      .from("campaigns")
      .delete()
      .eq("id", campaignId);

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      message: "Campaign deleted. Lead data has been preserved."
    });
  } catch (error) {
    console.error("Error deleting campaign:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to delete campaign" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/clients/[clientId]/sync-positive/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { getProviderForCampaign } from "@/lib/providers";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// POST - Sync only positive leads from Instantly (much faster than full sync)
export async function POST(
  request: Request,
  { params }: { params: Promise<{ clientId: string }> }
) {
  try {
    const { clientId } = await params;
    const supabase = getSupabase();

    // Get all campaigns for this client
    const { data: campaigns, error: campaignsError } = await supabase
      .from("campaigns")
      .select("id, name, instantly_campaign_id, provider_campaign_id, provider_type, api_key_encrypted")
      .eq("client_id", clientId);

    if (campaignsError) {
      console.error("Error fetching campaigns:", campaignsError);
      return NextResponse.json(
        { error: "Failed to fetch campaigns" },
        { status: 500 }
      );
    }

    let totalSynced = 0;
    let totalCreated = 0;
    let campaignsProcessed = 0;
    let campaignsWithoutApiKey = 0;
    const errors: string[] = [];

    // IMPORTANT: First reset ALL is_positive_reply=false for this client
    // This ensures we start with a clean slate before marking only truly positive leads
    console.log(`[Sync Positive] Resetting is_positive_reply for all leads of client ${clientId}...`);
    const { error: resetAllError } = await supabase
      .from("leads")
      .update({ is_positive_reply: false })
      .eq("client_id", clientId)
      .eq("is_positive_reply", true);

    if (resetAllError) {
      console.error(`[Sync Positive] Error resetting leads:`, resetAllError);
    } else {
      console.log(`[Sync Positive] Reset all leads to is_positive_reply=false`);
    }

    // For each campaign, fetch positive leads using the per-campaign API key
    for (const campaign of campaigns || []) {
      const providerCampaignId = campaign.provider_campaign_id || campaign.instantly_campaign_id;
      if (!providerCampaignId) {
        console.log(`[Sync Positive] Skipping campaign ${campaign.name} - no provider campaign ID`);
        continue;
      }

      if (!campaign.api_key_encrypted) {
        console.log(`[Sync Positive] Skipping campaign ${campaign.name} - no API key configured`);
        campaignsWithoutApiKey++;
        continue;
      }

      console.log(`[Sync Positive] Fetching positive leads for campaign: ${campaign.name}`);
      campaignsProcessed++;

      try {
        // Get provider with per-campaign API key
        const provider = await getProviderForCampaign(campaign.id);

        // Fetch only positive leads (uses interest_status filter)
        let positiveLeads: { email: string; firstName?: string; lastName?: string; companyName?: string; interestStatus?: string }[] = [];

        if ('fetchPositiveLeads' in provider && typeof provider.fetchPositiveLeads === 'function') {
          console.log(`[Sync Positive] Using fetchPositiveLeads for ${campaign.name}`);
          positiveLeads = await (provider as { fetchPositiveLeads: (id: string) => Promise<{ email: string; firstName?: string; lastName?: string; companyName?: string; interestStatus?: string }[]> }).fetchPositiveLeads(providerCampaignId);
        } else {
          // Fallback for providers without fetchPositiveLeads - THIS SHOULD NOT HAPPEN FOR INSTANTLY
          console.warn(`[Sync Positive] WARNING: Using fallback (fetchAllLeads) for ${campaign.name} - provider type: ${provider.providerType}`);
          const allLeads = await provider.fetchAllLeads(providerCampaignId);
          positiveLeads = allLeads.filter(
            (lead) => lead.interestStatus === "interested" ||
                      lead.interestStatus === "meeting_booked" ||
                      lead.interestStatus === "meeting_completed" ||
                      lead.interestStatus === "closed"
          );
          console.log(`[Sync Positive] Fallback filtered ${allLeads.length} leads down to ${positiveLeads.length} positive`);
        }

        console.log(`[Sync Positive] Found ${positiveLeads.length} positive leads in provider for ${campaign.name}`);

        // Get client name once for all leads
        const { data: clientData } = await supabase
          .from("clients")
          .select("name")
          .eq("id", clientId)
          .single();
        const clientName = clientData?.name || "";

        for (const lead of positiveLeads) {
          // Normalize email to handle case sensitivity and whitespace
          const normalizedEmail = lead.email.toLowerCase().trim();

          // Map interest status to our status field
          const leadStatus = mapInterestStatusToStatus(lead.interestStatus);

          // First, try to find and update existing lead (case-insensitive email match)
          const { data: existingLead } = await supabase
            .from("leads")
            .select("id")
            .eq("campaign_id", campaign.id)
            .ilike("email", normalizedEmail)
            .single();

          if (existingLead) {
            // Update existing lead to mark as positive
            const { error: updateError } = await supabase
              .from("leads")
              .update({
                is_positive_reply: true,
                has_replied: true,
                status: leadStatus,
                client_id: clientId,
                client_name: clientName,
              })
              .eq("id", existingLead.id);

            if (updateError) {
              console.error(`[Sync Positive] Error updating lead ${normalizedEmail}:`, updateError);
            } else {
              totalCreated++;
            }
          } else {
            // Create new lead if it doesn't exist
            const { error: insertError } = await supabase
              .from("leads")
              .insert({
                email: normalizedEmail,
                first_name: lead.firstName || null,
                last_name: lead.lastName || null,
                company_name: lead.companyName || null,
                campaign_id: campaign.id,
                client_id: clientId,
                client_name: clientName,
                campaign_name: campaign.name,
                is_positive_reply: true,
                has_replied: true,
                status: leadStatus,
              });

            if (insertError) {
              console.error(`[Sync Positive] Error inserting lead ${normalizedEmail}:`, insertError);
            } else {
              totalCreated++;
            }
          }

          totalSynced++;
        }
      } catch (err) {
        const errorMsg = err instanceof Error ? err.message : "Unknown error";
        console.error(`[Sync Positive] Error syncing campaign ${campaign.name}:`, err);
        errors.push(`${campaign.name}: ${errorMsg}`);
      }
    }

    console.log(`[Sync Positive] Complete - ${totalSynced} synced, ${totalCreated} updated, ${campaignsProcessed} campaigns processed`);

    // Build informative message
    let message = "";
    if (campaignsProcessed === 0) {
      if (campaignsWithoutApiKey > 0) {
        message = `No campaigns have API keys configured. Please add API keys in campaign settings.`;
      } else if ((campaigns || []).length === 0) {
        message = "No campaigns found for this client";
      } else {
        message = "No campaigns could be processed";
      }
    } else if (totalSynced === 0) {
      message = `Checked ${campaignsProcessed} campaign(s) - no positive leads found in Instantly`;
    }

    return NextResponse.json({
      success: true,
      synced: totalSynced,
      upserted: totalCreated,
      campaignsProcessed,
      campaignsWithoutApiKey,
      totalCampaigns: (campaigns || []).length,
      message,
      errors: errors.length > 0 ? errors : undefined,
    });
  } catch (error) {
    console.error("Error in sync positive leads:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to sync positive leads" },
      { status: 500 }
    );
  }
}

// Map interest status to our internal status
function mapInterestStatusToStatus(interestStatus?: string): string {
  switch (interestStatus) {
    case "meeting_booked":
    case "meeting_completed":
      return "booked";
    case "closed":
      return "won";
    case "interested":
    default:
      return "replied";
  }
}
</file>

<file path="src/app/api/clients/[clientId]/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

export async function GET(
  request: Request,
  { params }: { params: Promise<{ clientId: string }> }
) {
  try {
    const { clientId } = await params;
    const supabase = getSupabase();

    const { data: client, error } = await supabase
      .from("clients")
      .select("*")
      .eq("id", clientId)
      .single();

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: error.code === "PGRST116" ? 404 : 500 }
      );
    }

    return NextResponse.json({ client });
  } catch (error) {
    console.error("Error fetching client:", error);
    return NextResponse.json(
      { error: "Failed to fetch client" },
      { status: 500 }
    );
  }
}

export async function PATCH(
  request: Request,
  { params }: { params: Promise<{ clientId: string }> }
) {
  try {
    const { clientId } = await params;
    const supabase = getSupabase();
    const body = await request.json();

    // Only allow specific fields to be updated
    const allowedFields = [
      "name",
      "website",
      "notes",
      "logo_url",
      "product_service",
      "icp",
      "acv",
      "tcv",
      "verticals",
      "tam",
      "target_daily_emails",
    ];
    const updates: Record<string, unknown> = {};

    for (const field of allowedFields) {
      if (field in body) {
        updates[field] = body[field];
      }
    }

    if (Object.keys(updates).length === 0) {
      return NextResponse.json(
        { error: "No valid fields to update" },
        { status: 400 }
      );
    }

    const { data: client, error } = await supabase
      .from("clients")
      .update(updates)
      .eq("id", clientId)
      .select()
      .single();

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json({ client });
  } catch (error) {
    console.error("Error updating client:", error);
    return NextResponse.json(
      { error: "Failed to update client" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/auth/callback/route.ts">
import { createClient } from "@/lib/supabase/server";
import { createClient as createServiceClient } from "@supabase/supabase-js";
import { NextResponse } from "next/server";

// Service role client for operations that bypass RLS
function getServiceSupabase() {
  return createServiceClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url);
  const code = searchParams.get("code");
  const redirect = searchParams.get("redirect");
  const clientIdFromUrl = searchParams.get("client_id");
  const next = searchParams.get("next") ?? redirect ?? "/dashboard";

  console.log("[Auth Callback] Params:", { code: !!code, clientIdFromUrl, next });

  if (code) {
    const supabase = await createClient();
    const { data: sessionData, error } = await supabase.auth.exchangeCodeForSession(code);

    console.log("[Auth Callback] Session exchange:", {
      success: !error,
      userId: sessionData?.user?.id,
      userMetadata: sessionData?.user?.user_metadata
    });

    if (!error && sessionData?.user) {
      const userId = sessionData.user.id;
      const userMetadata = sessionData.user.user_metadata || {};

      // Get client_id from URL or from user metadata (set during invite)
      const clientId = clientIdFromUrl || userMetadata.client_id;

      // Use service role client for admin operations (bypasses RLS)
      const serviceSupabase = getServiceSupabase();

      // Check if profile exists and get role
      const { data: existingProfile } = await serviceSupabase
        .from("profiles")
        .select("id, role")
        .eq("id", userId)
        .single();

      let userRole = existingProfile?.role || "client";

      if (!existingProfile) {
        // Create profile if it doesn't exist
        const { error: profileError } = await serviceSupabase.from("profiles").insert({
          id: userId,
          email: sessionData.user.email,
          first_name: userMetadata.first_name || null,
          role: "client",
        });
        if (profileError) {
          console.error("[Auth Callback] Error creating profile:", profileError);
        } else {
          console.log("[Auth Callback] Created profile for user:", userId);
        }
        userRole = "client";
      }

      console.log("[Auth Callback] User role:", userRole);

      // If client_id is provided, link the user to that client
      if (clientId) {
        console.log("[Auth Callback] Linking user to client:", clientId);

        // First check if the client exists
        const { data: clientExists } = await serviceSupabase
          .from("clients")
          .select("id")
          .eq("id", clientId)
          .single();

        if (!clientExists) {
          console.error("[Auth Callback] Client does not exist:", clientId);
          // Redirect based on role
          if (userRole === "admin") {
            return NextResponse.redirect(`${origin}/admin?error=Client no longer exists`);
          }
          return NextResponse.redirect(`${origin}/dashboard?error=Client no longer exists`);
        }

        // Check if user is already linked to this client
        const { data: existingLink } = await serviceSupabase
          .from("client_users")
          .select("client_id, user_id")
          .eq("user_id", userId)
          .eq("client_id", clientId)
          .single();

        // If not linked, create the link
        if (!existingLink) {
          const { error: linkError } = await serviceSupabase
            .from("client_users")
            .insert({
              user_id: userId,
              client_id: clientId,
              role: "viewer",
            });

          if (linkError) {
            console.error("[Auth Callback] Error linking user to client:", linkError);
          } else {
            console.log("[Auth Callback] Successfully linked user to client");
          }
        }

        // Redirect directly to the client page (hip UI)
        return NextResponse.redirect(`${origin}/admin/clients/${clientId}`);
      }

      // Role-based redirect when no specific client is provided
      if (userRole === "admin") {
        console.log("[Auth Callback] Admin user, redirecting to /admin");
        return NextResponse.redirect(`${origin}/admin`);
      }

      // For client users, check for pending invitations first
      const userEmail = sessionData.user.email?.toLowerCase();
      console.log("[Auth Callback] Checking invitations for email:", userEmail);

      if (userEmail) {
        // Check for pending invitations for this email
        const { data: pendingInvitation } = await serviceSupabase
          .from("client_invitations")
          .select("id, client_id")
          .eq("email", userEmail)
          .is("accepted_at", null)
          .order("created_at", { ascending: false })
          .limit(1)
          .single();

        if (pendingInvitation) {
          console.log("[Auth Callback] Found pending invitation for client:", pendingInvitation.client_id);

          // Link user to the client from invitation
          const { error: linkError } = await serviceSupabase
            .from("client_users")
            .upsert({
              user_id: userId,
              client_id: pendingInvitation.client_id,
              role: "viewer",
            }, { onConflict: "client_id,user_id" });

          if (linkError) {
            console.error("[Auth Callback] Error linking from invitation:", linkError);
          } else {
            console.log("[Auth Callback] Linked user to client from invitation");
          }

          // Mark invitation as accepted
          await serviceSupabase
            .from("client_invitations")
            .update({ accepted_at: new Date().toISOString() })
            .eq("id", pendingInvitation.id);

          // Redirect to client page (hip UI)
          return NextResponse.redirect(`${origin}/admin/clients/${pendingInvitation.client_id}`);
        }
      }

      // Check if they have any existing linked clients
      const { data: linkedClients } = await serviceSupabase
        .from("client_users")
        .select("client_id")
        .eq("user_id", userId);

      if (linkedClients && linkedClients.length === 1) {
        // If they have exactly one client, go directly to that client's page (hip UI)
        console.log("[Auth Callback] Client user with one client, redirecting to client page");
        return NextResponse.redirect(`${origin}/admin/clients/${linkedClients[0].client_id}`);
      }

      if (linkedClients && linkedClients.length > 1) {
        // Multiple clients, let them choose
        console.log("[Auth Callback] Client user with multiple clients, redirecting to /dashboard");
        return NextResponse.redirect(`${origin}/dashboard`);
      }

      // No linked clients - check if this email has any invitations (accepted or not)
      // and link them if found
      if (userEmail) {
        const { data: anyInvitation } = await serviceSupabase
          .from("client_invitations")
          .select("client_id")
          .eq("email", userEmail)
          .order("created_at", { ascending: false })
          .limit(1)
          .single();

        if (anyInvitation) {
          console.log("[Auth Callback] Found invitation (possibly accepted) for client:", anyInvitation.client_id);

          // Link user to this client
          const { error: linkError } = await serviceSupabase
            .from("client_users")
            .upsert({
              user_id: userId,
              client_id: anyInvitation.client_id,
              role: "viewer",
            }, { onConflict: "client_id,user_id" });

          if (!linkError) {
            return NextResponse.redirect(`${origin}/admin/clients/${anyInvitation.client_id}`);
          }
        }
      }

      // Otherwise, go to the dashboard selection page
      console.log("[Auth Callback] Client user with no linked clients, redirecting to /dashboard");
      return NextResponse.redirect(`${origin}/dashboard`);
    }
  }

  // Return to login with error
  console.log("[Auth Callback] Authentication failed, redirecting to login");
  return NextResponse.redirect(`${origin}/login?error=Could not authenticate`);
}
</file>

<file path="src/app/page.tsx">
import { redirect } from "next/navigation";
import { createClient } from "@/lib/supabase/server";
import Link from "next/link";
import { MarketingHeader } from "@/components/marketing/header";
import { MarketingFooter } from "@/components/marketing/footer";

export default async function Home() {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Logged-in users go to dashboard
  if (user) {
    redirect("/dashboard");
  }

  // Non-logged-in users see the marketing home page
  return (
    <div className="min-h-screen bg-[#050508] text-white">
      <MarketingHeader />
      <main className="pt-16 lg:pt-20">
        {/* Hero Section */}
        <section className="relative overflow-hidden">
          {/* Background effects */}
          <div className="absolute inset-0 bg-gradient-to-br from-[#050508] via-[#0a1628] to-[#050508]" />
          <div className="absolute top-20 -left-40 w-[600px] h-[600px] bg-blue-600/20 rounded-full blur-[150px]" />
          <div className="absolute bottom-0 right-0 w-[500px] h-[500px] bg-cyan-500/15 rounded-full blur-[130px]" />

          {/* Grid pattern */}
          <div
            className="absolute inset-0 opacity-[0.03]"
            style={{
              backgroundImage: `radial-gradient(circle at 1px 1px, rgba(255,255,255,0.15) 1px, transparent 0)`,
              backgroundSize: '40px 40px'
            }}
          />

          <div className="relative max-w-7xl mx-auto px-6 lg:px-8 pt-24 pb-32 lg:pt-32 lg:pb-40">
            <div className="max-w-3xl mx-auto text-center">
              {/* Badge */}
              <div className="inline-flex items-center gap-2 px-4 py-2 bg-blue-500/10 border border-blue-500/20 rounded-full mb-8">
                <div className="w-2 h-2 bg-emerald-400 rounded-full animate-pulse" />
                <span className="text-sm text-blue-300 font-medium">Built for email outbound agencies</span>
              </div>

              {/* Headline */}
              <h1 className="text-4xl sm:text-5xl lg:text-6xl font-bold leading-[1.1] tracking-tight mb-6">
                Give your clients
                <span className="block text-transparent bg-clip-text bg-gradient-to-r from-blue-400 via-cyan-400 to-emerald-400">
                  real-time visibility
                </span>
              </h1>

              {/* Subheadline */}
              <p className="text-xl text-zinc-400 leading-relaxed mb-10 max-w-2xl mx-auto">
                Stop sending spreadsheet reports. Blue Reach gives your clients a branded dashboard to track their campaigns, leads, and results in real-time.
              </p>

              {/* CTAs */}
              <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
                <Link
                  href="/login"
                  className="w-full sm:w-auto px-8 py-4 bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white font-semibold rounded-xl transition-all shadow-xl shadow-blue-500/25 hover:shadow-blue-500/40 hover:-translate-y-0.5 text-center"
                >
                  Start Free Trial
                </Link>
                <Link
                  href="/features"
                  className="w-full sm:w-auto px-8 py-4 bg-white/5 hover:bg-white/10 border border-white/10 text-white font-semibold rounded-xl transition-all text-center"
                >
                  See Features
                </Link>
              </div>

              {/* Trust indicators */}
              <div className="mt-12 flex items-center justify-center gap-8 text-sm text-zinc-500">
                <div className="flex items-center gap-2">
                  <svg className="w-5 h-5 text-emerald-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                  <span>No credit card required</span>
                </div>
                <div className="flex items-center gap-2">
                  <svg className="w-5 h-5 text-emerald-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                  <span>14-day free trial</span>
                </div>
              </div>
            </div>
          </div>
        </section>

        {/* Problem/Solution Section */}
        <section className="py-20 lg:py-32 bg-zinc-900/30">
          <div className="max-w-7xl mx-auto px-6 lg:px-8">
            <div className="max-w-3xl mx-auto text-center mb-16">
              <h2 className="text-3xl lg:text-4xl font-bold mb-6">
                Your clients deserve better than spreadsheets
              </h2>
              <p className="text-lg text-zinc-400">
                Manual reporting wastes your time and leaves clients in the dark. Blue Reach automates everything so you can focus on results.
              </p>
            </div>

            <div className="grid md:grid-cols-3 gap-8">
              {[
                {
                  icon: "M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z",
                  title: "No more spreadsheets",
                  description: "Stop exporting CSVs and building manual reports. Everything syncs automatically from Instantly & Smartlead.",
                },
                {
                  icon: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z",
                  title: "Real-time updates",
                  description: "Clients see their campaign performance as it happens. Opens, replies, and meetings - all live.",
                },
                {
                  icon: "M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z",
                  title: "White-label ready",
                  description: "Add your logo, colors, and domain. Clients see your brand, not ours. Look professional without the dev work.",
                },
              ].map((item, i) => (
                <div
                  key={i}
                  className="p-8 rounded-2xl bg-white/[0.02] border border-white/5 hover:border-white/10 transition-all group"
                >
                  <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-blue-500/20 to-cyan-500/10 flex items-center justify-center mb-5 group-hover:scale-110 transition-transform">
                    <svg className="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d={item.icon} />
                    </svg>
                  </div>
                  <h3 className="text-xl font-semibold mb-3">{item.title}</h3>
                  <p className="text-zinc-400 leading-relaxed">{item.description}</p>
                </div>
              ))}
            </div>
          </div>
        </section>

        {/* Features Section */}
        <section className="py-20 lg:py-32">
          <div className="max-w-7xl mx-auto px-6 lg:px-8">
            <div className="text-center mb-16">
              <h2 className="text-3xl lg:text-4xl font-bold mb-6">
                Everything you need to manage clients
              </h2>
              <p className="text-lg text-zinc-400 max-w-2xl mx-auto">
                From campaign tracking to lead management, Blue Reach has you covered.
              </p>
            </div>

            <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
              {[
                {
                  icon: "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z",
                  title: "Client Portals",
                  description: "Each client gets their own branded dashboard. Manage multiple clients from one account.",
                  color: "blue",
                },
                {
                  icon: "M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z",
                  title: "Real-time Analytics",
                  description: "Track opens, clicks, replies, and meetings. See exactly how campaigns are performing.",
                  color: "cyan",
                },
                {
                  icon: "M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10",
                  title: "Lead Pipeline",
                  description: "Manage leads through your workflow. Track status, add notes, and move deals forward.",
                  color: "emerald",
                },
                {
                  icon: "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z",
                  title: "Email Sync",
                  description: "Connect Instantly, Smartlead, or Apollo. All your data in one place, synced automatically.",
                  color: "purple",
                },
                {
                  icon: "M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9",
                  title: "Instant Notifications",
                  description: "Get notified when leads reply or book meetings. Never miss an opportunity.",
                  color: "amber",
                },
                {
                  icon: "M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4",
                  title: "Custom Workflows",
                  description: "Define your own lead stages. Match your existing process, not the other way around.",
                  color: "rose",
                },
              ].map((feature, i) => (
                <div
                  key={i}
                  className="group p-6 rounded-2xl bg-white/[0.02] border border-white/5 hover:border-white/10 hover:bg-white/[0.04] transition-all"
                >
                  <div className={`w-11 h-11 rounded-xl bg-gradient-to-br ${
                    feature.color === 'blue' ? 'from-blue-500/20 to-blue-600/10' :
                    feature.color === 'cyan' ? 'from-cyan-500/20 to-cyan-600/10' :
                    feature.color === 'emerald' ? 'from-emerald-500/20 to-emerald-600/10' :
                    feature.color === 'purple' ? 'from-purple-500/20 to-purple-600/10' :
                    feature.color === 'amber' ? 'from-amber-500/20 to-amber-600/10' :
                    'from-rose-500/20 to-rose-600/10'
                  } flex items-center justify-center mb-4 group-hover:scale-110 transition-transform`}>
                    <svg className={`w-5 h-5 ${
                      feature.color === 'blue' ? 'text-blue-400' :
                      feature.color === 'cyan' ? 'text-cyan-400' :
                      feature.color === 'emerald' ? 'text-emerald-400' :
                      feature.color === 'purple' ? 'text-purple-400' :
                      feature.color === 'amber' ? 'text-amber-400' :
                      'text-rose-400'
                    }`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d={feature.icon} />
                    </svg>
                  </div>
                  <h3 className="text-lg font-semibold mb-2">{feature.title}</h3>
                  <p className="text-sm text-zinc-400 leading-relaxed">{feature.description}</p>
                </div>
              ))}
            </div>

            <div className="text-center mt-12">
              <Link
                href="/features"
                className="inline-flex items-center gap-2 text-blue-400 hover:text-blue-300 font-medium transition-colors"
              >
                See all features
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              </Link>
            </div>
          </div>
        </section>

        {/* Testimonials Section */}
        <section className="py-20 lg:py-32 bg-zinc-900/30">
          <div className="max-w-7xl mx-auto px-6 lg:px-8">
            <div className="text-center mb-16">
              <h2 className="text-3xl lg:text-4xl font-bold mb-6">
                Trusted by agency owners
              </h2>
              <p className="text-lg text-zinc-400">
                See what other agencies are saying about Blue Reach.
              </p>
            </div>

            <div className="grid md:grid-cols-3 gap-8">
              {[
                {
                  quote: "Blue Reach cut our reporting time from 4 hours to zero. Clients love having their own dashboard.",
                  author: "Add your testimonial",
                  role: "Agency Owner",
                  company: "Your Client",
                },
                {
                  quote: "The white-label portals make us look way more professional. Clients think we built it ourselves.",
                  author: "Add your testimonial",
                  role: "Founder",
                  company: "Your Client",
                },
                {
                  quote: "Finally, a tool built for agencies. The multi-client management is exactly what we needed.",
                  author: "Add your testimonial",
                  role: "CEO",
                  company: "Your Client",
                },
              ].map((testimonial, i) => (
                <div
                  key={i}
                  className="p-8 rounded-2xl bg-white/[0.02] border border-white/5"
                >
                  <div className="flex gap-1 mb-4">
                    {[...Array(5)].map((_, j) => (
                      <svg key={j} className="w-5 h-5 text-amber-400" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                      </svg>
                    ))}
                  </div>
                  <p className="text-zinc-300 leading-relaxed mb-6 italic">&ldquo;{testimonial.quote}&rdquo;</p>
                  <div>
                    <p className="font-semibold text-white">{testimonial.author}</p>
                    <p className="text-sm text-zinc-500">{testimonial.role}, {testimonial.company}</p>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </section>

        {/* CTA Section */}
        <section className="py-20 lg:py-32 relative overflow-hidden">
          {/* Background */}
          <div className="absolute inset-0 bg-gradient-to-br from-blue-600/20 via-transparent to-cyan-600/20" />

          <div className="relative max-w-4xl mx-auto px-6 lg:px-8 text-center">
            <h2 className="text-3xl lg:text-5xl font-bold mb-6">
              Ready to level up your agency?
            </h2>
            <p className="text-xl text-zinc-400 mb-10 max-w-2xl mx-auto">
              Join agencies who&apos;ve ditched spreadsheets for real-time client dashboards. Start your free trial today.
            </p>
            <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
              <Link
                href="/login"
                className="w-full sm:w-auto px-8 py-4 bg-white text-zinc-900 font-semibold rounded-xl hover:bg-zinc-100 transition-all shadow-xl hover:-translate-y-0.5 text-center"
              >
                Start Free Trial
              </Link>
              <Link
                href="/pricing"
                className="w-full sm:w-auto px-8 py-4 bg-white/10 hover:bg-white/20 border border-white/20 text-white font-semibold rounded-xl transition-all text-center"
              >
                View Pricing
              </Link>
            </div>
            <p className="mt-6 text-sm text-zinc-500">
              No credit card required. 14-day free trial.
            </p>
          </div>
        </section>
      </main>
      <MarketingFooter />
    </div>
  );
}
</file>

<file path="src/lib/instantly/campaigns.ts">
// Instantly Campaigns API Functions

import { getInstantlyClient } from "./client";
import type {
  InstantlyCampaign,
  InstantlyCampaignDetails,
  InstantlyCampaignAnalytics,
  InstantlyCampaignDailyAnalytics,
  InstantlyCampaignCreatePayload,
} from "./types";

interface CampaignsListResponse {
  items: InstantlyCampaign[];
}

// Analytics responses are direct arrays in V2 API
type CampaignAnalyticsResponse = InstantlyCampaignAnalytics[];

type CampaignDailyAnalyticsResponse = { daily: InstantlyCampaignDailyAnalytics[] } | InstantlyCampaignDailyAnalytics[];

export async function fetchInstantlyCampaigns(params?: {
  limit?: number;
  skip?: number;
  status?: string;
}): Promise<InstantlyCampaign[]> {
  const client = getInstantlyClient();
  const response = await client.get<CampaignsListResponse>("/campaigns", {
    limit: params?.limit || 100,
    skip: params?.skip || 0,
    status: params?.status,
  });
  return response.items || [];
}

export async function fetchAllInstantlyCampaigns(): Promise<InstantlyCampaign[]> {
  const allCampaigns: InstantlyCampaign[] = [];
  let skip = 0;
  const limit = 100;

  while (true) {
    const campaigns = await fetchInstantlyCampaigns({ limit, skip });
    allCampaigns.push(...campaigns);

    if (campaigns.length < limit) {
      break;
    }
    skip += limit;
  }

  return allCampaigns;
}

export async function fetchInstantlyCampaign(campaignId: string): Promise<InstantlyCampaign> {
  const client = getInstantlyClient();
  return client.get<InstantlyCampaign>(`/campaigns/${campaignId}`);
}

// Fetch campaign with full details including sequences (email templates)
export async function fetchInstantlyCampaignDetails(campaignId: string): Promise<InstantlyCampaignDetails> {
  const client = getInstantlyClient();
  return client.get<InstantlyCampaignDetails>(`/campaigns/${campaignId}`);
}

export async function activateCampaign(campaignId: string): Promise<{ success: boolean }> {
  const client = getInstantlyClient();
  return client.post<{ success: boolean }>(`/campaigns/${campaignId}/activate`);
}

export async function pauseCampaign(campaignId: string): Promise<{ success: boolean }> {
  const client = getInstantlyClient();
  return client.post<{ success: boolean }>(`/campaigns/${campaignId}/pause`);
}

export async function getCampaignAnalytics(params?: {
  id?: string;        // V2 API uses 'id' not 'campaign_id'
  start_date?: string;
  end_date?: string;
}): Promise<InstantlyCampaignAnalytics[]> {
  const client = getInstantlyClient();
  const response = await client.get<CampaignAnalyticsResponse>("/campaigns/analytics", params);
  // V2 API returns array directly
  return Array.isArray(response) ? response : [];
}

export async function getCampaignOverviewAnalytics(): Promise<InstantlyCampaignAnalytics[]> {
  const client = getInstantlyClient();
  const response = await client.get<CampaignAnalyticsResponse>("/campaigns/analytics/overview");
  // V2 API returns array directly
  return Array.isArray(response) ? response : [];
}

export async function getCampaignDailyAnalytics(params?: {
  id?: string;        // V2 API uses 'id' not 'campaign_id'
  start_date?: string;
  end_date?: string;
}): Promise<InstantlyCampaignDailyAnalytics[]> {
  const client = getInstantlyClient();
  const response = await client.get<CampaignDailyAnalyticsResponse>("/campaigns/analytics/daily", params);
  // API returns { daily: [...] } wrapper or direct array
  if (Array.isArray(response)) {
    return response;
  }
  if (response && typeof response === 'object' && 'daily' in response) {
    return response.daily || [];
  }
  return [];
}

// Create a new campaign in Instantly
export async function createInstantlyCampaign(
  payload: InstantlyCampaignCreatePayload
): Promise<InstantlyCampaign> {
  const client = getInstantlyClient();
  return client.post<InstantlyCampaign>("/campaigns", payload);
}

// Create campaign with sensible defaults
export async function createInstantlyCampaignWithDefaults(
  name: string,
  options?: {
    timezone?: string;
    emailAccounts?: string[];
    dailyLimit?: number;
    stopOnReply?: boolean;
  }
): Promise<InstantlyCampaign> {
  const payload: InstantlyCampaignCreatePayload = {
    name,
    campaign_schedule: {
      schedules: [
        {
          name: "Default Schedule",
          timing: {
            from: "09:00",
            to: "17:00",
          },
          days: {
            monday: true,
            tuesday: true,
            wednesday: true,
            thursday: true,
            friday: true,
            saturday: false,
            sunday: false,
          },
          timezone: options?.timezone || "Europe/Berlin",
        },
      ],
    },
    daily_limit: options?.dailyLimit,
    stop_on_reply: options?.stopOnReply ?? true,
    email_list: options?.emailAccounts,
  };

  return createInstantlyCampaign(payload);
}

// Delete a campaign from Instantly
export async function deleteInstantlyCampaign(
  campaignId: string
): Promise<{ success: boolean }> {
  const client = getInstantlyClient();
  return client.delete<{ success: boolean }>(`/campaigns/${campaignId}`);
}
</file>

<file path="CLAUDE.md">
# Claude Code Project Configuration

This file provides context for Claude Code when working on this project.

## Project Overview

**BlueReach Agency Management Dashboard** - A Next.js 15 SaaS application for lead generation agencies to manage clients, campaigns, and leads with Instantly.ai integration.

### Key Features
- Multi-tenant client portal with role-based access
- Instantly.ai + Smartlead campaign integration with real-time webhooks
- Lead workflow management (contacted  replied  booked  won/lost)
- Email thread viewing and sync
- Infrastructure health monitoring (email accounts, DNS checks, warmup tracking)
- Dark mode modern UI for clients
- Admin command center for agency staff

## Tech Stack

| Technology | Version | Purpose |
|------------|---------|---------|
| Next.js | 15.x | App Router, Server Components, API Routes |
| TypeScript | 5.x | Type-safe development |
| React | 19.x | UI framework |
| Supabase | Latest | PostgreSQL database, Auth (Google/Microsoft OAuth), RLS |
| Tailwind CSS | 3.x | Utility-first styling |
| shadcn/ui | Latest | UI component library |
| Lucide React | Latest | Icons |

## Architecture

### Authentication Flow
```
Login (Google/Microsoft OAuth)
    
Supabase Auth Callback (/auth/callback)
    
Check user role from profiles table
    
 Admin  /admin (Command Center)
 Client  /admin/clients/[clientId] (Hip UI with restricted permissions)
```

### Role-Based Access
- **Admin** (`profiles.role = 'admin'`): Full access to all routes and features
- **Client** (`profiles.role = 'client'`): Access only to `/admin/clients/[clientId]` for their linked clients
  - Can view analytics, manage lead workflow, add notes
  - Cannot link campaigns, delete campaigns, or access other admin routes

### Middleware Protection
- `/admin/*` routes protected by middleware
- Client users can only access `/admin/clients/[clientId]` if linked via `client_users` table
- Other admin routes blocked for non-admin users

## Project Structure

```
src/
 app/
    admin/                    # Admin portal
       clients/[clientId]/   # Client dashboard (used by both admin & clients)
          page.tsx          # Main client page with Lead Workflow
          campaigns/        # Campaign management
          settings/         # Client settings
       instantly/            # Instantly integration pages
       leads/                # Lead management
       layout.tsx            # Admin layout (dark mode, modern)
    api/                      # API routes
       clients/              # Client CRUD
       campaigns/            # Campaign operations
       leads/                # Lead operations
       instantly/            # Instantly API proxy
       webhooks/             # Webhook handlers
    auth/                     # Auth callbacks
    dashboard/                # Legacy client portal (redirects to admin/clients)
    login/                    # OAuth login (Google + Microsoft)
 components/
    layout/                   # Layout components
    leads/                    # Lead-specific components
    ui/                       # shadcn/ui components
 lib/
    instantly/                # Instantly API client
    smartlead/                # Smartlead API client
    dns/                      # DNS health checker (SPF/DKIM/DMARC)
    queries/                  # Database query functions
    supabase/                 # Supabase client setup
 types/
     database.ts               # TypeScript types for all tables
```

## Database Schema

### Core Tables

#### `profiles`
User profiles linked to Supabase Auth.
```sql
id          uuid PRIMARY KEY (references auth.users)
email       text
role        text ('admin' | 'client')
full_name   text
```

#### `clients`
Agency clients (companies being served).
```sql
id                  uuid PRIMARY KEY
name                text NOT NULL
logo_url            text
website             text
notes               text
product_service     text
acv                 numeric          -- Average Contract Value
tcv                 numeric          -- Total Contract Value
verticals           text[]           -- Target industries
tam                 integer          -- Total Addressable Market (lead count)
target_daily_emails integer
is_active           boolean
created_at          timestamptz
```

#### `client_users`
Links users to clients they can access.
```sql
client_id   uuid REFERENCES clients(id)
user_id     uuid REFERENCES auth.users(id)
role        text ('owner' | 'manager' | 'member' | 'viewer')
PRIMARY KEY (client_id, user_id)
```

#### `client_invitations`
Pending invitations for client users.
```sql
id          uuid PRIMARY KEY
client_id   uuid REFERENCES clients(id)
email       text NOT NULL
invited_by  uuid
created_at  timestamptz
accepted_at timestamptz  -- NULL until accepted
```

#### `campaigns`
Email campaigns linked to Instantly.
```sql
id                      uuid PRIMARY KEY
client_id               uuid REFERENCES clients(id)
instantly_campaign_id   text             -- ID from Instantly
provider_type           text             -- 'instantly', 'smartlead', etc.
provider_campaign_id    text
name                    text NOT NULL
original_name           text
copy_body               text             -- Email template
is_active               boolean
last_synced_at          timestamptz
```

#### `leads`
All leads with denormalized data for preservation.
```sql
id                  uuid PRIMARY KEY
campaign_id         uuid REFERENCES campaigns(id)
email               text NOT NULL
first_name          text
last_name           text
company_name        text
company_domain      text
phone               text
linkedin_url        text
status              text ('contacted'|'opened'|'clicked'|'replied'|'booked'|'won'|'lost')
is_positive_reply   boolean
has_replied         boolean
responded_at        timestamptz
meeting_at          timestamptz
closed_at           timestamptz
deal_value          numeric
notes               text
instantly_lead_id   text
email_open_count    integer
email_click_count   integer
email_reply_count   integer
metadata            jsonb
created_at          timestamptz
updated_at          timestamptz

-- Denormalized fields (preserved when parent deleted)
client_id           uuid
client_name         text
campaign_name       text
```

#### `lead_emails`
Email thread for each lead.
```sql
id                  uuid PRIMARY KEY
lead_id             uuid REFERENCES leads(id)
campaign_id         uuid REFERENCES campaigns(id)
provider_email_id   text
provider_thread_id  text
direction           text ('outbound' | 'inbound')
from_email          text
to_email            text
subject             text
body_text           text
body_html           text
sequence_step       integer
sent_at             timestamptz
opened_at           timestamptz
replied_at          timestamptz
created_at          timestamptz
```

### Supporting Tables

#### `api_providers`
Multi-provider API key storage.
```sql
id            uuid PRIMARY KEY
client_id     uuid REFERENCES clients(id)
provider_type text ('instantly'|'smartlead'|'lemlist'|'apollo')
api_key       text
workspace_id  text
is_active     boolean
label         text
```

#### `campaign_sequences`
Email sequence templates.
```sql
id              uuid PRIMARY KEY
campaign_id     uuid REFERENCES campaigns(id)
sequence_index  integer
step_number     integer
variant         text ('A', 'B', 'C')
subject         text
body_text       text
body_html       text
delay_days      integer
delay_hours     integer
```

#### `activities`
Activity log for leads.
```sql
id            uuid PRIMARY KEY
lead_id       uuid REFERENCES leads(id)
user_id       uuid
type          text ('call'|'meeting'|'email'|'note'|'status_change')
title         text
description   text
scheduled_at  timestamptz
completed_at  timestamptz
```

#### `email_events`
Tracking events from email providers.
```sql
id                  uuid PRIMARY KEY
lead_id             uuid REFERENCES leads(id)
campaign_id         uuid REFERENCES campaigns(id)
event_type          text ('sent'|'opened'|'clicked'|'replied'|'bounced')
instantly_event_id  text
timestamp           timestamptz
```

### Infrastructure Health Tables

#### `email_accounts`
Central registry of email accounts from Instantly and Smartlead.
```sql
id                    uuid PRIMARY KEY
provider_type         text NOT NULL ('instantly'|'smartlead')
provider_account_id   text
email                 text NOT NULL
client_id             uuid REFERENCES clients(id)  -- Manual assignment
domain                text GENERATED              -- Extracted from email
status                text ('active'|'error'|'disconnected'|'paused')
warmup_enabled        boolean
warmup_reputation     integer                     -- 0-100 score
warmup_emails_sent    integer
warmup_emails_received integer
daily_limit           integer
last_synced_at        timestamptz
UNIQUE(provider_type, email)
```

#### `email_account_health_history`
Daily snapshots for trend analysis.
```sql
id                    uuid PRIMARY KEY
email_account_id      uuid REFERENCES email_accounts(id)
snapshot_date         date NOT NULL
status                text
warmup_reputation     integer
warmup_emails_sent    integer
warmup_emails_received integer
emails_sent_today     integer
UNIQUE(email_account_id, snapshot_date)
```

#### `domain_health`
DNS validation cache for SPF/DKIM/DMARC.
```sql
id                uuid PRIMARY KEY
domain            text NOT NULL UNIQUE
has_spf           boolean
spf_record        text
spf_valid         boolean
has_dkim          boolean
dkim_selector     text
dkim_record       text
dkim_valid        boolean
has_dmarc         boolean
dmarc_record      text
dmarc_policy      text ('none'|'quarantine'|'reject')
dmarc_valid       boolean
health_score      integer GENERATED  -- 0-100 based on DNS records
last_checked_at   timestamptz
```

### Row Level Security (RLS)
- All tables have RLS enabled
- Admin users can access all data
- Client users can only access data for their linked clients
- Service role key bypasses RLS for webhook handlers

## Instantly API Integration

### Webhook Flow
```
Instantly Event (lead_interested, email_sent, etc.)
    
POST /api/webhooks/instantly/[campaignId]
    
Update lead status, create lead_emails record
    
Real-time sync to dashboard
```

### API Functions (`src/lib/instantly/`)
- `client.ts` - Base HTTP client with Bearer auth
- `campaigns.ts` - List, activate, pause campaigns
- `leads.ts` - List, create, update leads
- `analytics.ts` - Campaign and account analytics
- `accounts.ts` - Email account management

### Webhook Events Handled
- `lead_interested`  `is_positive_reply = true`
- `lead_not_interested`  `is_positive_reply = false`
- `email_sent`  Increment `emails_sent` counter
- `email_opened`  Increment open count
- `email_replied`  Update `has_replied`, `replied_at`

## Smartlead API Integration

### Authentication
Smartlead uses query parameter auth: `?api_key=YOUR_API_KEY`

### API Functions (`src/lib/smartlead/`)
- `client.ts` - Base HTTP client with query param auth
- `types.ts` - SmartleadAccount, SmartleadWarmupStats interfaces
- `accounts.ts` - Fetch accounts and warmup analytics

### Key Endpoints Used
- `GET /api/v1/email-accounts` - List all email accounts
- `GET /api/v1/email-accounts/{id}/warmup-stats` - Warmup analytics

## Infrastructure Health Feature

### Overview
Monitor email account health across providers with DNS validation.

### API Routes (`/api/admin/infrastructure/`)
| Route | Method | Purpose |
|-------|--------|---------|
| `/stats` | GET | Dashboard statistics |
| `/accounts` | GET | List accounts with filters |
| `/accounts/[id]` | PATCH | Assign client to account |
| `/sync` | POST | Sync from Instantly/Smartlead |
| `/dns` | GET | Get cached domain health |
| `/dns` | POST | Check specific domains |
| `/dns` | PATCH | Refresh all domains |
| `/history` | GET | Historical snapshots |
| `/history` | POST | Create daily snapshot |

### DNS Health Checker (`src/lib/dns/`)
Uses DNS-over-HTTPS (Google DoH) for server-side lookups:
- SPF record validation
- DKIM selector probing (common selectors: google, default, selector1, etc.)
- DMARC policy detection

### UI Features (`/admin/infrastructure`)
- Stats cards: Total accounts, active count, avg reputation, domain count
- Accounts table with client filter, provider filter, status filter
- Client assignment dialog for manual account-to-client mapping
- Domain health section with SPF/DKIM/DMARC status
- Auto-refresh every 30 seconds

## Key Workflows

### Lead Workflow (Client Dashboard)
1. **Positive Reply** - Lead marked as interested in Instantly
2. **Mark Responded** - User confirms they responded
3. **Schedule Meeting** - User books a meeting
4. **Close Won/Lost** - Deal outcome recorded

### Campaign Sync
1. Fetch campaigns from Instantly API
2. Create/update local campaign records
3. Sync analytics (sent, opened, replied counts)
4. Webhook handles real-time updates

### Client Invitation Flow
1. Admin creates invitation with email
2. Invitation stored in `client_invitations`
3. User signs up/logs in via OAuth
4. Auth callback checks for pending invitation
5. Auto-links user to client via `client_users`

## Environment Variables

```env
# Supabase
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=

# Instantly
INSTANTLY_API_KEY=
INSTANTLY_WEBHOOK_SECRET=

# Smartlead
SMARTLEAD_API_KEY=

# OAuth (configured in Supabase dashboard)
# Google and Microsoft providers
```

## Coding Conventions

### TypeScript
- Use strict TypeScript with explicit types
- Define interfaces in `src/types/database.ts`
- Use `type` for unions, `interface` for objects

### React/Next.js
- Server Components by default
- Add `"use client"` only when needed
- Use App Router conventions

### API Routes
- Route Handlers in `app/api/`
- Export named functions: `GET`, `POST`, `PUT`, `DELETE`
- Use service role client for webhook handlers (bypasses RLS)

### Styling
- Tailwind CSS exclusively
- Dark mode via CSS variables
- shadcn/ui component patterns

## Important Notes

1. **Role checks in client components** - Fetch user role and conditionally render admin features
2. **Service role for webhooks** - Use `SUPABASE_SERVICE_ROLE_KEY` to bypass RLS
3. **Denormalized lead data** - Always include `client_id`, `client_name`, `campaign_name`
4. **Real-time updates** - Dashboard auto-refreshes every 30 seconds
5. **No emojis** in code unless explicitly requested

## Deployment

- Docker support via `Dockerfile` and `docker-compose.yml`
- Caddy for reverse proxy with auto HTTPS
- Vercel-compatible
</file>

<file path="README.md">
# BlueReach Agency Management Dashboard

A comprehensive client portal and lead management system for agencies using [Instantly.ai](https://instantly.ai) for cold email outreach. Built with Next.js 15, Supabase, and TypeScript.

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Tech Stack](#tech-stack)
- [Architecture](#architecture)
- [Getting Started](#getting-started)
- [Environment Variables](#environment-variables)
- [Database Schema](#database-schema)
- [API Reference](#api-reference)
- [Instantly Integration](#instantly-integration)
- [Deployment](#deployment)
- [Project Structure](#project-structure)

---

## Overview

BlueReach Agency Management Dashboard is a white-label SaaS platform designed for lead generation agencies. It provides:

- **Admin Portal**: Full control over clients, campaigns, leads, and analytics
- **Client Portal**: Read-only dashboard for clients to view their campaign performance
- **Instantly Integration**: Bidirectional sync with Instantly.ai for campaign and lead management
- **Real-time Analytics**: Track emails sent, opens, replies, and positive responses

---

## Features

### Admin Dashboard (`/admin`)

#### Command Center
- **Real-time Analytics**: View key metrics filtered by time period (this week, this month, this quarter)
  - Leads contacted
  - Emails sent
  - Replies received
  - Positive replies (opportunities)
  - Bounced emails (cumulative)
  - Meetings held (cumulative)
  - Deals closed (cumulative)
- **Clickable Stats**: Click any metric to drill down into the detailed leads view

#### Client Management (`/admin/clients`)
- Create, edit, and delete clients
- Generate unique access codes for client portal login
- View all campaigns per client
- Track client-specific metrics

#### Campaign Management (`/admin/clients/[clientId]`)
- Link Instantly campaigns to clients
- View campaign performance:
  - Total leads in campaign
  - Leads contacted vs total (progress bar)
  - Emails sent
  - Replies received
  - Positive replies
- Click campaigns to view detailed analytics
- Delete campaigns (with confirmation)

#### Campaign Details (`/admin/clients/[clientId]/campaigns/[campaignId]`)
- Detailed campaign statistics
- List of positive replies with contact info
- Recent leads table
- Campaign progress visualization

#### Lead Management (`/admin/leads`)
- View all leads across all clients (48,000+ supported)
- **Server-side Filtering**:
  - Filter by client
  - Filter by status (contacted, opened, clicked, replied, booked, won, lost, not_interested)
  - Filter by positive replies only
- **Pagination**: 100 leads per page with navigation
- **CSV Export Options**:
  - Current filter results
  - Positive replies only
  - All replies
  - No response (contacted but didn't reply)
  - All leads
- Click any lead to view/edit details in slide-out panel

#### Lead Detail Panel
- View complete lead information
- Update lead status
- Add/edit notes
- View contact details (email, phone, company)

#### Lead Workflow (`/admin/clients/[clientId]`)
- **Track Lead Progress**: Follow positive replies through the sales funnel
- **Workflow States**:
  - Responded - Lead has been contacted/followed up
  - Meeting Scheduled - Meeting date and time set
  - Closed Won - Deal successfully closed
  - Closed Lost - Deal did not close
- **Collapsible UI**: Shows summary stats (responded, meetings, won, lost) in header
- **Quick Actions**: One-click status updates with date/time selection for meetings

#### Client Settings (`/admin/clients/[clientId]/settings`)
- **Client Logo**: Upload custom logo for each client
- **Client Details**: Name, website, notes
- **Internal Notes**: Track target market, TCV, services, and other important info

#### Agency Settings (`/admin/settings`)
- **Agency Logo**: Upload your agency branding logo
- **Instantly API Key**: Securely store and manage API credentials
- **Webhook Configuration**: Set up Instantly webhook secrets

#### Instantly Integration (`/admin/instantly`)
- **Connection Status**: View API connection health
- **Campaign Sync**: Import campaigns from Instantly
- **Lead Sync**: Sync leads bidirectionally
- **Account Management**: View email accounts and warmup status
- **Analytics**: View Instantly-specific metrics

#### Settings (`/admin/settings`)
- Configure webhook endpoints
- Manage sync settings
- View system configuration

### Client Portal (`/dashboard/[clientId]`)

- **Login via Access Code**: Clients use a unique code to access their dashboard
- **Campaign Overview**: View all campaigns assigned to them
- **Lead Statistics**: See leads, replies, and positive responses
- **Lead Table**: Browse their leads with filtering
- **Read-only Access**: Clients cannot modify data

### Authentication

- **Admin Access**: Full authentication via Supabase Auth
- **Client Access**: Simple access code system (no email/password required)
- **Middleware Protection**: Routes protected based on user role

---

## Tech Stack

| Technology | Purpose |
|------------|---------|
| **Next.js 15** | React framework with App Router |
| **TypeScript** | Type-safe development |
| **Supabase** | PostgreSQL database + Auth + Real-time |
| **Tailwind CSS** | Utility-first styling |
| **shadcn/ui** | UI component library |
| **Instantly API v2** | Cold email platform integration |
| **Docker** | Containerized deployment |
| **Caddy** | Reverse proxy with auto HTTPS |

---

## Architecture

```

                         Client Browser                          

                                  
                                  

                     Next.js Application                         
       
     Admin Pages       Client Pages        API Routes     
     /admin/*          /dashboard/*        /api/*         
       

                                                   
                                                   
   
         Supabase                       Instantly API          
           
    PostgreSQL Database             Campaigns              
    - clients                       Leads                  
    - campaigns                     Analytics              
    - leads                         Accounts               
    - users                         
       
    
    Authentication           
    

```

### Data Flow

1. **Instantly  Supabase**: Campaigns and leads sync via API or webhooks
2. **Supabase  Next.js**: Server components fetch data directly
3. **Next.js  Browser**: React renders the UI
4. **Browser  API Routes**: Client-side actions (status updates, exports)

---

## Getting Started

### Prerequisites

- Node.js 18+
- npm or yarn
- Supabase account
- Instantly.ai account with API access

### Installation

```bash
# Clone the repository
git clone https://github.com/Toagan/BlueReach-Agency-Management-SAAS.git
cd BlueReach-Agency-Management-SAAS

# Install dependencies
npm install

# Set up environment variables
cp .env.example .env.local
# Edit .env.local with your credentials

# Run database migrations
# Execute the SQL files in Supabase SQL Editor:
# 1. supabase-schema.sql
# 2. supabase-schema-v2.sql
# 3. supabase-settings.sql
# 4. supabase-preserve-leads.sql

# Start development server
npm run dev
```

### Development

```bash
# Run development server
npm run dev

# Build for production
npm run build

# Start production server
npm start

# Type checking
npm run type-check

# Linting
npm run lint
```

---

## Environment Variables

Create a `.env.local` file with the following variables:

```env
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# Instantly API
INSTANTLY_API_KEY=your-instantly-api-key

# Webhook Security
INSTANTLY_WEBHOOK_SECRET=your-webhook-secret
```

### Variable Descriptions

| Variable | Description |
|----------|-------------|
| `NEXT_PUBLIC_SUPABASE_URL` | Your Supabase project URL |
| `NEXT_PUBLIC_SUPABASE_ANON_KEY` | Supabase anonymous/public key |
| `SUPABASE_SERVICE_ROLE_KEY` | Supabase service role key (server-side only) |
| `INSTANTLY_API_KEY` | Instantly API key (found in Instantly settings) |
| `INSTANTLY_WEBHOOK_SECRET` | Secret for validating Instantly webhooks |

---

## Database Schema

### Tables

#### `clients`
Stores agency clients.

| Column | Type | Description |
|--------|------|-------------|
| `id` | uuid | Primary key |
| `name` | text | Client name |
| `email` | text | Client email |
| `access_code` | text | Unique login code for client portal |
| `created_at` | timestamp | Creation timestamp |
| `updated_at` | timestamp | Last update timestamp |

#### `campaigns`
Links Instantly campaigns to clients.

| Column | Type | Description |
|--------|------|-------------|
| `id` | uuid | Primary key |
| `client_id` | uuid | Foreign key to clients |
| `instantly_campaign_id` | text | Instantly campaign ID |
| `name` | text | Campaign name |
| `status` | text | Campaign status |
| `created_at` | timestamp | Creation timestamp |
| `last_synced_at` | timestamp | Last sync with Instantly |

#### `leads`
Stores all leads from campaigns.

| Column | Type | Description |
|--------|------|-------------|
| `id` | uuid | Primary key |
| `campaign_id` | uuid | Foreign key to campaigns |
| `client_id` | uuid | Denormalized client ID |
| `client_name` | text | Denormalized client name |
| `campaign_name` | text | Denormalized campaign name |
| `email` | text | Lead email address |
| `first_name` | text | Lead first name |
| `last_name` | text | Lead last name |
| `company_name` | text | Lead company |
| `phone` | text | Lead phone number |
| `status` | enum | Lead status (see below) |
| `is_positive_reply` | boolean | Whether reply was positive |
| `notes` | text | Admin notes |
| `responded_at` | timestamp | When lead was marked as responded |
| `meeting_at` | timestamp | Scheduled meeting date/time |
| `closed_at` | timestamp | When deal was closed |
| `created_at` | timestamp | Creation timestamp |
| `updated_at` | timestamp | Last update timestamp |

**Lead Status Values:**
- `contacted` - Initial outreach sent
- `opened` - Email was opened
- `clicked` - Link in email was clicked
- `replied` - Lead replied to email
- `booked` - Meeting was booked
- `won` - Deal was closed (won)
- `lost` - Deal was closed (lost)
- `not_interested` - Lead declined

#### `settings`
Application settings (singleton table).

| Column | Type | Description |
|--------|------|-------------|
| `id` | integer | Always 1 |
| `webhook_url` | text | Instantly webhook URL |
| `sync_interval` | integer | Auto-sync interval (minutes) |
| `updated_at` | timestamp | Last update timestamp |

### SQL Migration Files

1. **`supabase-schema.sql`** - Initial schema with clients, campaigns, leads
2. **`supabase-schema-v2.sql`** - Adds denormalized fields for data preservation
3. **`supabase-settings.sql`** - Settings table
4. **`supabase-preserve-leads.sql`** - Triggers to preserve lead data on client/campaign deletion
5. **`supabase-analytics.sql`** - Analytics views and functions

---

## API Reference

### Admin APIs

#### Settings
```
GET  /api/admin/settings           # Get all settings (masked values)
POST /api/admin/settings           # Update a setting
DELETE /api/admin/settings?key=x   # Clear a setting
POST /api/admin/settings/logo      # Upload agency logo
```

#### Analytics
```
GET /api/admin/analytics?period=this_week
```
Returns aggregated analytics from Instantly.

**Query Parameters:**
- `period`: `this_week` | `this_month` | `this_quarter`

**Response:**
```json
{
  "leads_contacted": 150,
  "emails_sent": 500,
  "replies": 25,
  "opportunities": 10,
  "bounced_cumulative": 15,
  "meetings_held_cumulative": 5,
  "deals_closed_cumulative": 2,
  "reply_rate": 5.0
}
```

#### Lead Export
```
GET /api/admin/leads/export?export=positive
```
Returns CSV file of leads.

**Query Parameters:**
- `export`: `current` | `positive` | `replied` | `no_response` | `all`
- `client`: Client ID (for `current` filter)
- `status`: Lead status (for `current` filter)
- `positive`: `true` (for `current` filter)

#### Customers (Clients)
```
GET  /api/admin/customers         # List all clients
POST /api/admin/customers         # Create client
GET  /api/admin/customers/[id]    # Get client
PUT  /api/admin/customers/[id]    # Update client
DELETE /api/admin/customers/[id]  # Delete client
```

### Client APIs

```
GET    /api/clients/[clientId]         # Get client details
PATCH  /api/clients/[clientId]         # Update client (name, website, notes, logo_url)
GET    /api/clients/[clientId]/leads   # Get leads for client (?positive=true)
POST   /api/clients/[clientId]/logo    # Upload client logo
```

### Lead Workflow APIs

```
PATCH  /api/leads/[leadId]/workflow    # Update lead workflow status
```

**Actions:**
- `mark_responded` - Mark lead as responded
- `schedule_meeting` - Set meeting date/time
- `close_won` - Mark deal as won
- `close_lost` - Mark deal as lost
- `update_notes` - Update workflow notes
- `revert_status` - Revert to previous status

### Campaign APIs

```
GET    /api/campaigns/[id]/details  # Get campaign details with stats
GET    /api/campaigns/[id]/leads    # Get leads for campaign
DELETE /api/campaigns/[id]          # Delete campaign
```

### Instantly Integration APIs

```
GET  /api/instantly/status              # Check API connection
GET  /api/instantly/campaigns           # List Instantly campaigns
POST /api/instantly/campaigns           # Sync campaigns to DB
GET  /api/instantly/campaigns/[id]      # Get campaign details
POST /api/instantly/campaigns/[id]      # Activate/pause campaign
GET  /api/instantly/campaigns/analytics # Get campaign analytics
GET  /api/instantly/leads               # List leads from Instantly
POST /api/instantly/leads               # Sync leads to DB
GET  /api/instantly/accounts            # List email accounts
POST /api/instantly/sync                # Full sync (campaigns + leads)
```

### Webhook

```
POST /api/webhooks/instantly
```
Receives real-time updates from Instantly when lead status changes.

**Payload:**
```json
{
  "event_type": "reply_received",
  "campaign_id": "abc123",
  "lead_email": "lead@example.com",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

---

## Instantly Integration

### Setup

1. Get your API key from Instantly Settings  Integrations  API
2. Add the key to `INSTANTLY_API_KEY` environment variable
3. Configure webhook in Instantly to point to `/api/webhooks/instantly`

### Sync Process

#### Manual Sync
1. Go to Admin  Instantly  Overview
2. Click "Sync Campaigns" to import campaigns
3. Click "Sync Leads" to import leads from all campaigns

#### Automatic Sync
Set up a cron job to call the sync endpoint:
```bash
# Every 15 minutes
*/15 * * * * curl -X POST https://your-domain.com/api/instantly/sync
```

See `CRON_SETUP.md` for detailed instructions.

### Webhook Events

The webhook handler processes these Instantly events:
- `lead_created` - New lead added to campaign
- `email_sent` - Email sent to lead
- `email_opened` - Lead opened email
- `link_clicked` - Lead clicked link
- `reply_received` - Lead replied
- `lead_interested` - Lead marked as positive
- `lead_not_interested` - Lead marked as not interested
- `meeting_booked` - Meeting was scheduled
- `lead_won` - Deal closed won
- `lead_lost` - Deal closed lost

---

## Deployment

### Docker Deployment

```bash
# Build the image
docker build -t bluereach-dashboard .

# Run with Docker Compose
docker-compose up -d
```

#### docker-compose.yml
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_SUPABASE_URL=${NEXT_PUBLIC_SUPABASE_URL}
      - NEXT_PUBLIC_SUPABASE_ANON_KEY=${NEXT_PUBLIC_SUPABASE_ANON_KEY}
      - SUPABASE_SERVICE_ROLE_KEY=${SUPABASE_SERVICE_ROLE_KEY}
      - INSTANTLY_API_KEY=${INSTANTLY_API_KEY}
      - INSTANTLY_WEBHOOK_SECRET=${INSTANTLY_WEBHOOK_SECRET}
    restart: unless-stopped

  caddy:
    image: caddy:2
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
    restart: unless-stopped

volumes:
  caddy_data:
```

### Vercel Deployment

1. Connect your GitHub repository to Vercel
2. Add environment variables in Vercel dashboard
3. Deploy

### Environment-Specific Configuration

| Environment | Database | API |
|-------------|----------|-----|
| Development | Supabase Dev Project | Instantly Sandbox |
| Staging | Supabase Staging Project | Instantly Sandbox |
| Production | Supabase Production Project | Instantly Production |

---

## Project Structure

```
src/
 app/
    admin/                    # Admin portal pages
       clients/              # Client management
          [clientId]/       # Individual client
              campaigns/    # Campaign management
                  [campaignId]/ # Campaign details
       instantly/            # Instantly integration UI
       leads/                # Lead management
       settings/             # App settings
       layout.tsx            # Admin layout with sidebar
       page.tsx              # Command center dashboard
   
    api/                      # API routes
       admin/                # Admin APIs
          analytics/        # Analytics endpoints
          customers/        # Client CRUD
          leads/            # Lead export
          settings/         # Settings
       campaigns/            # Campaign APIs
       clients/              # Client-specific APIs
       instantly/            # Instantly integration
       webhooks/             # Webhook handlers
   
    auth/                     # Auth callback
    dashboard/                # Client portal
       [clientId]/           # Client-specific dashboard
    login/                    # Login page
    globals.css               # Global styles
    layout.tsx                # Root layout
    page.tsx                  # Landing page

 components/
    layout/                   # Layout components
       header.tsx            # Top navigation
       sidebar.tsx           # Admin sidebar
       stats-cards.tsx       # Statistics display
    leads/                    # Lead components
       lead-detail-panel.tsx # Slide-out detail view
       lead-table.tsx        # Lead listing table
    ui/                       # shadcn/ui components
        badge.tsx
        button.tsx
        card.tsx
        dialog.tsx
        dropdown-menu.tsx
        input.tsx
        label.tsx
        select.tsx
        sheet.tsx
        table.tsx
        textarea.tsx

 lib/
    instantly/                # Instantly API client
       accounts.ts           # Account management
       analytics.ts          # Analytics fetching
       campaigns.ts          # Campaign operations
       client.ts             # Base HTTP client
       index.ts              # Exports
       leads.ts              # Lead operations
       types.ts              # TypeScript types
    queries/                  # Database queries
       campaigns.ts
       clients.ts
       leads.ts
       stats.ts
    supabase/                 # Supabase clients
       client.ts             # Browser client
       middleware.ts         # Auth middleware
       server.ts             # Server client
    utils.ts                  # Utility functions

 types/
    database.ts               # Database type definitions

 middleware.ts                 # Next.js middleware
```

---

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

---

## License

This project is proprietary software. All rights reserved.

---

## Support

For support, please contact the development team or open an issue on GitHub.
</file>

<file path="src/app/admin/clients/[clientId]/campaigns/add-campaign-dialog.tsx">
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { createClient } from "@/lib/supabase/client";
import {
  Copy,
  Check,
  ExternalLink,
  CheckCircle2,
  XCircle,
  Loader2,
} from "lucide-react";

type ProviderType = "instantly" | "smartlead";

interface ProviderCampaign {
  id: string;
  name: string;
  status: "active" | "paused" | "draft" | "completed";
  leadsCount?: number;
}

interface AddCampaignDialogProps {
  clientId: string;
}

const PROVIDERS: { value: ProviderType; label: string; available: boolean }[] = [
  { value: "instantly", label: "Instantly", available: true },
  { value: "smartlead", label: "Smartlead", available: true },
];

export function AddCampaignDialog({ clientId }: AddCampaignDialogProps) {
  // Dialog state
  const [open, setOpen] = useState(false);
  const [step, setStep] = useState<"select" | "success">("select");

  // Provider selection
  const [selectedProvider, setSelectedProvider] = useState<ProviderType>("instantly");

  // API key
  const [apiKey, setApiKey] = useState("");
  const [apiKeyValid, setApiKeyValid] = useState<boolean | null>(null);
  const [loadingCampaigns, setLoadingCampaigns] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null);

  // Campaigns
  const [campaigns, setCampaigns] = useState<ProviderCampaign[]>([]);
  const [linkedCampaignIds, setLinkedCampaignIds] = useState<Set<string>>(new Set());
  const [selectedCampaignId, setSelectedCampaignId] = useState("");
  const [customName, setCustomName] = useState("");

  // Submission
  const [isPending, startTransition] = useTransition();
  const [linkedCampaignName, setLinkedCampaignName] = useState("");
  const [copied, setCopied] = useState(false);

  const router = useRouter();
  const supabase = createClient();

  // Generate webhook URL
  const webhookUrl =
    typeof window !== "undefined"
      ? `${window.location.origin}/api/webhooks/${selectedProvider}`
      : "";

  // Load campaigns (validates API key and fetches campaigns in one step)
  const loadCampaigns = async () => {
    if (!apiKey.trim()) return;

    setLoadingCampaigns(true);
    setApiKeyValid(null);
    setLoadError(null);
    setCampaigns([]);
    setSelectedCampaignId("");

    try {
      // First validate the API key
      const validateRes = await fetch(`/api/providers/${selectedProvider}/validate`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ apiKey: apiKey.trim() }),
      });
      const validateData = await validateRes.json();

      if (!validateData.valid) {
        setApiKeyValid(false);
        setLoadError("Invalid API key. Please check and try again.");
        setLoadingCampaigns(false);
        return;
      }

      setApiKeyValid(true);

      // Fetch campaigns
      const res = await fetch(`/api/providers/${selectedProvider}/campaigns`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ apiKey: apiKey.trim() }),
      });
      const data = await res.json();

      if (data.error) {
        setLoadError(data.error);
        setLoadingCampaigns(false);
        return;
      }

      setCampaigns(data.campaigns || []);

      // Fetch already linked campaigns
      const { data: linked } = await supabase
        .from("campaigns")
        .select("provider_campaign_id, instantly_campaign_id")
        .eq("provider_type", selectedProvider);

      const linkedIds = new Set<string>();
      (linked || []).forEach((c) => {
        if (c.provider_campaign_id) linkedIds.add(c.provider_campaign_id);
        if (c.instantly_campaign_id) linkedIds.add(c.instantly_campaign_id);
      });
      setLinkedCampaignIds(linkedIds);

      if ((data.campaigns || []).length === 0) {
        setLoadError("No campaigns found in this account.");
      }
    } catch (error) {
      console.error("Error loading campaigns:", error);
      setLoadError("Failed to connect. Please check your API key.");
      setApiKeyValid(false);
    } finally {
      setLoadingCampaigns(false);
    }
  };

  // Reset when provider changes
  const handleProviderChange = (provider: ProviderType) => {
    setSelectedProvider(provider);
    setApiKey("");
    setApiKeyValid(null);
    setCampaigns([]);
    setSelectedCampaignId("");
    setLoadError(null);
  };

  const selectedCampaign = campaigns.find((c) => c.id === selectedCampaignId);
  const availableCampaigns = campaigns.filter((c) => !linkedCampaignIds.has(c.id));

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!selectedCampaignId || !apiKey.trim()) return;

    const campaignName = customName.trim() || selectedCampaign?.name || "Unnamed Campaign";

    const { error } = await supabase.from("campaigns").insert({
      client_id: clientId,
      name: campaignName,
      original_name: selectedCampaign?.name,
      provider_type: selectedProvider,
      provider_campaign_id: selectedCampaignId,
      instantly_campaign_id: selectedProvider === "instantly" ? selectedCampaignId : null,
      api_key_encrypted: apiKey.trim(),
      is_active: selectedCampaign?.status === "active",
    });

    if (error) {
      console.error("Error creating campaign:", error);
      alert("Failed to link campaign: " + error.message);
      return;
    }

    setLinkedCampaignName(campaignName);
    setStep("success");

    startTransition(() => {
      router.refresh();
    });
  };

  const handleClose = () => {
    setOpen(false);
    setTimeout(() => {
      setStep("select");
      setSelectedProvider("instantly");
      setApiKey("");
      setApiKeyValid(null);
      setCampaigns([]);
      setSelectedCampaignId("");
      setCustomName("");
      setCopied(false);
      setLoadError(null);
    }, 200);
  };

  const copyWebhookUrl = async () => {
    await navigator.clipboard.writeText(webhookUrl);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const getProviderSettingsUrl = () => {
    switch (selectedProvider) {
      case "instantly":
        return "https://app.instantly.ai/app/settings/integrations";
      case "smartlead":
        return "https://app.smartlead.ai/settings/integrations";
      default:
        return "#";
    }
  };

  return (
    <Dialog open={open} onOpenChange={(isOpen) => (isOpen ? setOpen(true) : handleClose())}>
      <DialogTrigger asChild>
        <Button onClick={() => setOpen(true)}>Link Campaign</Button>
      </DialogTrigger>
      <DialogContent className="max-w-lg">
        {step === "success" ? (
          <>
            <DialogHeader>
              <DialogTitle className="text-green-600">Campaign Linked!</DialogTitle>
              <DialogDescription>
                <strong>{linkedCampaignName}</strong> has been linked successfully.
              </DialogDescription>
            </DialogHeader>
            <div className="py-4 space-y-4">
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                <h4 className="font-medium text-blue-900 mb-2">
                  Set up Webhook in {selectedProvider === "instantly" ? "Instantly" : "Smartlead"}
                </h4>
                <p className="text-sm text-blue-800 mb-3">
                  To receive real-time updates (opens, clicks, replies), add this webhook URL in your{" "}
                  {selectedProvider === "instantly" ? "Instantly" : "Smartlead"} campaign settings:
                </p>
                <div className="flex gap-2">
                  <Input value={webhookUrl} readOnly className="bg-white text-sm font-mono" />
                  <Button type="button" variant="outline" size="icon" onClick={copyWebhookUrl}>
                    {copied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                  </Button>
                </div>
              </div>

              <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                <h4 className="font-medium text-yellow-900 mb-2">Webhook Events to Enable</h4>
                {selectedProvider === "instantly" ? (
                  <ul className="text-sm text-yellow-800 space-y-1">
                    <li>- <strong>reply_received</strong> - When lead replies</li>
                    <li>- <strong>lead_interested</strong> - Positive reply detected</li>
                    <li>- <strong>email_opened</strong> - When email is opened</li>
                    <li>- <strong>link_clicked</strong> - When link is clicked</li>
                    <li>- <strong>email_sent</strong> - When email is sent</li>
                  </ul>
                ) : (
                  <ul className="text-sm text-yellow-800 space-y-1">
                    <li>- <strong>EMAIL_REPLY</strong> - When lead replies</li>
                    <li>- <strong>LEAD_CATEGORY_UPDATED</strong> - Interest status changes</li>
                    <li>- <strong>EMAIL_OPEN</strong> - When email is opened</li>
                    <li>- <strong>EMAIL_LINK_CLICK</strong> - When link is clicked</li>
                    <li>- <strong>EMAIL_SENT</strong> - When email is sent</li>
                    <li>- <strong>LEAD_UNSUBSCRIBED</strong> - When lead unsubscribes</li>
                  </ul>
                )}
              </div>

              <a
                href={getProviderSettingsUrl()}
                target="_blank"
                rel="noopener noreferrer"
                className="flex items-center gap-2 text-sm text-blue-600 hover:underline"
              >
                <ExternalLink className="h-4 w-4" />
                Open {selectedProvider === "instantly" ? "Instantly" : "Smartlead"} Webhook Settings
              </a>
            </div>
            <DialogFooter>
              <Button onClick={handleClose}>Done</Button>
            </DialogFooter>
          </>
        ) : (
          <form onSubmit={handleSubmit}>
            <DialogHeader>
              <DialogTitle>Link Campaign</DialogTitle>
              <DialogDescription>
                Connect a campaign from your email provider to this client.
              </DialogDescription>
            </DialogHeader>
            <div className="py-4 space-y-4">
              {/* Provider Selection */}
              <div>
                <Label>Email Provider</Label>
                <div className="grid grid-cols-2 gap-2 mt-2">
                  {PROVIDERS.map((provider) => (
                    <button
                      key={provider.value}
                      type="button"
                      disabled={!provider.available}
                      onClick={() => handleProviderChange(provider.value)}
                      className={`p-3 rounded-lg border text-left transition-colors ${
                        selectedProvider === provider.value
                          ? "border-blue-500 bg-blue-50 text-blue-700"
                          : provider.available
                          ? "border-gray-200 hover:border-gray-300"
                          : "border-gray-100 bg-gray-50 text-gray-400 cursor-not-allowed"
                      }`}
                    >
                      <div className="font-medium">{provider.label}</div>
                      {!provider.available && <div className="text-xs">Coming soon</div>}
                    </button>
                  ))}
                </div>
              </div>

              {/* API Key Input */}
              <div>
                <Label htmlFor="apiKey">API Key *</Label>
                <div className="flex gap-2 mt-1">
                  <div className="relative flex-1">
                    <Input
                      id="apiKey"
                      type="password"
                      value={apiKey}
                      onChange={(e) => {
                        setApiKey(e.target.value);
                        setApiKeyValid(null);
                        setCampaigns([]);
                        setLoadError(null);
                      }}
                      placeholder={`Enter your ${
                        selectedProvider === "instantly" ? "Instantly" : "Smartlead"
                      } API key`}
                      className="pr-10"
                    />
                    {apiKeyValid !== null && !loadingCampaigns && (
                      <div className="absolute right-3 top-1/2 -translate-y-1/2">
                        {apiKeyValid ? (
                          <CheckCircle2 className="h-5 w-5 text-green-500" />
                        ) : (
                          <XCircle className="h-5 w-5 text-red-500" />
                        )}
                      </div>
                    )}
                  </div>
                  <Button
                    type="button"
                    onClick={loadCampaigns}
                    disabled={!apiKey.trim() || loadingCampaigns}
                  >
                    {loadingCampaigns ? (
                      <Loader2 className="h-4 w-4 animate-spin" />
                    ) : (
                      "Load Campaigns"
                    )}
                  </Button>
                </div>
                <p className="text-xs text-gray-500 mt-1">
                  {selectedProvider === "instantly"
                    ? "Find your API key in Instantly Settings > Integrations > API"
                    : "Find your API key in Smartlead Settings > API"}
                </p>
                {loadError && (
                  <p className="text-xs text-red-500 mt-1">{loadError}</p>
                )}
              </div>

              {/* Campaign Selection - shows after loading */}
              {apiKeyValid && campaigns.length > 0 && (
                <>
                  <div className="border-t pt-4">
                    <Label htmlFor="campaign">Select Campaign *</Label>
                    {availableCampaigns.length === 0 ? (
                      <div className="mt-2 p-3 bg-gray-50 rounded-lg text-sm text-gray-500">
                        All campaigns from this account are already linked.
                      </div>
                    ) : (
                      <Select value={selectedCampaignId} onValueChange={setSelectedCampaignId}>
                        <SelectTrigger className="mt-1">
                          <SelectValue placeholder="Choose a campaign..." />
                        </SelectTrigger>
                        <SelectContent>
                          {availableCampaigns.map((campaign) => (
                            <SelectItem key={campaign.id} value={campaign.id}>
                              <div className="flex items-center gap-2">
                                <span
                                  className={`w-2 h-2 rounded-full ${
                                    campaign.status === "active" ? "bg-green-500" : "bg-gray-400"
                                  }`}
                                />
                                {campaign.name}
                                {campaign.leadsCount !== undefined && (
                                  <span className="text-gray-400 text-xs">({campaign.leadsCount} leads)</span>
                                )}
                              </div>
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    )}
                    <p className="text-xs text-gray-500 mt-1">
                      Found {campaigns.length} campaigns ({availableCampaigns.length} available)
                    </p>
                  </div>

                  {selectedCampaign && (
                    <div>
                      <Label htmlFor="customName">Display Name (Optional)</Label>
                      <Input
                        id="customName"
                        value={customName}
                        onChange={(e) => setCustomName(e.target.value)}
                        placeholder={selectedCampaign.name}
                        className="mt-1"
                      />
                      <p className="text-xs text-gray-500 mt-1">
                        Leave empty to use the original campaign name
                      </p>
                    </div>
                  )}
                </>
              )}
            </div>
            <DialogFooter>
              <Button type="button" variant="outline" onClick={handleClose}>
                Cancel
              </Button>
              <Button
                type="submit"
                disabled={isPending || !selectedCampaignId || !apiKeyValid}
              >
                {isPending ? "Linking..." : "Link Campaign"}
              </Button>
            </DialogFooter>
          </form>
        )}
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/app/admin/clients/[clientId]/settings/page.tsx">
"use client";

import { useState, useEffect, useRef } from "react";
import { useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { ArrowLeft, Upload, Save, Check, AlertCircle, RefreshCw, Trash2, UserPlus, Mail, X, Users } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import Link from "next/link";
import Image from "next/image";

interface ClientData {
  id: string;
  name: string;
  logo_url?: string;
  website?: string;
  notes?: string;
  product_service?: string;
  icp?: string;
  acv?: number;
  tcv?: number;
  verticals?: string[];
  tam?: number;
  target_daily_emails?: number;
}

interface ClientUser {
  user_id: string;
  role: string;
  created_at: string;
  profiles: {
    id: string;
    email: string;
    full_name: string | null;
  };
}

interface PendingInvitation {
  id: string;
  email: string;
  role: string;
  created_at: string;
  expires_at: string;
}

export default function ClientSettingsPage() {
  const params = useParams();
  const clientId = params.clientId as string;

  const [client, setClient] = useState<ClientData | null>(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const [name, setName] = useState("");
  const [website, setWebsite] = useState("");
  const [notes, setNotes] = useState("");
  const [logoFile, setLogoFile] = useState<File | null>(null);
  const [logoPreview, setLogoPreview] = useState<string | null>(null);
  const [uploadingLogo, setUploadingLogo] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Client Intelligence fields
  const [productService, setProductService] = useState("");
  const [icp, setIcp] = useState("");
  const [acv, setAcv] = useState("");
  const [tcv, setTcv] = useState("");
  const [verticals, setVerticals] = useState("");
  const [tam, setTam] = useState("");
  const [targetDailyEmails, setTargetDailyEmails] = useState("");

  // Team/Invitation state
  const [clientUsers, setClientUsers] = useState<ClientUser[]>([]);
  const [pendingInvitations, setPendingInvitations] = useState<PendingInvitation[]>([]);
  const [inviteEmail, setInviteEmail] = useState("");
  const [inviting, setInviting] = useState(false);
  const [inviteError, setInviteError] = useState<string | null>(null);
  const [inviteSuccess, setInviteSuccess] = useState<string | null>(null);
  const [removingUserId, setRemovingUserId] = useState<string | null>(null);

  useEffect(() => {
    fetchClient();
    fetchTeamMembers();
  }, [clientId]);

  const fetchTeamMembers = async () => {
    try {
      const res = await fetch(`/api/clients/${clientId}/invitations`);
      if (res.ok) {
        const data = await res.json();
        setClientUsers(data.users || []);
        setPendingInvitations(data.pendingInvitations || []);
      }
    } catch (err) {
      console.error("Failed to fetch team members:", err);
    }
  };

  const [inviteLink, setInviteLink] = useState<string | null>(null);

  const handleInvite = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inviteEmail.trim()) return;

    setInviting(true);
    setInviteError(null);
    setInviteSuccess(null);
    setInviteLink(null);

    try {
      const res = await fetch(`/api/clients/${clientId}/invitations`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email: inviteEmail.trim(), role: "owner" }),
      });

      const data = await res.json();

      if (res.ok) {
        setInviteSuccess(data.message || "Invitation created!");
        setInviteEmail("");
        fetchTeamMembers();

        // If email wasn't sent, show the login link
        if (data.loginUrl) {
          setInviteLink(data.loginUrl);
        } else {
          setTimeout(() => setInviteSuccess(null), 5000);
        }
      } else {
        setInviteError(data.error || "Failed to send invitation");
      }
    } catch (err) {
      setInviteError("Failed to send invitation");
    } finally {
      setInviting(false);
    }
  };

  const copyInviteLink = () => {
    if (inviteLink) {
      navigator.clipboard.writeText(inviteLink);
      setInviteSuccess("Link copied to clipboard!");
      setTimeout(() => {
        setInviteSuccess(null);
      }, 3000);
    }
  };

  const dismissInviteLink = () => {
    setInviteLink(null);
    setInviteSuccess(null);
  };

  const handleRemoveUser = async (userId: string) => {
    if (!confirm("Remove this user from the client?")) return;

    setRemovingUserId(userId);
    try {
      const res = await fetch(`/api/clients/${clientId}/invitations?userId=${userId}`, {
        method: "DELETE",
      });

      if (res.ok) {
        fetchTeamMembers();
      }
    } catch (err) {
      console.error("Failed to remove user:", err);
    } finally {
      setRemovingUserId(null);
    }
  };

  const handleCancelInvitation = async (invitationId: string) => {
    try {
      const res = await fetch(`/api/clients/${clientId}/invitations?invitationId=${invitationId}`, {
        method: "DELETE",
      });

      if (res.ok) {
        fetchTeamMembers();
      }
    } catch (err) {
      console.error("Failed to cancel invitation:", err);
    }
  };

  const fetchClient = async () => {
    try {
      const res = await fetch(`/api/clients/${clientId}`);
      if (res.ok) {
        const data = await res.json();
        const clientData = data.client;
        setClient(clientData);
        setName(clientData.name || "");
        setWebsite(clientData.website || "");
        setNotes(clientData.notes || "");
        if (clientData.logo_url) {
          setLogoPreview(clientData.logo_url);
        }
        // Load Client Intelligence fields
        setProductService(clientData.product_service || "");
        setIcp(clientData.icp || "");
        setAcv(clientData.acv ? String(clientData.acv) : "");
        setTcv(clientData.tcv ? String(clientData.tcv) : "");
        setVerticals(clientData.verticals ? clientData.verticals.join(", ") : "");
        setTam(clientData.tam ? String(clientData.tam) : "");
        setTargetDailyEmails(clientData.target_daily_emails ? String(clientData.target_daily_emails) : "");
      } else {
        setError("Failed to load client");
      }
    } catch (err) {
      setError("Failed to load client");
    } finally {
      setLoading(false);
    }
  };

  const handleLogoChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setLogoFile(file);
      const reader = new FileReader();
      reader.onloadend = () => {
        setLogoPreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleLogoUpload = async () => {
    if (!logoFile) return;

    setUploadingLogo(true);
    setError(null);
    try {
      const formData = new FormData();
      formData.append("file", logoFile);

      const res = await fetch(`/api/clients/${clientId}/logo`, {
        method: "POST",
        body: formData,
      });

      if (res.ok) {
        const data = await res.json();
        setLogoPreview(data.url);
        setLogoFile(null);
        setSuccess("Logo uploaded successfully");
        setTimeout(() => setSuccess(null), 3000);
      } else {
        const data = await res.json();
        setError(data.error || "Failed to upload logo");
      }
    } catch (err) {
      setError("Failed to upload logo");
    } finally {
      setUploadingLogo(false);
    }
  };

  const handleRemoveLogo = async () => {
    if (!confirm("Remove the client logo?")) return;

    try {
      const res = await fetch(`/api/clients/${clientId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ logo_url: null }),
      });

      if (res.ok) {
        setLogoPreview(null);
        setSuccess("Logo removed");
        setTimeout(() => setSuccess(null), 3000);
      }
    } catch (err) {
      setError("Failed to remove logo");
    }
  };

  const handleSave = async () => {
    setSaving(true);
    setError(null);
    setSuccess(null);

    try {
      // Parse verticals from comma-separated string
      const verticalsArray = verticals
        .split(",")
        .map((v) => v.trim())
        .filter((v) => v.length > 0);

      const res = await fetch(`/api/clients/${clientId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: name.trim(),
          website: website.trim() || null,
          notes: notes.trim() || null,
          product_service: productService.trim() || null,
          icp: icp.trim() || null,
          acv: acv ? parseFloat(acv) : null,
          tcv: tcv ? parseFloat(tcv) : null,
          verticals: verticalsArray.length > 0 ? verticalsArray : null,
          tam: tam ? parseInt(tam, 10) : null,
          target_daily_emails: targetDailyEmails ? parseInt(targetDailyEmails, 10) : null,
        }),
      });

      if (res.ok) {
        setSuccess("Settings saved successfully");
        setTimeout(() => setSuccess(null), 3000);
        fetchClient();
      } else {
        const data = await res.json();
        setError(data.error || "Failed to save settings");
      }
    } catch (err) {
      setError("Failed to save settings");
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <RefreshCw className="h-8 w-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (!client) {
    return (
      <div className="space-y-4">
        <Link
          href="/admin"
          className="text-sm text-muted-foreground hover:text-foreground flex items-center gap-1"
        >
          <ArrowLeft className="h-4 w-4" />
          Back to Command Center
        </Link>
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">
          Client not found
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6 max-w-2xl">
      <div>
        <Link
          href={`/admin/clients/${clientId}`}
          className="text-sm text-muted-foreground hover:text-foreground flex items-center gap-1 mb-2"
        >
          <ArrowLeft className="h-4 w-4" />
          Back to {client.name}
        </Link>
        <h1 className="text-2xl font-bold">Client Settings</h1>
        <p className="text-muted-foreground">Configure settings for {client.name}</p>
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg flex items-center gap-2">
          <AlertCircle className="h-4 w-4" />
          {error}
        </div>
      )}

      {success && (
        <div className="bg-green-50 border border-green-200 text-green-700 px-4 py-3 rounded-lg flex items-center gap-2">
          <Check className="h-4 w-4" />
          {success}
        </div>
      )}

      {/* Client Logo */}
      <Card>
        <CardHeader>
          <CardTitle>Client Logo</CardTitle>
          <CardDescription>
            Upload a logo for this client to display in their dashboard
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center gap-6">
            <div className="w-24 h-24 border-2 border-dashed border-gray-200 rounded-lg flex items-center justify-center overflow-hidden bg-gray-50">
              {logoPreview ? (
                <Image
                  src={logoPreview}
                  alt="Client logo"
                  width={96}
                  height={96}
                  className="object-contain w-full h-full"
                  unoptimized={logoPreview.startsWith("data:")}
                />
              ) : (
                <div className="w-12 h-12 rounded-full bg-muted flex items-center justify-center">
                  <span className="text-lg font-bold text-muted-foreground">
                    {client.name.charAt(0).toUpperCase()}
                  </span>
                </div>
              )}
            </div>
            <div className="space-y-2">
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleLogoChange}
                accept="image/*"
                className="hidden"
              />
              <div className="flex gap-2">
                <Button
                  variant="outline"
                  onClick={() => fileInputRef.current?.click()}
                >
                  <Upload className="h-4 w-4 mr-2" />
                  {logoPreview ? "Change Logo" : "Upload Logo"}
                </Button>
                {logoFile && (
                  <Button onClick={handleLogoUpload} disabled={uploadingLogo}>
                    {uploadingLogo ? (
                      <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                    ) : (
                      <Check className="h-4 w-4 mr-2" />
                    )}
                    Save
                  </Button>
                )}
                {logoPreview && !logoFile && (
                  <Button variant="outline" onClick={handleRemoveLogo}>
                    <Trash2 className="h-4 w-4 mr-2" />
                    Remove
                  </Button>
                )}
              </div>
              <p className="text-xs text-muted-foreground">
                Recommended: 200x200px, PNG or JPG
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Client Details */}
      <Card>
        <CardHeader>
          <CardTitle>Client Details</CardTitle>
          <CardDescription>
            Basic information about this client
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="name">Client Name</Label>
            <Input
              id="name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="Enter client name"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="website">Website</Label>
            <Input
              id="website"
              value={website}
              onChange={(e) => setWebsite(e.target.value)}
              placeholder="https://example.com"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="notes">Notes</Label>
            <Textarea
              id="notes"
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              placeholder="Internal notes about this client..."
              rows={4}
            />
          </div>
        </CardContent>
      </Card>

      {/* Client Intelligence */}
      <Card>
        <CardHeader>
          <CardTitle>Client Intelligence</CardTitle>
          <CardDescription>
            Business details for campaign planning and email recommendations
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="productService">The Offer (Product/Service)</Label>
            <Textarea
              id="productService"
              value={productService}
              onChange={(e) => setProductService(e.target.value)}
              placeholder="Describe what you're offering - the core value proposition..."
              rows={3}
            />
            <p className="text-xs text-muted-foreground">What problem does this solve? What&apos;s the main benefit?</p>
          </div>

          <div className="space-y-2">
            <Label htmlFor="icp">Ideal Customer Profile (ICP)</Label>
            <Textarea
              id="icp"
              value={icp}
              onChange={(e) => setIcp(e.target.value)}
              placeholder="e.g., B2B SaaS companies with 50-500 employees, Series A-C funded, in the US/EU, looking to scale their sales team..."
              rows={4}
            />
            <p className="text-xs text-muted-foreground">Describe the ideal target customer: company size, industry, geography, pain points, etc.</p>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="acv">ACV (Annual Contract Value)</Label>
              <Input
                id="acv"
                type="number"
                value={acv}
                onChange={(e) => setAcv(e.target.value)}
                placeholder="e.g., 50000"
              />
              <p className="text-xs text-muted-foreground">Average annual value per deal</p>
            </div>
            <div className="space-y-2">
              <Label htmlFor="tcv">TCV (Total Contract Value)</Label>
              <Input
                id="tcv"
                type="number"
                value={tcv}
                onChange={(e) => setTcv(e.target.value)}
                placeholder="e.g., 150000"
              />
              <p className="text-xs text-muted-foreground">Total value over contract lifetime</p>
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="verticals">Target Verticals</Label>
            <Input
              id="verticals"
              value={verticals}
              onChange={(e) => setVerticals(e.target.value)}
              placeholder="e.g., SaaS, Healthcare, FinTech"
            />
            <p className="text-xs text-muted-foreground">Comma-separated list of industries</p>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="tam">TAM (Total Addressable Market)</Label>
              <Input
                id="tam"
                type="number"
                value={tam}
                onChange={(e) => setTam(e.target.value)}
                placeholder="e.g., 5000"
              />
              <p className="text-xs text-muted-foreground">Total number of potential leads</p>
            </div>
            <div className="space-y-2">
              <Label htmlFor="targetDailyEmails">Target Daily Emails</Label>
              <Input
                id="targetDailyEmails"
                type="number"
                value={targetDailyEmails}
                onChange={(e) => setTargetDailyEmails(e.target.value)}
                placeholder="e.g., 100"
              />
              <p className="text-xs text-muted-foreground">Recommended daily send volume</p>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Team Access */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Users className="h-5 w-5" />
            Team Access
          </CardTitle>
          <CardDescription>
            Invite client owners to access their dashboard
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* Invite Form */}
          <form onSubmit={handleInvite} className="space-y-4">
            <div className="flex gap-2">
              <div className="flex-1">
                <Input
                  type="email"
                  value={inviteEmail}
                  onChange={(e) => setInviteEmail(e.target.value)}
                  placeholder="email@example.com"
                  disabled={inviting}
                />
              </div>
              <Button type="submit" disabled={inviting || !inviteEmail.trim()}>
                {inviting ? (
                  <RefreshCw className="h-4 w-4 animate-spin mr-2" />
                ) : (
                  <UserPlus className="h-4 w-4 mr-2" />
                )}
                Invite
              </Button>
            </div>

            {inviteError && (
              <div className="bg-red-50 border border-red-200 text-red-700 px-3 py-2 rounded-lg text-sm flex items-center gap-2">
                <AlertCircle className="h-4 w-4" />
                {inviteError}
              </div>
            )}

            {inviteSuccess && (
              <div className="bg-green-50 border border-green-200 text-green-700 px-3 py-2 rounded-lg text-sm flex items-center gap-2">
                <Check className="h-4 w-4" />
                {inviteSuccess}
              </div>
            )}

            {inviteLink && (
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 space-y-3">
                <div className="flex items-start justify-between gap-2">
                  <div className="flex items-start gap-2">
                    <Mail className="h-5 w-5 text-blue-600 mt-0.5" />
                    <div>
                      <p className="text-sm font-medium text-blue-800">Share this link with the user</p>
                      <p className="text-xs text-blue-600 mt-1">
                        Copy and send this link via email, Slack, or any messaging app.
                      </p>
                    </div>
                  </div>
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={dismissInviteLink}
                    className="text-blue-600 hover:text-blue-800 hover:bg-blue-100 -mr-2 -mt-2"
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
                <div className="flex gap-2">
                  <Input
                    value={inviteLink}
                    readOnly
                    className="text-xs bg-white font-mono"
                  />
                  <Button
                    type="button"
                    variant="outline"
                    onClick={copyInviteLink}
                    className="shrink-0"
                  >
                    Copy Link
                  </Button>
                </div>
              </div>
            )}
          </form>

          {/* Current Team Members */}
          {clientUsers.length > 0 && (
            <div className="space-y-2">
              <h4 className="text-sm font-medium text-muted-foreground">Active Members</h4>
              <div className="space-y-2">
                {clientUsers.map((cu) => (
                  <div
                    key={cu.user_id}
                    className="flex items-center justify-between p-3 bg-muted/50 rounded-lg"
                  >
                    <div className="flex items-center gap-3">
                      <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                        <span className="text-sm font-medium text-primary">
                          {cu.profiles?.email?.charAt(0).toUpperCase() || "?"}
                        </span>
                      </div>
                      <div>
                        <p className="text-sm font-medium">
                          {cu.profiles?.full_name || cu.profiles?.email || "Unknown"}
                        </p>
                        {cu.profiles?.full_name && cu.profiles?.email && (
                          <p className="text-xs text-muted-foreground">{cu.profiles.email}</p>
                        )}
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <Badge variant="secondary">{cu.role || "owner"}</Badge>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleRemoveUser(cu.user_id)}
                        disabled={removingUserId === cu.user_id}
                        className="text-muted-foreground hover:text-red-600"
                      >
                        {removingUserId === cu.user_id ? (
                          <RefreshCw className="h-4 w-4 animate-spin" />
                        ) : (
                          <X className="h-4 w-4" />
                        )}
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Pending Invitations */}
          {pendingInvitations.length > 0 && (
            <div className="space-y-2">
              <h4 className="text-sm font-medium text-muted-foreground">Pending Invitations</h4>
              <div className="space-y-2">
                {pendingInvitations.map((inv) => (
                  <div
                    key={inv.id}
                    className="flex items-center justify-between p-3 bg-amber-50 dark:bg-amber-950/30 rounded-lg border border-amber-200 dark:border-amber-800"
                  >
                    <div className="flex items-center gap-3">
                      <div className="w-8 h-8 rounded-full bg-amber-100 dark:bg-amber-900 flex items-center justify-center">
                        <Mail className="h-4 w-4 text-amber-600" />
                      </div>
                      <div>
                        <p className="text-sm font-medium">{inv.email}</p>
                        <p className="text-xs text-muted-foreground">
                          Expires: {new Date(inv.expires_at).toLocaleDateString()}
                        </p>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <Badge variant="outline" className="text-amber-600 border-amber-300">
                        Pending
                      </Badge>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleCancelInvitation(inv.id)}
                        className="text-muted-foreground hover:text-red-600"
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {clientUsers.length === 0 && pendingInvitations.length === 0 && (
            <div className="text-center py-6 text-muted-foreground">
              <Users className="h-8 w-8 mx-auto mb-2 opacity-50" />
              <p className="text-sm">No team members yet</p>
              <p className="text-xs mt-1">Invite client owners to give them access to their dashboard</p>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Save Button */}
      <div className="flex justify-end">
        <Button onClick={handleSave} disabled={saving}>
          <Save className="h-4 w-4 mr-2" />
          {saving ? "Saving..." : "Save Settings"}
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/app/api/admin/customers/route.ts">
import { createClient } from "@/lib/supabase/server";
import { NextResponse } from "next/server";

export async function GET() {
  try {
    const supabase = await createClient();

    // Verify admin access
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    if (profile?.role !== "admin") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // Fetch all clients with campaign counts and lead stats
    const { data: clients, error } = await supabase
      .from("clients")
      .select(`
        *,
        campaigns(
          id,
          instantly_campaign_id,
          is_active
        )
      `)
      .order("created_at", { ascending: false });

    if (error) {
      console.error("Error fetching clients:", error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Transform the data to include campaign counts
    const customers = (clients || []).map((client) => {
      const campaigns = client.campaigns || [];
      return {
        id: client.id,
        name: client.name,
        logo_url: client.logo_url || null,
        is_active: true, // All clients are active by default
        created_at: client.created_at,
        campaigns_count: campaigns.length,
        total_leads: 0, // Will be populated from Instantly data if available
        total_emails_sent: 0,
        reply_rate: 0,
      };
    });

    return NextResponse.json({ customers });
  } catch (error) {
    console.error("Error in customers GET:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const supabase = await createClient();

    // Verify admin access
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    if (profile?.role !== "admin") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const body = await request.json();
    const { name, instantly_api_key, webhook_secret } = body;

    if (!name || typeof name !== "string" || name.trim().length === 0) {
      return NextResponse.json(
        { error: "Customer name is required" },
        { status: 400 }
      );
    }

    // Build insert data with optional fields
    const insertData: Record<string, string> = { name: name.trim() };

    if (instantly_api_key && typeof instantly_api_key === "string") {
      insertData.instantly_api_key = instantly_api_key.trim();
    }

    if (webhook_secret && typeof webhook_secret === "string") {
      insertData.webhook_secret = webhook_secret.trim();
    }

    const { data: client, error } = await supabase
      .from("clients")
      .insert(insertData)
      .select()
      .single();

    if (error) {
      console.error("Error creating client:", error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ customer: client }, { status: 201 });
  } catch (error) {
    console.error("Error in customers POST:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/leads/[leadId]/emails/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { fetchEmailsForLead, getInstantlyClient } from "@/lib/instantly";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - Fetch emails from database for a lead
export async function GET(
  request: Request,
  { params }: { params: Promise<{ leadId: string }> }
) {
  try {
    const { leadId } = await params;
    const supabase = getSupabase();

    // Get lead to find the email
    const { data: lead, error: leadError } = await supabase
      .from("leads")
      .select("id, email, campaign_id")
      .eq("id", leadId)
      .single();

    if (leadError || !lead) {
      return NextResponse.json({ error: "Lead not found" }, { status: 404 });
    }

    // Fetch emails from database
    const { data: emails, error: emailsError } = await supabase
      .from("lead_emails")
      .select("*")
      .eq("lead_id", leadId)
      .order("sent_at", { ascending: true });

    if (emailsError) {
      console.error("Error fetching emails:", emailsError);
      return NextResponse.json(
        { error: "Failed to fetch emails" },
        { status: 500 }
      );
    }

    return NextResponse.json({ emails: emails || [] });
  } catch (error) {
    console.error("Error in GET /api/leads/[leadId]/emails:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch emails" },
      { status: 500 }
    );
  }
}

// POST - Sync emails from Instantly for a lead
export async function POST(
  request: Request,
  { params }: { params: Promise<{ leadId: string }> }
) {
  try {
    const { leadId } = await params;
    const supabase = getSupabase();

    // Check if Instantly is configured
    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    // Get lead info with campaign's Instantly ID
    const { data: lead, error: leadError } = await supabase
      .from("leads")
      .select("id, email, campaign_id, campaigns(instantly_campaign_id)")
      .eq("id", leadId)
      .single();

    if (leadError || !lead) {
      return NextResponse.json({ error: "Lead not found" }, { status: 404 });
    }

    // Get the Instantly campaign ID from the joined data
    // The campaigns relation returns an object when using .single() on leads
    const campaignData = lead.campaigns as unknown as { instantly_campaign_id: string | null } | null;
    const instantlyCampaignId = campaignData?.instantly_campaign_id;

    console.log(`[Email Sync] Lead: ${lead.email}, Instantly Campaign: ${instantlyCampaignId}`);

    // Fetch emails from Instantly - pass campaign ID for more accurate results
    const instantlyEmails = await fetchEmailsForLead(lead.email, instantlyCampaignId || undefined);

    let imported = 0;
    let skipped = 0;

    for (const email of instantlyEmails) {
      // Check if email already exists
      const { data: existing } = await supabase
        .from("lead_emails")
        .select("id")
        .eq("lead_id", leadId)
        .eq("provider_email_id", email.id)
        .single();

      if (existing) {
        skipped++;
        continue;
      }

      // Determine direction based on from/to emails
      const isOutbound = email.from_address_email !== lead.email;
      const toEmail = email.to_address_email_list?.[0] || lead.email;

      // Insert email
      const { error: insertError } = await supabase.from("lead_emails").insert({
        lead_id: leadId,
        campaign_id: lead.campaign_id,
        provider_email_id: email.id,
        provider_thread_id: email.thread_id || null,
        direction: isOutbound ? "outbound" : "inbound",
        from_email: email.from_address_email || "",
        to_email: toEmail,
        subject: email.subject || null,
        body_text: email.body?.text || null,
        body_html: email.body?.html || email.body?.text || null,
        sequence_step: null,
        is_auto_reply: false,
        sent_at: email.timestamp_email || email.timestamp_created || null,
        metadata: {
          instantly_data: {
            campaign_id: email.i_campaign,
            eaccount: email.eaccount,
            is_reply: email.is_reply,
          },
        },
      });

      if (insertError) {
        console.error("Failed to insert email:", insertError);
      } else {
        imported++;
      }
    }

    return NextResponse.json({
      success: true,
      imported,
      skipped,
      total: instantlyEmails.length,
    });
  } catch (error) {
    console.error("Error in POST /api/leads/[leadId]/emails:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to sync emails" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/lib/providers/instantly/index.ts">
// Instantly Provider Implementation
// Implements EmailCampaignProvider interface with per-campaign API key

import { InstantlyApiClient } from "./client";
import type {
  EmailCampaignProvider,
  ProviderCampaign,
  ProviderCampaignDetails,
  ProviderLead,
  ProviderLeadCreatePayload,
  ProviderCampaignAnalytics,
  ProviderDailyAnalytics,
  ProviderEmail,
  ProviderWebhookPayload,
  ProviderSequence,
  ProviderSequenceStep,
  WebhookEventType,
} from "../types";
import { ProviderError } from "../types";
import crypto from "crypto";

// Instantly-specific types (internal)
interface InstantlyCampaign {
  id: string;
  name: string;
  status: number | "active" | "paused" | "completed" | "draft";
  created_at: string;
  updated_at?: string;
  leads_count?: number;
  emails_sent_count?: number;
  replies_count?: number;
  bounces_count?: number;
  sequences?: InstantlySequence[];
  email_gap?: number;
  daily_limit?: number;
  stop_on_reply?: boolean;
  link_tracking?: boolean;
  open_tracking?: boolean;
}

interface InstantlySequence {
  steps: InstantlySequenceStep[];
}

interface InstantlySequenceStep {
  type?: string;
  delay?: number;
  variants?: { subject?: string; body?: string; v_disabled?: boolean }[];
  subject?: string;
  body?: string;
}

interface InstantlyLead {
  id: string;
  email: string;
  first_name?: string;
  last_name?: string;
  company_name?: string;
  phone?: string;
  website?: string;
  campaign_id?: string;
  status?: string;
  interest_status?: string;
  lead_data?: Record<string, string>;
  created_at?: string;
  updated_at?: string;
}

interface InstantlyAnalytics {
  campaign_id: string;
  campaign_name: string;
  leads_count: number;
  contacted_count: number;
  completed_count: number;
  emails_sent_count: number;
  open_count: number;
  open_count_unique: number;
  reply_count: number;
  reply_count_unique: number;
  link_click_count: number;
  link_click_count_unique: number;
  bounced_count: number;
  unsubscribed_count: number;
  total_opportunities?: number;
  total_interested?: number;
  total_meeting_booked?: number;
  total_closed?: number;
}

interface InstantlyDailyAnalytics {
  date: string;
  sent: number;
  opened: number;
  unique_opened: number;
  replies: number;
  unique_replies: number;
  clicks: number;
  unique_clicks: number;
}

interface InstantlyEmail {
  id: string;
  from_address_email: string;
  to_address_email_list: string[];
  cc_address_email_list?: string[];
  bcc_address_email_list?: string[];
  subject: string;
  body?: { text?: string; html?: string };
  thread_id?: string;
  i_campaign?: string;
  lead_email?: string;
  is_reply?: boolean;
  timestamp_email?: string;
  timestamp_created?: string;
}

export class InstantlyProvider implements EmailCampaignProvider {
  readonly providerType = "instantly" as const;
  private client: InstantlyApiClient;

  constructor(apiKey: string) {
    this.client = new InstantlyApiClient(apiKey);
  }

  // ============================================
  // API KEY VALIDATION
  // ============================================

  async validateApiKey(): Promise<boolean> {
    try {
      // Try to fetch campaigns - if it works, the key is valid
      await this.client.get<{ items: unknown[] }>("/campaigns", { limit: 1 });
      return true;
    } catch (error) {
      if (error instanceof ProviderError && error.statusCode === 401) {
        return false;
      }
      throw error;
    }
  }

  // ============================================
  // CAMPAIGN OPERATIONS
  // ============================================

  async fetchCampaigns(): Promise<ProviderCampaign[]> {
    const allCampaigns: ProviderCampaign[] = [];
    let skip = 0;
    const limit = 100;

    while (true) {
      const response = await this.client.get<{ items: InstantlyCampaign[] }>(
        "/campaigns",
        { limit, skip }
      );
      const campaigns = response.items || [];

      allCampaigns.push(...campaigns.map((c) => this.mapCampaign(c)));

      if (campaigns.length < limit) {
        break;
      }
      skip += limit;
    }

    return allCampaigns;
  }

  async fetchCampaign(campaignId: string): Promise<ProviderCampaignDetails> {
    const campaign = await this.client.get<InstantlyCampaign>(
      `/campaigns/${campaignId}`
    );
    return this.mapCampaignDetails(campaign);
  }

  private mapCampaign(c: InstantlyCampaign): ProviderCampaign {
    return {
      id: c.id,
      name: c.name,
      status: this.normalizeStatus(c.status),
      createdAt: c.created_at,
      updatedAt: c.updated_at,
      leadsCount: c.leads_count,
      emailsSentCount: c.emails_sent_count,
      repliesCount: c.replies_count,
      bouncesCount: c.bounces_count,
    };
  }

  private mapCampaignDetails(c: InstantlyCampaign): ProviderCampaignDetails {
    return {
      ...this.mapCampaign(c),
      sequences: c.sequences?.map((s) => this.mapSequence(s)) || [],
      emailGap: c.email_gap,
      dailyLimit: c.daily_limit,
      stopOnReply: c.stop_on_reply,
      linkTracking: c.link_tracking,
      openTracking: c.open_tracking,
    };
  }

  private mapSequence(s: InstantlySequence): ProviderSequence {
    return {
      steps: s.steps.map((step, index) => this.mapSequenceStep(step, index)),
    };
  }

  private mapSequenceStep(
    step: InstantlySequenceStep,
    index: number
  ): ProviderSequenceStep {
    return {
      stepNumber: index + 1,
      delayDays: step.delay || 0,
      variants:
        step.variants?.map((v) => ({
          subject: v.subject,
          body: v.body,
          isActive: !v.v_disabled,
        })) || [],
    };
  }

  private normalizeStatus(
    status: number | string
  ): "active" | "paused" | "draft" | "completed" {
    if (typeof status === "number") {
      return status === 1 ? "active" : "paused";
    }
    if (["active", "paused", "draft", "completed"].includes(status)) {
      return status as "active" | "paused" | "draft" | "completed";
    }
    return "paused";
  }

  // ============================================
  // LEAD OPERATIONS
  // ============================================

  async fetchLeads(
    campaignId: string,
    options?: { limit?: number; offset?: number }
  ): Promise<ProviderLead[]> {
    console.log(`[InstantlyProvider] Fetching leads for campaign ${campaignId}`);
    const response = await this.client.post<{ items: InstantlyLead[] }>(
      "/leads/list",
      {
        campaign_id: campaignId,
        limit: options?.limit || 100,
        skip: options?.offset || 0,
      }
    );
    console.log(`[InstantlyProvider] Got ${response.items?.length || 0} leads`);
    return (response.items || []).map((l) => this.mapLead(l));
  }

  async fetchAllLeads(campaignId: string): Promise<ProviderLead[]> {
    const limit = 100;
    const concurrency = 5; // Stay well under 10 req/s rate limit

    // First, get total count from analytics to know how many pages we need
    let expectedLeads = 0;
    try {
      const analytics = await this.fetchCampaignAnalytics(campaignId);
      expectedLeads = analytics.leadsCount || 0;
      console.log(`[InstantlyProvider] Campaign ${campaignId} has ${expectedLeads} leads according to analytics`);
    } catch (err) {
      // If analytics fails, fall back to sequential fetching
      console.log(`[InstantlyProvider] Could not get lead count, using sequential fetch. Error:`, err);
      return this.fetchAllLeadsSequential(campaignId);
    }

    if (expectedLeads === 0) {
      return [];
    }

    // Calculate total pages needed
    const totalPages = Math.ceil(expectedLeads / limit);
    // Safety cap: never fetch more than 1.1x the expected leads (allow 10% margin)
    const maxLeads = Math.ceil(expectedLeads * 1.1);
    console.log(`[InstantlyProvider] Fetching ${expectedLeads} leads in ${totalPages} pages (${concurrency} concurrent, max ${maxLeads})`);

    // If only a few pages, just do sequential
    if (totalPages <= 3) {
      return this.fetchAllLeadsSequential(campaignId);
    }

    // Fetch in parallel batches
    const allLeads: ProviderLead[] = [];
    const pageOffsets = Array.from({ length: totalPages }, (_, i) => i * limit);

    for (let i = 0; i < pageOffsets.length; i += concurrency) {
      const batch = pageOffsets.slice(i, i + concurrency);
      const batchPromises = batch.map((offset) =>
        this.fetchLeads(campaignId, { limit, offset })
      );

      const batchResults = await Promise.all(batchPromises);
      for (const leads of batchResults) {
        allLeads.push(...leads);
      }

      // Safety check: stop if we've exceeded expected count
      if (allLeads.length > maxLeads) {
        console.warn(`[InstantlyProvider] WARNING: Fetched ${allLeads.length} leads, exceeds expected ${expectedLeads}. Stopping.`);
        break;
      }

      // Small delay between batches to stay under rate limit
      if (i + concurrency < pageOffsets.length) {
        await new Promise((resolve) => setTimeout(resolve, 200));
      }
    }

    console.log(`[InstantlyProvider] Fetched ${allLeads.length} leads total (expected: ${expectedLeads})`);
    return allLeads;
  }

  // Sequential fallback for when we can't determine total count
  private async fetchAllLeadsSequential(campaignId: string): Promise<ProviderLead[]> {
    const allLeads: ProviderLead[] = [];
    let skip = 0;
    const limit = 100;

    while (true) {
      const leads = await this.fetchLeads(campaignId, { limit, offset: skip });
      allLeads.push(...leads);

      if (leads.length < limit) {
        break;
      }
      skip += limit;
    }

    return allLeads;
  }

  // Fetch only positive/interested leads (all positive statuses)
  async fetchPositiveLeads(campaignId: string): Promise<ProviderLead[]> {
    const allPositiveLeads: ProviderLead[] = [];
    const limit = 100;

    // Instantly interest_status values:
    // 1 = Interested, 3 = Meeting Booked, 4 = Meeting Completed, 5 = Closed
    const positiveStatuses = [1, 3, 4, 5];

    for (const status of positiveStatuses) {
      let skip = 0;
      console.log(`[InstantlyProvider] Fetching leads with interest_status=${status} for campaign ${campaignId}`);

      while (true) {
        const response = await this.client.post<{ items: InstantlyLead[] }>(
          "/leads/list",
          {
            campaign_id: campaignId,
            interest_status: status,
            limit,
            skip,
          }
        );
        const leads = (response.items || []).map((l) => ({
          ...this.mapLead(l),
          interestStatus: this.mapInterestStatus(status),
        }));
        allPositiveLeads.push(...leads);

        if (leads.length < limit) {
          break;
        }
        skip += limit;
      }
    }

    console.log(`[InstantlyProvider] Found ${allPositiveLeads.length} total positive leads`);
    return allPositiveLeads;
  }

  private mapInterestStatus(status: number): ProviderLead["interestStatus"] {
    switch (status) {
      case 1: return "interested";
      case 2: return "not_interested";
      case 3: return "meeting_booked";
      case 4: return "meeting_completed";
      case 5: return "closed";
      default: return undefined;
    }
  }

  async createLead(
    campaignId: string,
    lead: ProviderLeadCreatePayload
  ): Promise<ProviderLead> {
    const response = await this.client.post<InstantlyLead>("/leads", {
      campaign_id: campaignId,
      email: lead.email,
      first_name: lead.firstName,
      last_name: lead.lastName,
      company_name: lead.companyName,
      phone: lead.phone,
      website: lead.website,
      custom_variables: lead.customVariables,
      skip_if_in_campaign: lead.skipIfInCampaign,
      skip_if_in_workspace: lead.skipIfInWorkspace,
    });
    return this.mapLead(response);
  }

  async createLeads(
    campaignId: string,
    leads: ProviderLeadCreatePayload[]
  ): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const lead of leads) {
      try {
        await this.createLead(campaignId, lead);
        success++;
      } catch (error) {
        console.error(`[Instantly] Failed to create lead ${lead.email}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  async updateLeadInterestStatus(
    campaignId: string,
    email: string,
    status: "interested" | "not_interested" | "neutral"
  ): Promise<void> {
    await this.client.post("/leads/update-interest-status", {
      lead_email: email,
      campaign_id: campaignId,
      interest_status: status,
    });
  }

  private mapLead(l: InstantlyLead): ProviderLead {
    return {
      id: l.id,
      email: l.email,
      firstName: l.first_name,
      lastName: l.last_name,
      companyName: l.company_name,
      phone: l.phone,
      website: l.website,
      status: l.status,
      interestStatus: l.interest_status as ProviderLead["interestStatus"],
      createdAt: l.created_at,
      updatedAt: l.updated_at,
      customFields: l.lead_data,
    };
  }

  // ============================================
  // ANALYTICS
  // ============================================

  async fetchCampaignAnalytics(
    campaignId: string
  ): Promise<ProviderCampaignAnalytics> {
    const response = await this.client.get<InstantlyAnalytics[]>(
      "/campaigns/analytics",
      { id: campaignId }
    );

    const analytics = Array.isArray(response) ? response[0] : null;

    if (!analytics) {
      throw new ProviderError(
        `No analytics found for campaign ${campaignId}`,
        "instantly"
      );
    }

    return this.mapAnalytics(analytics);
  }

  async fetchDailyAnalytics(
    campaignId: string,
    startDate: string,
    endDate: string
  ): Promise<ProviderDailyAnalytics[]> {
    const response = await this.client.get<
      { daily: InstantlyDailyAnalytics[] } | InstantlyDailyAnalytics[]
    >("/campaigns/analytics/daily", {
      id: campaignId,
      start_date: startDate,
      end_date: endDate,
    });

    const daily = Array.isArray(response) ? response : response.daily || [];

    return daily.map((d) => ({
      date: d.date,
      sent: d.sent,
      opened: d.opened,
      uniqueOpened: d.unique_opened,
      replied: d.replies,
      uniqueReplied: d.unique_replies,
      clicked: d.clicks,
      uniqueClicked: d.unique_clicks,
    }));
  }

  private mapAnalytics(a: InstantlyAnalytics): ProviderCampaignAnalytics {
    return {
      campaignId: a.campaign_id,
      campaignName: a.campaign_name,
      leadsCount: a.leads_count,
      contactedCount: a.contacted_count,
      completedCount: a.completed_count,
      emailsSentCount: a.emails_sent_count,
      openCount: a.open_count,
      openCountUnique: a.open_count_unique,
      replyCount: a.reply_count,
      replyCountUnique: a.reply_count_unique,
      linkClickCount: a.link_click_count,
      linkClickCountUnique: a.link_click_count_unique,
      bouncedCount: a.bounced_count,
      unsubscribedCount: a.unsubscribed_count,
      totalOpportunities: a.total_opportunities,
      totalInterested: a.total_interested,
      totalMeetingBooked: a.total_meeting_booked,
      totalClosed: a.total_closed,
    };
  }

  // ============================================
  // EMAIL OPERATIONS
  // ============================================

  async fetchEmailsForLead(
    campaignId: string,
    leadEmail: string
  ): Promise<ProviderEmail[]> {
    const response = await this.client.get<
      { items?: InstantlyEmail[]; data?: InstantlyEmail[] } | InstantlyEmail[]
    >("/emails", {
      campaign_id: campaignId,
      search: leadEmail,
      limit: 100,
    });

    let emails: InstantlyEmail[];
    if (Array.isArray(response)) {
      emails = response;
    } else {
      emails = response.items || response.data || [];
    }

    return emails
      .map((e) => this.mapEmail(e))
      .sort((a, b) => a.sentAt.localeCompare(b.sentAt));
  }

  private mapEmail(e: InstantlyEmail): ProviderEmail {
    return {
      id: e.id,
      fromEmail: e.from_address_email,
      toEmail: e.to_address_email_list?.[0] || "",
      ccEmails: e.cc_address_email_list,
      bccEmails: e.bcc_address_email_list,
      subject: e.subject,
      bodyText: e.body?.text,
      bodyHtml: e.body?.html,
      threadId: e.thread_id,
      campaignId: e.i_campaign,
      leadEmail: e.lead_email,
      isReply: e.is_reply || false,
      sentAt: e.timestamp_email || e.timestamp_created || new Date().toISOString(),
    };
  }

  // ============================================
  // WEBHOOK HANDLING
  // ============================================

  parseWebhookPayload(
    rawBody: string,
    headers: Record<string, string>
  ): ProviderWebhookPayload {
    let payload: Record<string, unknown>;
    try {
      payload = JSON.parse(rawBody);
    } catch {
      throw new ProviderError(
        "Invalid webhook payload: not valid JSON",
        "instantly"
      );
    }

    const eventType = this.mapEventType(payload.event_type as string);

    return {
      eventType,
      providerEventId: payload.id as string | undefined,
      campaignId:
        (payload.campaign_id as string) ||
        (payload.campaign as { id?: string })?.id,
      campaignName: (payload.campaign as { name?: string })?.name,
      leadEmail:
        (payload.lead_email as string) ||
        (payload.lead as { email?: string })?.email,
      leadId: (payload.lead as { id?: string })?.id,
      timestamp: (payload.timestamp as string) || new Date().toISOString(),
      emailSubject:
        (payload.email as { subject?: string })?.subject ||
        (payload.subject as string),
      emailBody:
        (payload.email as { body?: string })?.body || (payload.body as string),
      emailFrom: (payload.email as { from?: string })?.from,
      emailTo: (payload.email as { to?: string })?.to,
      threadId: payload.thread_id as string | undefined,
      sequenceStep: payload.step as number | undefined,
      linkClicked: payload.link_url as string | undefined,
      bounceType: payload.bounce_type as "hard" | "soft" | undefined,
      bounceReason: payload.bounce_reason as string | undefined,
      rawPayload: payload,
    };
  }

  verifyWebhookSignature(
    rawBody: string,
    signature: string | null,
    secret: string | null
  ): boolean {
    // If no secret configured, accept all webhooks
    if (!secret) {
      return true;
    }

    // If secret is set but no signature provided, reject
    if (!signature) {
      return false;
    }

    // Compute expected signature
    const expectedSignature = crypto
      .createHmac("sha256", secret)
      .update(rawBody)
      .digest("hex");

    // Compare signatures (constant-time comparison)
    try {
      return crypto.timingSafeEqual(
        Buffer.from(signature),
        Buffer.from(expectedSignature)
      );
    } catch {
      return false;
    }
  }

  private mapEventType(eventType: string | undefined): WebhookEventType {
    if (!eventType) return "unknown";

    const mapping: Record<string, WebhookEventType> = {
      email_sent: "email_sent",
      sent: "email_sent",
      email_opened: "email_opened",
      opened: "email_opened",
      open: "email_opened",
      link_clicked: "link_clicked",
      clicked: "link_clicked",
      click: "link_clicked",
      reply_received: "reply_received",
      replied: "reply_received",
      reply: "reply_received",
      lead_replied: "reply_received",
      email_bounced: "email_bounced",
      bounced: "email_bounced",
      bounce: "email_bounced",
      lead_bounced: "email_bounced",
      unsubscribed: "unsubscribed",
      unsubscribe: "unsubscribed",
      lead_interested: "lead_interested",
      interested: "lead_interested",
      positive_reply: "lead_interested",
      lead_not_interested: "lead_not_interested",
      not_interested: "lead_not_interested",
      negative_reply: "lead_not_interested",
      meeting_booked: "meeting_booked",
      meeting_completed: "meeting_completed",
      out_of_office: "out_of_office",
      ooo: "out_of_office",
    };

    return mapping[eventType.toLowerCase()] || "unknown";
  }
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: "standalone",
  devIndicators: false,
  images: {
    dangerouslyAllowSVG: true,
    remotePatterns: [
      {
        protocol: "https",
        hostname: "*.supabase.co",
      },
      {
        protocol: "https",
        hostname: "*.supabase.in",
      },
    ],
    // Allow data URLs (base64 images)
    unoptimized: false,
  },
};

export default nextConfig;
</file>

<file path="src/app/admin/settings/page.tsx">
"use client";

import { useEffect, useState, useRef } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Settings, Key, Shield, Check, X, RefreshCw, Eye, EyeOff, Upload, ArrowLeft, Image as ImageIcon, Building2, Palette, Mail } from "lucide-react";
import Link from "next/link";
import Image from "next/image";

interface Setting {
  key: string;
  is_set: boolean;
  is_encrypted: boolean;
  updated_at: string;
  masked_value: string;
}

export default function SettingsPage() {
  const [settings, setSettings] = useState<Setting[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState<string | null>(null);
  const [editingKey, setEditingKey] = useState<string | null>(null);
  const [editValue, setEditValue] = useState("");
  const [showValue, setShowValue] = useState(false);
  const [testingConnection, setTestingConnection] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<"success" | "error" | null>(null);

  // Logo state
  const [logoUrl, setLogoUrl] = useState<string | null>(null);
  const [logoFile, setLogoFile] = useState<File | null>(null);
  const [logoPreview, setLogoPreview] = useState<string | null>(null);
  const [uploadingLogo, setUploadingLogo] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Branding state
  const [agencyName, setAgencyName] = useState("");
  const [primaryColor, setPrimaryColor] = useState("#2563eb");
  const [senderName, setSenderName] = useState("");
  const [senderEmail, setSenderEmail] = useState("");
  const [savingBranding, setSavingBranding] = useState(false);

  const fetchSettings = async () => {
    try {
      const res = await fetch("/api/admin/settings");
      const data = await res.json();
      setSettings(data.settings || []);

      // Load branding settings
      const allSettings = data.settings || [];
      const logoSetting = allSettings.find((s: Setting) => s.key === "agency_logo_url");
      const nameSetting = allSettings.find((s: Setting) => s.key === "agency_name");
      const colorSetting = allSettings.find((s: Setting) => s.key === "agency_primary_color");
      const senderNameSetting = allSettings.find((s: Setting) => s.key === "agency_sender_name");
      const senderEmailSetting = allSettings.find((s: Setting) => s.key === "agency_sender_email");

      if (logoSetting?.is_set) {
        setLogoUrl(logoSetting.masked_value);
        setLogoPreview(logoSetting.masked_value);
      }
      if (nameSetting?.is_set) setAgencyName(nameSetting.masked_value);
      if (colorSetting?.is_set) setPrimaryColor(colorSetting.masked_value);
      if (senderNameSetting?.is_set) setSenderName(senderNameSetting.masked_value);
      if (senderEmailSetting?.is_set) setSenderEmail(senderEmailSetting.masked_value);
    } catch (error) {
      console.error("Error fetching settings:", error);
    } finally {
      setLoading(false);
    }
  };

  const saveBrandingSettings = async () => {
    setSavingBranding(true);
    try {
      const updates = [
        { key: "agency_name", value: agencyName },
        { key: "agency_primary_color", value: primaryColor },
        { key: "agency_sender_name", value: senderName },
        { key: "agency_sender_email", value: senderEmail },
      ];

      for (const update of updates) {
        await fetch("/api/admin/settings", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(update),
        });
      }

      await fetchSettings();
    } catch (error) {
      console.error("Error saving branding:", error);
    } finally {
      setSavingBranding(false);
    }
  };

  useEffect(() => {
    fetchSettings();
  }, []);

  const handleLogoChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setLogoFile(file);
      const reader = new FileReader();
      reader.onloadend = () => {
        setLogoPreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleLogoUpload = async () => {
    if (!logoFile) return;

    setUploadingLogo(true);
    try {
      const formData = new FormData();
      formData.append("file", logoFile);

      const res = await fetch("/api/admin/settings/logo", {
        method: "POST",
        body: formData,
      });

      if (res.ok) {
        const data = await res.json();
        setLogoUrl(data.url);
        setLogoPreview(data.url);
        setLogoFile(null);
        await fetchSettings();
      } else {
        const data = await res.json();
        alert(data.error || "Failed to upload logo");
      }
    } catch (error) {
      console.error("Error uploading logo:", error);
      alert("Failed to upload logo");
    } finally {
      setUploadingLogo(false);
    }
  };

  const handleSave = async (key: string) => {
    setSaving(key);
    try {
      const res = await fetch("/api/admin/settings", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ key, value: editValue }),
      });

      if (res.ok) {
        setEditingKey(null);
        setEditValue("");
        await fetchSettings();
      }
    } catch (error) {
      console.error("Error saving setting:", error);
    } finally {
      setSaving(null);
    }
  };

  const handleClear = async (key: string) => {
    if (!confirm("Are you sure you want to clear this setting?")) return;

    setSaving(key);
    try {
      const res = await fetch(`/api/admin/settings?key=${key}`, {
        method: "DELETE",
      });

      if (res.ok) {
        await fetchSettings();
      }
    } catch (error) {
      console.error("Error clearing setting:", error);
    } finally {
      setSaving(null);
    }
  };

  const testConnection = async () => {
    setTestingConnection(true);
    setConnectionStatus(null);
    try {
      const res = await fetch("/api/instantly/status");
      const data = await res.json();
      setConnectionStatus(data.connected ? "success" : "error");
    } catch {
      setConnectionStatus("error");
    } finally {
      setTestingConnection(false);
    }
  };

  const settingLabels: Record<string, { label: string; description: string; icon: typeof Key }> = {
    instantly_api_key: {
      label: "Instantly API Key",
      description: "Your Instantly.ai API key for syncing campaigns and leads",
      icon: Key,
    },
    instantly_webhook_secret: {
      label: "Instantly Webhook Secret",
      description: "Secret for validating incoming webhooks from Instantly",
      icon: Shield,
    },
    smartlead_api_key: {
      label: "Smartlead API Key",
      description: "Your Smartlead API key for syncing email accounts and warmup data",
      icon: Key,
    },
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <RefreshCw className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div>
        <Link
          href="/admin"
          className="text-sm text-muted-foreground hover:text-foreground flex items-center gap-1 mb-2"
        >
          <ArrowLeft className="h-4 w-4" />
          Back to Command Center
        </Link>
        <h1 className="text-2xl font-bold flex items-center gap-2">
          <Settings className="h-6 w-6" />
          Settings
        </h1>
        <p className="text-gray-500">Configure your agency branding and integrations</p>
      </div>

      {/* Agency Logo */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <ImageIcon className="h-5 w-5" />
            Agency Logo
          </CardTitle>
          <CardDescription>
            Upload your agency logo to display in the dashboard
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center gap-6">
            <div className="w-24 h-24 border-2 border-dashed border-gray-200 rounded-lg flex items-center justify-center overflow-hidden bg-gray-50">
              {logoPreview ? (
                <Image
                  src={logoPreview}
                  alt="Agency logo"
                  width={96}
                  height={96}
                  className="object-contain w-full h-full"
                  unoptimized={logoPreview.startsWith("data:")}
                />
              ) : (
                <Upload className="h-8 w-8 text-gray-400" />
              )}
            </div>
            <div className="space-y-2">
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleLogoChange}
                accept="image/*"
                className="hidden"
              />
              <div className="flex gap-2">
                <Button
                  variant="outline"
                  onClick={() => fileInputRef.current?.click()}
                >
                  <Upload className="h-4 w-4 mr-2" />
                  {logoPreview ? "Change Logo" : "Upload Logo"}
                </Button>
                {logoFile && (
                  <Button onClick={handleLogoUpload} disabled={uploadingLogo}>
                    {uploadingLogo ? (
                      <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                    ) : (
                      <Check className="h-4 w-4 mr-2" />
                    )}
                    Save
                  </Button>
                )}
              </div>
              <p className="text-xs text-muted-foreground">
                Recommended: 200x200px, PNG or JPG
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Branding Settings */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Building2 className="h-5 w-5" />
            Agency Branding
          </CardTitle>
          <CardDescription>
            Customize your agency name and colors for client communications
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="agencyName">Agency Name</Label>
              <Input
                id="agencyName"
                value={agencyName}
                onChange={(e) => setAgencyName(e.target.value)}
                placeholder="BlueReach Agency"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="primaryColor" className="flex items-center gap-2">
                <Palette className="h-4 w-4" />
                Primary Color
              </Label>
              <div className="flex gap-2">
                <Input
                  id="primaryColor"
                  type="color"
                  value={primaryColor}
                  onChange={(e) => setPrimaryColor(e.target.value)}
                  className="w-16 h-10 p-1 cursor-pointer"
                />
                <Input
                  value={primaryColor}
                  onChange={(e) => setPrimaryColor(e.target.value)}
                  placeholder="#2563eb"
                  className="flex-1"
                />
              </div>
            </div>
          </div>

          <div className="border-t pt-4 mt-4">
            <Label className="flex items-center gap-2 mb-3">
              <Mail className="h-4 w-4" />
              Email Sender Settings
            </Label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="senderName">Sender Name</Label>
                <Input
                  id="senderName"
                  value={senderName}
                  onChange={(e) => setSenderName(e.target.value)}
                  placeholder="BlueReach Team"
                />
                <p className="text-xs text-muted-foreground">
                  This name appears as the &quot;From&quot; in emails
                </p>
              </div>
              <div className="space-y-2">
                <Label htmlFor="senderEmail">Sender Email</Label>
                <Input
                  id="senderEmail"
                  type="email"
                  value={senderEmail}
                  onChange={(e) => setSenderEmail(e.target.value)}
                  placeholder="hello@bluereach.com"
                />
                <p className="text-xs text-muted-foreground">
                  Must be verified in Resend
                </p>
              </div>
            </div>
          </div>

          <div className="flex justify-end pt-2">
            <Button onClick={saveBrandingSettings} disabled={savingBranding}>
              {savingBranding ? (
                <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
              ) : (
                <Check className="h-4 w-4 mr-2" />
              )}
              Save Branding Settings
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* Email API Key */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Mail className="h-5 w-5" />
            Email Service (Resend)
          </CardTitle>
          <CardDescription>
            Configure Resend API key to send invitation emails
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {(() => {
            const resendSetting = settings.find(s => s.key === "resend_api_key");
            const isEditing = editingKey === "resend_api_key";

            return (
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <Label className="flex items-center gap-2">
                    <Key className="h-4 w-4 text-gray-500" />
                    Resend API Key
                    {resendSetting?.is_set ? (
                      <Badge variant="default" className="ml-2">Configured</Badge>
                    ) : (
                      <Badge variant="secondary" className="ml-2">Not Set</Badge>
                    )}
                  </Label>
                </div>
                <p className="text-sm text-gray-500">
                  Get your API key from <a href="https://resend.com" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">resend.com</a>
                </p>

                {isEditing ? (
                  <div className="flex gap-2">
                    <div className="relative flex-1">
                      <Input
                        type={showValue ? "text" : "password"}
                        value={editValue}
                        onChange={(e) => setEditValue(e.target.value)}
                        placeholder="re_..."
                        className="pr-10"
                      />
                      <button
                        type="button"
                        onClick={() => setShowValue(!showValue)}
                        className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600"
                      >
                        {showValue ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                      </button>
                    </div>
                    <Button
                      onClick={() => handleSave("resend_api_key")}
                      disabled={saving === "resend_api_key"}
                    >
                      {saving === "resend_api_key" ? (
                        <RefreshCw className="h-4 w-4 animate-spin" />
                      ) : (
                        "Save"
                      )}
                    </Button>
                    <Button
                      variant="outline"
                      onClick={() => {
                        setEditingKey(null);
                        setEditValue("");
                        setShowValue(false);
                      }}
                    >
                      Cancel
                    </Button>
                  </div>
                ) : (
                  <div className="flex gap-2">
                    <Input
                      type="password"
                      value={resendSetting?.is_set ? resendSetting.masked_value : ""}
                      disabled
                      placeholder="Not configured"
                      className="flex-1"
                    />
                    <Button
                      variant="outline"
                      onClick={() => {
                        setEditingKey("resend_api_key");
                        setEditValue("");
                      }}
                    >
                      {resendSetting?.is_set ? "Change" : "Set"}
                    </Button>
                    {resendSetting?.is_set && (
                      <Button
                        variant="outline"
                        onClick={() => handleClear("resend_api_key")}
                        disabled={saving === "resend_api_key"}
                        className="text-red-600 hover:text-red-700"
                      >
                        Clear
                      </Button>
                    )}
                  </div>
                )}
              </div>
            );
          })()}
        </CardContent>
      </Card>

      {/* Instantly Integration */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle>Instantly Integration</CardTitle>
              <CardDescription>
                Connect your Instantly.ai account to sync campaigns and leads
              </CardDescription>
            </div>
            <Button
              variant="outline"
              size="sm"
              onClick={testConnection}
              disabled={testingConnection}
            >
              {testingConnection ? (
                <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
              ) : connectionStatus === "success" ? (
                <Check className="h-4 w-4 mr-2 text-green-500" />
              ) : connectionStatus === "error" ? (
                <X className="h-4 w-4 mr-2 text-red-500" />
              ) : (
                <RefreshCw className="h-4 w-4 mr-2" />
              )}
              Test Connection
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-6">
          {settings.map((setting) => {
            const config = settingLabels[setting.key] || {
              label: setting.key,
              description: "",
              icon: Key,
            };
            const Icon = config.icon;
            const isEditing = editingKey === setting.key;

            return (
              <div key={setting.key} className="space-y-2">
                <div className="flex items-center justify-between">
                  <Label className="flex items-center gap-2">
                    <Icon className="h-4 w-4 text-gray-500" />
                    {config.label}
                    {setting.is_set ? (
                      <Badge variant="default" className="ml-2">Configured</Badge>
                    ) : (
                      <Badge variant="secondary" className="ml-2">Not Set</Badge>
                    )}
                  </Label>
                </div>
                <p className="text-sm text-gray-500">{config.description}</p>

                {isEditing ? (
                  <div className="flex gap-2">
                    <div className="relative flex-1">
                      <Input
                        type={showValue ? "text" : "password"}
                        value={editValue}
                        onChange={(e) => setEditValue(e.target.value)}
                        placeholder="Enter new value..."
                        className="pr-10"
                      />
                      <button
                        type="button"
                        onClick={() => setShowValue(!showValue)}
                        className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600"
                      >
                        {showValue ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                      </button>
                    </div>
                    <Button
                      onClick={() => handleSave(setting.key)}
                      disabled={saving === setting.key}
                    >
                      {saving === setting.key ? (
                        <RefreshCw className="h-4 w-4 animate-spin" />
                      ) : (
                        "Save"
                      )}
                    </Button>
                    <Button
                      variant="outline"
                      onClick={() => {
                        setEditingKey(null);
                        setEditValue("");
                        setShowValue(false);
                      }}
                    >
                      Cancel
                    </Button>
                  </div>
                ) : (
                  <div className="flex gap-2">
                    <Input
                      type="password"
                      value={setting.is_set ? setting.masked_value : ""}
                      disabled
                      placeholder="Not configured"
                      className="flex-1"
                    />
                    <Button
                      variant="outline"
                      onClick={() => {
                        setEditingKey(setting.key);
                        setEditValue("");
                      }}
                    >
                      {setting.is_set ? "Change" : "Set"}
                    </Button>
                    {setting.is_set && (
                      <Button
                        variant="outline"
                        onClick={() => handleClear(setting.key)}
                        disabled={saving === setting.key}
                        className="text-red-600 hover:text-red-700"
                      >
                        Clear
                      </Button>
                    )}
                  </div>
                )}

                {setting.updated_at && setting.is_set && (
                  <p className="text-xs text-gray-400">
                    Last updated: {new Date(setting.updated_at).toLocaleString()}
                  </p>
                )}
              </div>
            );
          })}
        </CardContent>
      </Card>

      {/* Smartlead Integration */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle>Smartlead Integration</CardTitle>
              <CardDescription>
                Connect your Smartlead account to sync email accounts and warmup data
              </CardDescription>
            </div>
          </div>
        </CardHeader>
        <CardContent className="space-y-6">
          {(() => {
            const smartleadSetting = settings.find(s => s.key === "smartlead_api_key");
            const config = settingLabels["smartlead_api_key"];
            const Icon = config.icon;
            const isEditing = editingKey === "smartlead_api_key";

            return (
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <Label className="flex items-center gap-2">
                    <Icon className="h-4 w-4 text-gray-500" />
                    {config.label}
                    {smartleadSetting?.is_set ? (
                      <Badge variant="default" className="ml-2">Configured</Badge>
                    ) : (
                      <Badge variant="secondary" className="ml-2">Not Set</Badge>
                    )}
                  </Label>
                </div>
                <p className="text-sm text-gray-500">{config.description}</p>

                {isEditing ? (
                  <div className="flex gap-2">
                    <div className="relative flex-1">
                      <Input
                        type={showValue ? "text" : "password"}
                        value={editValue}
                        onChange={(e) => setEditValue(e.target.value)}
                        placeholder="Enter Smartlead API key..."
                        className="pr-10"
                      />
                      <button
                        type="button"
                        onClick={() => setShowValue(!showValue)}
                        className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600"
                      >
                        {showValue ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                      </button>
                    </div>
                    <Button
                      onClick={() => handleSave("smartlead_api_key")}
                      disabled={saving === "smartlead_api_key"}
                    >
                      {saving === "smartlead_api_key" ? (
                        <RefreshCw className="h-4 w-4 animate-spin" />
                      ) : (
                        "Save"
                      )}
                    </Button>
                    <Button
                      variant="outline"
                      onClick={() => {
                        setEditingKey(null);
                        setEditValue("");
                        setShowValue(false);
                      }}
                    >
                      Cancel
                    </Button>
                  </div>
                ) : (
                  <div className="flex gap-2">
                    <Input
                      type="password"
                      value={smartleadSetting?.is_set ? smartleadSetting.masked_value : ""}
                      disabled
                      placeholder="Not configured"
                      className="flex-1"
                    />
                    <Button
                      variant="outline"
                      onClick={() => {
                        setEditingKey("smartlead_api_key");
                        setEditValue("");
                      }}
                    >
                      {smartleadSetting?.is_set ? "Change" : "Set"}
                    </Button>
                    {smartleadSetting?.is_set && (
                      <Button
                        variant="outline"
                        onClick={() => handleClear("smartlead_api_key")}
                        disabled={saving === "smartlead_api_key"}
                        className="text-red-600 hover:text-red-700"
                      >
                        Clear
                      </Button>
                    )}
                  </div>
                )}

                {smartleadSetting?.updated_at && smartleadSetting?.is_set && (
                  <p className="text-xs text-gray-400">
                    Last updated: {new Date(smartleadSetting.updated_at).toLocaleString()}
                  </p>
                )}
              </div>
            );
          })()}
        </CardContent>
      </Card>

      {/* Help Section */}
      <Card>
        <CardHeader>
          <CardTitle>How to get your API Keys</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-4">
            <div>
              <h4 className="font-medium mb-2">Instantly API Key</h4>
              <ol className="list-decimal list-inside space-y-1 text-sm text-gray-600">
                <li>Log in to your Instantly.ai dashboard</li>
                <li>Go to <strong>Settings</strong>  <strong>Integrations</strong>  <strong>API</strong></li>
                <li>Click <strong>Create API Key</strong></li>
                <li>Copy the key and paste it above</li>
              </ol>
            </div>
            <div>
              <h4 className="font-medium mb-2">Smartlead API Key</h4>
              <ol className="list-decimal list-inside space-y-1 text-sm text-gray-600">
                <li>Log in to your Smartlead dashboard</li>
                <li>Go to <strong>Settings</strong>  <strong>API</strong></li>
                <li>Copy your API key and paste it above</li>
              </ol>
            </div>
          </div>
          <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
            <p className="text-sm text-yellow-800">
              <strong>Note:</strong> Your API keys are stored securely and encrypted.
              They will only be used to sync data between your email providers and this dashboard.
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/api/clients/[clientId]/campaigns/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

interface RouteParams {
  params: Promise<{ clientId: string }>;
}

// GET - Get campaigns for a client with analytics (ALL DATA FROM SUPABASE ONLY)
export async function GET(request: Request, { params }: RouteParams) {
  try {
    const { clientId } = await params;
    const supabase = getSupabase();

    // Get campaigns from local DB for this client
    const { data: campaigns, error } = await supabase
      .from("campaigns")
      .select("*")
      .eq("client_id", clientId)
      .order("name");

    if (error) {
      return NextResponse.json(
        { error: "Failed to fetch campaigns" },
        { status: 500 }
      );
    }

    // Get campaign IDs for aggregation
    const campaignIds = campaigns.map((c) => c.id);

    if (campaignIds.length === 0) {
      return NextResponse.json({
        campaigns: [],
        analyticsLoaded: true,
        clientStats: { replied: 0, positive: 0 },
      });
    }

    // Count positive replies for client
    const { count: clientPositive } = await supabase
      .from("leads")
      .select("*", { count: "exact", head: true })
      .eq("client_id", clientId)
      .eq("is_positive_reply", true);

    // Count all replied leads
    const { count: clientReplied } = await supabase
      .from("leads")
      .select("*", { count: "exact", head: true })
      .eq("client_id", clientId)
      .or("has_replied.eq.true,status.eq.replied,status.eq.booked,status.eq.won,status.eq.lost");

    // Build stats map using COUNT queries (more efficient than fetching all leads)
    const localStatsMap = new Map<string, {
      leads_count: number;
      replied_count: number;
      positive_count: number;
    }>();

    // Get counts for each campaign using parallel queries
    await Promise.all(
      campaignIds.map(async (campaignId) => {
        const [totalResult, repliedResult, positiveResult] = await Promise.all([
          // Total leads count
          supabase
            .from("leads")
            .select("*", { count: "exact", head: true })
            .eq("campaign_id", campaignId),
          // Replied leads count
          supabase
            .from("leads")
            .select("*", { count: "exact", head: true })
            .eq("campaign_id", campaignId)
            .or("has_replied.eq.true,status.eq.replied,status.eq.booked,status.eq.won,status.eq.lost"),
          // Positive leads count
          supabase
            .from("leads")
            .select("*", { count: "exact", head: true })
            .eq("campaign_id", campaignId)
            .eq("is_positive_reply", true),
        ]);

        localStatsMap.set(campaignId, {
          leads_count: totalResult.count || 0,
          replied_count: repliedResult.count || 0,
          positive_count: positiveResult.count || 0,
        });
      })
    );

    // Build campaigns with analytics - ALL FROM SUPABASE
    const campaignsWithAnalytics = campaigns.map((campaign) => {
      const localStats = localStatsMap.get(campaign.id) || {
        leads_count: 0,
        replied_count: 0,
        positive_count: 0,
      };

      // Use cached values from campaign sync, fallback to local leads count
      const emailsSent = campaign.cached_emails_sent || localStats.leads_count;
      const repliesCount = campaign.cached_reply_count || localStats.replied_count;
      const bounced = campaign.cached_emails_bounced || 0;
      const opened = campaign.cached_emails_opened || 0;
      // Use cached positive count from provider, fallback to local leads count
      const positiveCount = campaign.cached_positive_count || localStats.positive_count;

      const analytics = {
        leads_count: localStats.leads_count,
        emails_sent: emailsSent,
        emails_replied: repliesCount,
        emails_bounced: bounced,
        emails_opened: opened,
        total_opportunities: positiveCount,
        contacted_count: emailsSent,
        reply_rate: emailsSent > 0 ? repliesCount / emailsSent : 0,
        bounce_rate: emailsSent > 0 ? bounced / emailsSent : 0,
      };

      return {
        ...campaign,
        analytics,
      };
    });

    return NextResponse.json({
      campaigns: campaignsWithAnalytics,
      analyticsLoaded: true,
      clientStats: {
        replied: clientReplied ?? 0,
        positive: clientPositive ?? 0,
      },
    });
  } catch (error) {
    console.error("Error fetching client campaigns:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch campaigns" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/webhooks/instantly/[campaignId]/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import crypto from "crypto";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

interface RouteParams {
  params: Promise<{ campaignId: string }>;
}

// Instantly webhook event types (from Instantly API V2 docs)
interface InstantlyWebhookPayload {
  // Base Fields (Always Present)
  timestamp: string;
  event_type: string;
  workspace: string;
  campaign_id: string;
  campaign_name: string;

  // Optional Fields
  lead_email?: string;
  email_account?: string;
  unibox_url?: string;

  // Step Information
  step?: number;
  variant?: number;
  is_first?: boolean;

  // Email information
  email_id?: string;
  email_subject?: string;
  email_text?: string;
  email_html?: string;

  // Reply Information
  reply_text_snippet?: string;
  reply_subject?: string;
  reply_text?: string;
  reply_html?: string;

  // Additional lead data fields
  [key: string]: unknown;
}

// Verify webhook signature if secret is configured
function verifyWebhookSignature(
  payload: string,
  signature: string | null,
  secret: string | null
): boolean {
  if (!secret || !signature) {
    // If no secret configured, allow all webhooks (for development)
    return true;
  }

  const expectedSignature = crypto
    .createHmac("sha256", secret)
    .update(payload)
    .digest("hex");

  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

// POST - Receive webhook events from Instantly
export async function POST(request: Request, { params }: RouteParams) {
  const startTime = Date.now();
  const { campaignId } = await params;
  const supabase = getSupabase();

  try {
    // Get raw body for signature verification
    const rawBody = await request.text();
    const payload: InstantlyWebhookPayload = JSON.parse(rawBody);

    // Verify signature if configured
    const signature = request.headers.get("x-instantly-signature");
    const webhookSecret = process.env.INSTANTLY_WEBHOOK_SECRET;

    if (webhookSecret && !verifyWebhookSignature(rawBody, signature, webhookSecret)) {
      console.error("[Webhook] Invalid signature for campaign:", campaignId);
      return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
    }

    // Get the campaign to verify it exists
    const { data: campaign, error: campaignError } = await supabase
      .from("campaigns")
      .select("id, name, instantly_campaign_id")
      .eq("id", campaignId)
      .single();

    if (campaignError || !campaign) {
      console.error("[Webhook] Campaign not found:", campaignId);
      return NextResponse.json({ error: "Campaign not found" }, { status: 404 });
    }

    // Log the webhook event
    console.log(`[Webhook] Received event for campaign ${campaign.name}:`, {
      event_type: payload.event_type,
      email: payload.email || payload.lead_email,
      interest_status: payload.interest_status || payload.lt_interest_status,
    });

    // Get lead email from payload and normalize it
    const rawLeadEmail = payload.lead_email;

    if (!rawLeadEmail) {
      console.warn("[Webhook] No lead_email in payload:", payload);
      return NextResponse.json({
        success: true,
        message: "No lead_email in payload, skipped"
      });
    }

    // Normalize email to handle case sensitivity and whitespace
    const leadEmail = rawLeadEmail.toLowerCase().trim();

    // Instantly event types (from API V2 docs):
    // Positive: "lead_interested", "lead_meeting_booked", "lead_meeting_completed", "lead_closed"
    // Negative: "lead_not_interested", "lead_out_of_office", "lead_wrong_person"
    // Neutral: "lead_neutral"
    // Other: "email_sent", "email_opened", "reply_received", "auto_reply_received", "link_clicked", "email_bounced", "lead_unsubscribed"

    const eventType = payload.event_type || "";

    // Positive event types
    const positiveEvents = [
      "lead_interested",
      "lead_meeting_booked",
      "lead_meeting_completed",
      "lead_closed",
    ];

    // Negative event types
    const negativeEvents = [
      "lead_not_interested",
      "lead_out_of_office",
      "lead_wrong_person",
      "lead_neutral",
    ];

    const isPositive = positiveEvents.includes(eventType);
    const isNegative = negativeEvents.includes(eventType);
    const isReply = eventType === "reply_received" || eventType === "auto_reply_received";
    const isEmailSent = eventType === "email_sent";
    const isBounced = eventType === "email_bounced";

    // Get client_id from campaign for creating new leads
    const { data: campaignWithClient } = await supabase
      .from("campaigns")
      .select("client_id")
      .eq("id", campaignId)
      .single();

    const clientId = campaignWithClient?.client_id;

    // Get client name separately if we have client_id
    let clientName = "";
    if (clientId) {
      const { data: clientData } = await supabase
        .from("clients")
        .select("name")
        .eq("id", clientId)
        .single();
      clientName = clientData?.name || "";
    }

    // Try to find existing lead first
    const { data: existingLead } = await supabase
      .from("leads")
      .select("id, email_open_count, email_click_count, status")
      .eq("campaign_id", campaignId)
      .eq("email", leadEmail)
      .maybeSingle();

    // Build update data based on event type
    const updateData: Record<string, unknown> = {
      updated_at: new Date().toISOString(),
    };

    // Handle different event types
    if (isPositive) {
      updateData.is_positive_reply = true;
      updateData.has_replied = true;
      updateData.status = "replied";
    } else if (isNegative) {
      updateData.is_positive_reply = false;
    }

    if (isReply) {
      updateData.has_replied = true;
      updateData.status = "replied";
      // Increment campaign's cached_reply_count
      const { data: campaignData } = await supabase
        .from("campaigns")
        .select("cached_reply_count")
        .eq("id", campaignId)
        .single();
      await supabase
        .from("campaigns")
        .update({ cached_reply_count: (campaignData?.cached_reply_count || 0) + 1 })
        .eq("id", campaignId);
    }

    if (isEmailSent) {
      // Mark lead as contacted
      if (!existingLead || existingLead.status === "new") {
        updateData.status = "contacted";
      }
      // Increment campaign's cached_emails_sent
      try {
        await supabase.rpc("increment_campaign_emails_sent", { campaign_uuid: campaignId });
      } catch {
        // RPC might not exist, update directly
        const currentSent = (campaign as { cached_emails_sent?: number }).cached_emails_sent || 0;
        await supabase
          .from("campaigns")
          .update({ cached_emails_sent: currentSent + 1 })
          .eq("id", campaignId);
      }
    }

    if (isBounced) {
      updateData.status = "bounced";
      // Increment campaign's cached_emails_bounced
      const currentBounced = (campaign as { cached_emails_bounced?: number }).cached_emails_bounced || 0;
      await supabase
        .from("campaigns")
        .update({ cached_emails_bounced: currentBounced + 1 })
        .eq("id", campaignId);
    }


    // Update or create lead
    if (existingLead) {
      const { error: updateError } = await supabase
        .from("leads")
        .update(updateData)
        .eq("id", existingLead.id);

      if (updateError) {
        console.error("[Webhook] Error updating lead:", updateError);
      } else {
        console.log(`[Webhook] Updated lead ${leadEmail} - event: ${eventType}`);
      }
    } else if (clientId && (isPositive || isReply || isEmailSent)) {
      // Create new lead if it doesn't exist and this is a meaningful event
      const { error: insertError } = await supabase
        .from("leads")
        .insert({
          email: leadEmail,
          campaign_id: campaignId,
          client_id: clientId,
          client_name: clientName,
          campaign_name: campaign.name,
          is_positive_reply: isPositive,
          has_replied: isReply || isPositive,
          status: isPositive || isReply ? "replied" : "contacted",
          ...updateData,
        });

      if (insertError) {
        console.error("[Webhook] Error creating lead:", insertError);
      } else {
        console.log(`[Webhook] Created new lead ${leadEmail} from webhook event: ${eventType}`);
      }
    } else {
      console.warn(`[Webhook] Lead not found and not creating for event ${eventType}: ${leadEmail}`);
    }

    const duration = Date.now() - startTime;
    console.log(`[Webhook] Processed in ${duration}ms`);

    return NextResponse.json({
      success: true,
      campaign: campaign.name,
      event_type: payload.event_type,
      lead_email: leadEmail,
      is_positive: isPositive,
      processed_at: new Date().toISOString(),
    });

  } catch (error) {
    console.error("[Webhook] Error processing webhook:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to process webhook" },
      { status: 500 }
    );
  }
}

// GET - Return webhook info/status for this campaign
export async function GET(request: Request, { params }: RouteParams) {
  const { campaignId } = await params;
  const supabase = getSupabase();

  try {
    const { data: campaign, error } = await supabase
      .from("campaigns")
      .select("id, name, instantly_campaign_id")
      .eq("id", campaignId)
      .single();

    if (error || !campaign) {
      return NextResponse.json({ error: "Campaign not found" }, { status: 404 });
    }

    // Get the base URL from the request
    const url = new URL(request.url);
    const webhookUrl = `${url.protocol}//${url.host}/api/webhooks/instantly/${campaignId}`;

    return NextResponse.json({
      campaign_id: campaign.id,
      campaign_name: campaign.name,
      instantly_campaign_id: campaign.instantly_campaign_id,
      webhook_url: webhookUrl,
      supported_events: {
        positive: ["lead_interested", "lead_meeting_booked", "lead_meeting_completed", "lead_closed"],
        negative: ["lead_not_interested", "lead_out_of_office", "lead_wrong_person", "lead_neutral"],
        other: ["reply_received", "email_sent", "email_opened", "link_clicked", "email_bounced"],
      },
      instructions: "Configure this URL in your Instantly campaign webhook settings. Select the events you want to track. Positive events (lead_interested, lead_meeting_booked, etc.) will set is_positive_reply=true.",
    });

  } catch (error) {
    console.error("[Webhook] Error fetching campaign:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch campaign" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/webhooks/instantly/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { headers } from "next/headers";
import crypto from "crypto";
import { fetchEmailsForLead as fetchInstantlyEmails } from "@/lib/instantly";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// Verify webhook signature from Instantly
async function verifySignature(payload: string, signature: string | null): Promise<boolean> {
  if (!signature) return false;
  
  const supabase = getSupabase();
  const { data: setting } = await supabase
    .from("settings")
    .select("value")
    .eq("key", "instantly_webhook_secret")
    .single();
    
  const secret = setting?.value;
  if (!secret) {
    console.warn("No webhook secret configured, accepting all webhooks");
    return true; // Allow webhooks if no secret is configured
  }
  
  const expectedSignature = crypto
    .createHmac("sha256", secret)
    .update(payload)
    .digest("hex");
    
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

interface InstantlyWebhookPayload {
  event_type: string;
  campaign_id?: string;
  lead_email?: string;
  lead?: {
    email?: string;
    first_name?: string;
    last_name?: string;
    company_name?: string;
  };
  email?: {
    id?: string;
    subject?: string;
    body?: string;
    body_text?: string;
    body_html?: string;
    from_email?: string;
    to_email?: string;
    timestamp?: string;
    direction?: "sent" | "received" | "outbound" | "inbound";
  };
  timestamp?: string;
  data?: Record<string, unknown>;
}

// Helper function to sync all emails for a lead from Instantly
async function syncEmailThreadForLead(
  supabase: ReturnType<typeof getSupabase>,
  leadId: string,
  leadEmail: string,
  campaignId: string
) {
  try {
    const instantlyEmails = await fetchInstantlyEmails(leadEmail);

    for (const email of instantlyEmails) {
      // Check if email already exists
      const { data: existing } = await supabase
        .from("lead_emails")
        .select("id")
        .eq("lead_id", leadId)
        .eq("provider_email_id", email.id)
        .single();

      if (existing) continue;

      // Determine direction
      const isOutbound = email.from_address_email !== leadEmail;
      const toEmail = email.to_address_email_list?.[0] || leadEmail;

      // Insert email
      await supabase.from("lead_emails").insert({
        lead_id: leadId,
        campaign_id: campaignId,
        provider_email_id: email.id,
        provider_thread_id: email.thread_id || null,
        direction: isOutbound ? "outbound" : "inbound",
        from_email: email.from_address_email || "",
        to_email: toEmail,
        subject: email.subject || null,
        body_text: email.body?.text || null,
        body_html: email.body?.html || email.body?.text || null,
        sent_at: email.timestamp_email || email.timestamp_created || null,
        metadata: {
          instantly_data: {
            campaign_id: email.i_campaign,
            eaccount: email.eaccount,
            is_reply: email.is_reply,
          },
        },
      });
    }

    console.log(`Synced ${instantlyEmails.length} emails for lead ${leadEmail}`);
  } catch (error) {
    console.error("Failed to sync email thread:", error);
  }
}

export async function POST(request: Request) {
  try {
    const headersList = await headers();
    const signature = headersList.get("x-instantly-signature");
    const rawBody = await request.text();
    
    // Verify signature if configured
    const isValid = await verifySignature(rawBody, signature);
    if (!isValid) {
      return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
    }
    
    const payload: InstantlyWebhookPayload = JSON.parse(rawBody);
    const supabase = getSupabase();
    
    console.log("Received webhook:", payload.event_type, payload);
    
    // Find the campaign and lead
    let campaignId: string | null = null;
    let leadId: string | null = null;
    const leadEmail = payload.lead_email || payload.lead?.email;
    
    if (payload.campaign_id) {
      const { data: campaign } = await supabase
        .from("campaigns")
        .select("id, client_id")
        .eq("instantly_campaign_id", payload.campaign_id)
        .single();
        
      if (campaign) {
        campaignId = campaign.id;
        
        // Find the lead
        if (leadEmail) {
          const { data: lead } = await supabase
            .from("leads")
            .select("id")
            .eq("campaign_id", campaignId)
            .eq("email", leadEmail)
            .single();
            
          if (lead) {
            leadId = lead.id;
          }
        }
      }
    }
    
    // Handle different event types
    switch (payload.event_type) {
      case "email_sent":
        if (leadId && campaignId) {
          await supabase.from("leads").update({
            status: "contacted",
            last_contacted_at: payload.timestamp || new Date().toISOString(),
          }).eq("id", leadId);

          // Store the email in lead_emails if email data is provided
          if (payload.email) {
            // Check if this email already exists (by provider_email_id if available)
            if (payload.email.id) {
              const { data: existing } = await supabase
                .from("lead_emails")
                .select("id")
                .eq("lead_id", leadId)
                .eq("provider_email_id", payload.email.id)
                .single();

              if (existing) break; // Already exists
            }

            await supabase.from("lead_emails").insert({
              lead_id: leadId,
              campaign_id: campaignId,
              provider_email_id: payload.email.id || null,
              direction: "outbound",
              from_email: payload.email.from_email || "",
              to_email: payload.email.to_email || leadEmail || "",
              subject: payload.email.subject || "Outreach Email",
              body_text: payload.email.body_text || payload.email.body || "",
              body_html: payload.email.body_html || null,
              sent_at: payload.email.timestamp || payload.timestamp,
            });
          }
        }
        break;

      case "email_opened":
        if (leadId) {
          // Update open count - increment via direct update
          try {
            const { data: lead } = await supabase
              .from("leads")
              .select("email_open_count")
              .eq("id", leadId)
              .single();

            if (lead) {
              await supabase.from("leads").update({
                email_open_count: (lead.email_open_count || 0) + 1,
              }).eq("id", leadId);
            }
          } catch {
            // Ignore errors
          }
        }
        break;

      case "link_clicked":
        if (leadId) {
          // Update click count - increment via direct update
          try {
            const { data: lead } = await supabase
              .from("leads")
              .select("email_click_count")
              .eq("id", leadId)
              .single();

            if (lead) {
              await supabase.from("leads").update({
                email_click_count: (lead.email_click_count || 0) + 1,
              }).eq("id", leadId);
            }
          } catch {
            // Ignore errors
          }
        }
        break;

      case "reply_received":
      case "lead_replied":
        if (leadId && campaignId && leadEmail) {
          await supabase.from("leads").update({
            status: "replied",
            has_replied: true,
          }).eq("id", leadId);

          // Store the reply email if provided
          if (payload.email) {
            // Check if this email already exists
            if (payload.email.id) {
              const { data: existing } = await supabase
                .from("lead_emails")
                .select("id")
                .eq("lead_id", leadId)
                .eq("provider_email_id", payload.email.id)
                .single();

              if (existing) break;
            }

            await supabase.from("lead_emails").insert({
              lead_id: leadId,
              campaign_id: campaignId,
              provider_email_id: payload.email.id || null,
              direction: "inbound",
              from_email: payload.email.from_email || leadEmail,
              to_email: payload.email.to_email || "",
              subject: payload.email.subject || "Re: Outreach",
              body_text: payload.email.body_text || payload.email.body || "",
              body_html: payload.email.body_html || null,
              sent_at: payload.email.timestamp || payload.timestamp,
            });
          }

          // Also sync all emails from Instantly to ensure we have the full thread
          await syncEmailThreadForLead(supabase, leadId, leadEmail, campaignId);
        }
        break;

      case "lead_interested":
      case "positive_reply":
        if (leadId && campaignId && leadEmail) {
          await supabase.from("leads").update({
            status: "replied",
            is_positive_reply: true,
            has_replied: true,
          }).eq("id", leadId);

          // Auto-sync the full email thread when a positive reply is received
          await syncEmailThreadForLead(supabase, leadId, leadEmail, campaignId);
        }
        break;
        
      case "lead_not_interested":
      case "negative_reply":
        if (leadId) {
          await supabase.from("leads").update({
            status: "closed_lost",
            has_replied: true,
          }).eq("id", leadId);
        }
        break;
        
      case "meeting_booked":
        if (leadId) {
          await supabase.from("leads").update({
            status: "meeting",
            is_positive_reply: true,
            meeting_at: payload.timestamp || null,
          }).eq("id", leadId);
        }
        break;
        
      case "lead_bounced":
        // Could mark lead as bounced
        break;
        
      default:
        console.log("Unhandled event type:", payload.event_type);
    }
    
    // Log the webhook event
    try {
      await supabase.from("webhook_logs").insert({
        source: "instantly",
        event_type: payload.event_type,
        payload: payload,
        processed_at: new Date().toISOString(),
      });
    } catch {
      // webhook_logs table might not exist, that's ok
    }
    
    return NextResponse.json({ success: true, event: payload.event_type });
  } catch (error) {
    console.error("Webhook error:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Webhook processing failed" },
      { status: 500 }
    );
  }
}

// GET endpoint to check webhook status
export async function GET() {
  return NextResponse.json({
    status: "active",
    endpoint: "/api/webhooks/instantly",
    supported_events: [
      "email_sent",
      "email_opened",
      "link_clicked",
      "reply_received",
      "lead_replied",
      "lead_interested",
      "positive_reply",
      "lead_not_interested",
      "negative_reply",
      "meeting_booked",
      "lead_bounced",
    ],
  });
}
</file>

<file path="src/app/login/page.tsx">
import { Suspense } from "react";
import { LoginClient } from "./login-client";

// Loading fallback for Suspense
function LoginFallback() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-[#050508]">
      <div className="flex flex-col items-center gap-4">
        <div className="w-12 h-12 bg-gradient-to-br from-blue-500 to-cyan-400 rounded-2xl flex items-center justify-center animate-pulse">
          <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M13 10V3L4 14h7v7l9-11h-7z" />
          </svg>
        </div>
        <div className="flex items-center gap-2">
          <div className="w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce [animation-delay:-0.3s]" />
          <div className="w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce [animation-delay:-0.15s]" />
          <div className="w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce" />
        </div>
      </div>
    </div>
  );
}

export default function LoginPage() {
  return (
    <Suspense fallback={<LoginFallback />}>
      <LoginClient />
    </Suspense>
  );
}
</file>

<file path="src/components/leads/lead-detail-panel.tsx">
"use client";

import { useState, useEffect } from "react";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Mail,
  RefreshCw,
  ArrowUpRight,
  ArrowDownLeft,
  Building2,
  Phone,
  Globe,
  Linkedin,
  User,
  Calendar,
  MousePointer,
  Eye,
  MessageSquare,
  ThumbsUp,
  Clock,
  Hash,
  ExternalLink,
  Copy,
  Check,
  X,
} from "lucide-react";
import type { Lead, LeadStatus, LeadEmail } from "@/types/database";

interface LeadDetailPanelProps {
  lead: Lead | null;
  open: boolean;
  onClose: () => void;
  onStatusChange: (leadId: string, status: LeadStatus) => Promise<void>;
  onNotesChange: (leadId: string, notes: string) => Promise<void>;
}

const statusOptions: { value: LeadStatus; label: string; color: string }[] = [
  { value: "contacted", label: "Contacted", color: "bg-slate-500" },
  { value: "opened", label: "Opened", color: "bg-amber-500" },
  { value: "clicked", label: "Clicked", color: "bg-orange-500" },
  { value: "replied", label: "Replied", color: "bg-blue-500" },
  { value: "booked", label: "Meeting Booked", color: "bg-emerald-500" },
  { value: "won", label: "Closed Won", color: "bg-green-500" },
  { value: "lost", label: "Closed Lost", color: "bg-red-500" },
  { value: "not_interested", label: "Not Interested", color: "bg-gray-500" },
];

const statusColors: Record<LeadStatus, string> = {
  contacted: "bg-slate-100 text-slate-700 dark:bg-slate-800 dark:text-slate-300",
  opened: "bg-amber-100 text-amber-700 dark:bg-amber-900 dark:text-amber-300",
  clicked: "bg-orange-100 text-orange-700 dark:bg-orange-900 dark:text-orange-300",
  replied: "bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300",
  booked: "bg-emerald-100 text-emerald-700 dark:bg-emerald-900 dark:text-emerald-300",
  won: "bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300",
  lost: "bg-red-100 text-red-700 dark:bg-red-900 dark:text-red-300",
  not_interested: "bg-gray-100 text-gray-600 dark:bg-gray-800 dark:text-gray-400",
};

export function LeadDetailPanel({
  lead,
  open,
  onClose,
  onStatusChange,
  onNotesChange,
}: LeadDetailPanelProps) {
  const [notes, setNotes] = useState(lead?.notes || "");
  const [isSaving, setIsSaving] = useState(false);
  const [emails, setEmails] = useState<LeadEmail[]>([]);
  const [isLoadingEmails, setIsLoadingEmails] = useState(false);
  const [isSyncingEmails, setIsSyncingEmails] = useState(false);
  const [copiedEmail, setCopiedEmail] = useState(false);
  const [activeTab, setActiveTab] = useState("details");

  useEffect(() => {
    if (lead) {
      setNotes(lead.notes || "");
    }
  }, [lead?.id, lead?.notes]);

  useEffect(() => {
    if (open && lead) {
      fetchEmails();
    }
  }, [open, lead?.id]);

  const fetchEmails = async () => {
    if (!lead) return;
    setIsLoadingEmails(true);
    try {
      const res = await fetch(`/api/leads/${lead.id}/emails`);
      if (res.ok) {
        const data = await res.json();
        setEmails(data.emails || []);
      }
    } catch (error) {
      console.error("Failed to fetch emails:", error);
    } finally {
      setIsLoadingEmails(false);
    }
  };

  const syncEmails = async () => {
    if (!lead) return;
    setIsSyncingEmails(true);
    try {
      const res = await fetch(`/api/leads/${lead.id}/emails`, {
        method: "POST",
      });
      if (res.ok) {
        await fetchEmails();
      }
    } catch (error) {
      console.error("Failed to sync emails:", error);
    } finally {
      setIsSyncingEmails(false);
    }
  };

  const copyEmail = () => {
    if (lead?.email) {
      navigator.clipboard.writeText(lead.email);
      setCopiedEmail(true);
      setTimeout(() => setCopiedEmail(false), 2000);
    }
  };

  if (!lead) return null;

  const handleStatusChange = async (status: LeadStatus) => {
    setIsSaving(true);
    await onStatusChange(lead.id, status);
    setIsSaving(false);
  };

  const handleNotesSave = async () => {
    setIsSaving(true);
    await onNotesChange(lead.id, notes);
    setIsSaving(false);
  };

  const displayName = lead.first_name || lead.last_name
    ? `${lead.first_name || ""} ${lead.last_name || ""}`.trim()
    : null;

  const getInitials = () => {
    if (lead.first_name && lead.last_name) {
      return `${lead.first_name[0]}${lead.last_name[0]}`.toUpperCase();
    }
    if (lead.first_name) return lead.first_name[0].toUpperCase();
    if (lead.email) return lead.email[0].toUpperCase();
    return "?";
  };

  return (
    <Sheet open={open} onOpenChange={onClose}>
      <SheetContent className="w-full sm:w-[480px] p-0 flex flex-col">
        {/* Header */}
        <SheetHeader className="p-6 pb-4 border-b bg-muted/30">
          <SheetTitle className="sr-only">
            Lead Details: {displayName || lead.email}
          </SheetTitle>
          <div className="flex items-start gap-4">
            <div className="w-14 h-14 rounded-full bg-primary/10 flex items-center justify-center shrink-0">
              <span className="text-lg font-semibold text-primary">{getInitials()}</span>
            </div>
            <div className="flex-1 min-w-0">
              {displayName && (
                <h2 className="text-lg font-semibold text-foreground truncate">
                  {displayName}
                </h2>
              )}
              <div className="flex items-center gap-2 mt-1">
                <p className="text-sm text-muted-foreground truncate flex-1">{lead.email}</p>
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-7 w-7 p-0 shrink-0"
                  onClick={copyEmail}
                >
                  {copiedEmail ? (
                    <Check className="h-3.5 w-3.5 text-green-600" />
                  ) : (
                    <Copy className="h-3.5 w-3.5" />
                  )}
                </Button>
              </div>
              <div className="flex items-center gap-2 mt-2">
                <Badge className={statusColors[lead.status]}>
                  {statusOptions.find(s => s.value === lead.status)?.label || lead.status}
                </Badge>
                {lead.is_positive_reply && (
                  <Badge className="bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300">
                    <ThumbsUp className="h-3 w-3 mr-1" />
                    Positive
                  </Badge>
                )}
              </div>
            </div>
            <Button
              variant="ghost"
              size="sm"
              className="h-8 w-8 p-0 shrink-0"
              onClick={onClose}
            >
              <X className="h-4 w-4" />
            </Button>
          </div>
        </SheetHeader>

        {/* Stats Bar */}
        <div className="grid grid-cols-3 gap-px bg-border">
          <div className="bg-background p-3 text-center">
            <div className="flex items-center justify-center gap-1.5 text-muted-foreground mb-1">
              <Eye className="h-3.5 w-3.5" />
              <span className="text-xs">Opens</span>
            </div>
            <p className="text-lg font-semibold">{lead.email_open_count || 0}</p>
          </div>
          <div className="bg-background p-3 text-center">
            <div className="flex items-center justify-center gap-1.5 text-muted-foreground mb-1">
              <MousePointer className="h-3.5 w-3.5" />
              <span className="text-xs">Clicks</span>
            </div>
            <p className="text-lg font-semibold">{lead.email_click_count || 0}</p>
          </div>
          <div className="bg-background p-3 text-center">
            <div className="flex items-center justify-center gap-1.5 text-muted-foreground mb-1">
              <MessageSquare className="h-3.5 w-3.5" />
              <span className="text-xs">Replies</span>
            </div>
            <p className="text-lg font-semibold">{lead.email_reply_count || 0}</p>
          </div>
        </div>

        {/* Tabs */}
        <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 flex flex-col overflow-hidden">
          <TabsList className="w-full justify-start rounded-none border-b bg-transparent h-auto p-0">
            <TabsTrigger
              value="details"
              className="rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent px-4 py-3"
            >
              Details
            </TabsTrigger>
            <TabsTrigger
              value="emails"
              className="rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent px-4 py-3"
            >
              Emails ({emails.length})
            </TabsTrigger>
            <TabsTrigger
              value="notes"
              className="rounded-none border-b-2 border-transparent data-[state=active]:border-primary data-[state=active]:bg-transparent px-4 py-3"
            >
              Notes
            </TabsTrigger>
          </TabsList>

          <div className="flex-1 overflow-y-auto">
            {/* Details Tab */}
            <TabsContent value="details" className="m-0 p-4 space-y-4">
              {/* Status Selector */}
              <Card>
                <CardContent className="p-4">
                  <label className="text-sm font-medium text-foreground mb-2 block">Status</label>
                  <Select
                    value={lead.status}
                    onValueChange={(value) => handleStatusChange(value as LeadStatus)}
                    disabled={isSaving}
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      {statusOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          <div className="flex items-center gap-2">
                            <div className={`w-2 h-2 rounded-full ${option.color}`} />
                            {option.label}
                          </div>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </CardContent>
              </Card>

              {/* Contact Info */}
              <Card>
                <CardContent className="p-4">
                  <h4 className="text-sm font-medium text-foreground mb-3 flex items-center gap-2">
                    <User className="h-4 w-4" />
                    Contact Information
                  </h4>
                  <div className="space-y-3">
                    {lead.company_name && (
                      <div className="flex items-center gap-3 text-sm">
                        <Building2 className="h-4 w-4 text-muted-foreground shrink-0" />
                        <span>{lead.company_name}</span>
                      </div>
                    )}
                    {lead.company_domain && (
                      <div className="flex items-center gap-3 text-sm">
                        <Globe className="h-4 w-4 text-muted-foreground shrink-0" />
                        <a
                          href={`https://${lead.company_domain}`}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-primary hover:underline flex items-center gap-1"
                        >
                          {lead.company_domain}
                          <ExternalLink className="h-3 w-3" />
                        </a>
                      </div>
                    )}
                    {lead.phone && (
                      <div className="flex items-center gap-3 text-sm">
                        <Phone className="h-4 w-4 text-muted-foreground shrink-0" />
                        <a href={`tel:${lead.phone}`} className="text-primary hover:underline">
                          {lead.phone}
                        </a>
                      </div>
                    )}
                    {lead.linkedin_url && (
                      <div className="flex items-center gap-3 text-sm">
                        <Linkedin className="h-4 w-4 text-muted-foreground shrink-0" />
                        <a
                          href={lead.linkedin_url}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-primary hover:underline flex items-center gap-1"
                        >
                          LinkedIn Profile
                          <ExternalLink className="h-3 w-3" />
                        </a>
                      </div>
                    )}
                    {!lead.company_name && !lead.company_domain && !lead.phone && !lead.linkedin_url && (
                      <p className="text-sm text-muted-foreground">No additional contact info available</p>
                    )}
                  </div>
                </CardContent>
              </Card>

              {/* Personalization */}
              {lead.personalization && (
                <Card>
                  <CardContent className="p-4">
                    <h4 className="text-sm font-medium text-foreground mb-2">Personalization</h4>
                    <p className="text-sm text-muted-foreground bg-muted p-3 rounded-md">
                      {lead.personalization}
                    </p>
                  </CardContent>
                </Card>
              )}

              {/* Timeline */}
              <Card>
                <CardContent className="p-4">
                  <h4 className="text-sm font-medium text-foreground mb-3 flex items-center gap-2">
                    <Calendar className="h-4 w-4" />
                    Timeline
                  </h4>
                  <div className="space-y-2 text-sm">
                    {lead.last_contacted_at && (
                      <div className="flex items-center justify-between py-1.5 border-b border-border last:border-0">
                        <span className="text-muted-foreground flex items-center gap-2">
                          <Clock className="h-3.5 w-3.5" />
                          Last Contacted
                        </span>
                        <span>{new Date(lead.last_contacted_at).toLocaleDateString()}</span>
                      </div>
                    )}
                    <div className="flex items-center justify-between py-1.5 border-b border-border last:border-0">
                      <span className="text-muted-foreground flex items-center gap-2">
                        <Calendar className="h-3.5 w-3.5" />
                        Created
                      </span>
                      <span>{new Date(lead.created_at).toLocaleDateString()}</span>
                    </div>
                    <div className="flex items-center justify-between py-1.5 border-b border-border last:border-0">
                      <span className="text-muted-foreground flex items-center gap-2">
                        <RefreshCw className="h-3.5 w-3.5" />
                        Updated
                      </span>
                      <span>{new Date(lead.updated_at).toLocaleDateString()}</span>
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* IDs */}
              <Card>
                <CardContent className="p-4">
                  <h4 className="text-sm font-medium text-foreground mb-3 flex items-center gap-2">
                    <Hash className="h-4 w-4" />
                    Reference IDs
                  </h4>
                  <div className="space-y-2 text-sm">
                    <div className="flex items-center justify-between">
                      <span className="text-muted-foreground">Lead ID</span>
                      <code className="text-xs bg-muted px-2 py-1 rounded">{lead.id.slice(0, 12)}...</code>
                    </div>
                    {lead.instantly_lead_id && (
                      <div className="flex items-center justify-between">
                        <span className="text-muted-foreground">Instantly ID</span>
                        <code className="text-xs bg-muted px-2 py-1 rounded">{lead.instantly_lead_id.slice(0, 12)}...</code>
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>
            </TabsContent>

            {/* Emails Tab */}
            <TabsContent value="emails" className="m-0 p-4">
              <div className="flex items-center justify-between mb-4">
                <h4 className="text-sm font-medium flex items-center gap-2">
                  <Mail className="h-4 w-4" />
                  Email Thread
                </h4>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={syncEmails}
                  disabled={isSyncingEmails}
                >
                  <RefreshCw className={`h-3.5 w-3.5 mr-1.5 ${isSyncingEmails ? "animate-spin" : ""}`} />
                  {isSyncingEmails ? "Syncing..." : "Sync"}
                </Button>
              </div>

              {isLoadingEmails ? (
                <div className="flex items-center justify-center py-12">
                  <RefreshCw className="h-6 w-6 animate-spin text-muted-foreground" />
                </div>
              ) : emails.length === 0 ? (
                <div className="text-center py-12">
                  <div className="w-12 h-12 rounded-full bg-muted flex items-center justify-center mx-auto mb-3">
                    <Mail className="h-6 w-6 text-muted-foreground" />
                  </div>
                  <p className="text-sm font-medium">No emails yet</p>
                  <p className="text-xs text-muted-foreground mt-1">Click Sync to fetch emails from Instantly</p>
                </div>
              ) : (
                <div className="space-y-3">
                  {emails.map((email, index) => (
                    <Card
                      key={email.id}
                      className={`overflow-hidden ${
                        email.direction === "outbound"
                          ? "border-l-4 border-l-blue-500"
                          : "border-l-4 border-l-green-500"
                      }`}
                    >
                      <CardContent className="p-3">
                        <div className="flex items-center justify-between mb-2">
                          <Badge
                            variant="secondary"
                            className={
                              email.direction === "outbound"
                                ? "bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300"
                                : "bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300"
                            }
                          >
                            {email.direction === "outbound" ? (
                              <><ArrowUpRight className="h-3 w-3 mr-1" /> Sent</>
                            ) : (
                              <><ArrowDownLeft className="h-3 w-3 mr-1" /> Reply</>
                            )}
                          </Badge>
                          <span className="text-xs text-muted-foreground">
                            {email.sent_at ? new Date(email.sent_at).toLocaleString() : ""}
                          </span>
                        </div>
                        {email.subject && (
                          <p className="font-medium text-sm mb-2 truncate" title={email.subject}>
                            {email.subject}
                          </p>
                        )}
                        <div className="text-sm text-muted-foreground">
                          {email.body_html ? (
                            <div
                              className="prose prose-sm max-w-none dark:prose-invert [&_*]:text-sm [&_a]:text-primary"
                              dangerouslySetInnerHTML={{
                                __html: email.body_html.length > 300
                                  ? email.body_html.slice(0, 300) + "..."
                                  : email.body_html
                              }}
                            />
                          ) : (
                            <p className="line-clamp-3">
                              {email.body_text || "(No content)"}
                            </p>
                          )}
                        </div>
                      </CardContent>
                    </Card>
                  ))}
                </div>
              )}
            </TabsContent>

            {/* Notes Tab */}
            <TabsContent value="notes" className="m-0 p-4">
              <div className="space-y-3">
                <Textarea
                  value={notes}
                  onChange={(e) => setNotes(e.target.value)}
                  placeholder="Add notes about this lead..."
                  className="min-h-[200px] resize-none"
                />
                <Button
                  onClick={handleNotesSave}
                  disabled={isSaving || notes === lead.notes}
                  className="w-full"
                >
                  {isSaving ? (
                    <>
                      <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                      Saving...
                    </>
                  ) : (
                    "Save Notes"
                  )}
                </Button>
              </div>
            </TabsContent>
          </div>
        </Tabs>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="package.json">
{
  "name": "agency-client-portal",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-tabs": "^1.1.13",
    "@supabase/ssr": "^0.8.0",
    "@supabase/supabase-js": "^2.89.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.562.0",
    "next": "16.1.1",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "resend": "^6.6.0",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "dotenv": "^17.2.3",
    "eslint": "^9",
    "eslint-config-next": "16.1.1",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5"
  }
}
</file>

<file path="src/lib/instantly/types.ts">
// Instantly API V2 Types

// Base pagination types
export interface InstantlyPaginationParams {
  limit?: number;
  skip?: number;
}

export interface InstantlyPaginatedResponse<T> {
  items: T[];
  total_count?: number;
}

// Error types
export interface InstantlyApiError {
  error: string;
  message?: string;
  statusCode?: number;
}

// Campaign Sequence Variant (A/B testing)
export interface InstantlySequenceVariant {
  subject?: string;
  body?: string;
  v_disabled?: boolean;
}

// Campaign Sequence Step (email template)
export interface InstantlySequenceStep {
  type?: string; // "email" for now
  delay?: number; // Delay in days before sending
  variants?: InstantlySequenceVariant[]; // V2 API has variants array
  // Legacy fields (V1 API)
  subject?: string;
  body?: string;
  variant_id?: string;
}

// Campaign Sequence
export interface InstantlySequence {
  steps: InstantlySequenceStep[];
}

// Campaign types
export interface InstantlyCampaign {
  id: string;
  name: string;
  // Status can be numeric (1=active, 0=paused) or string depending on API version
  status: number | "active" | "paused" | "completed" | "draft";
  created_at: string;
  updated_at?: string;
  leads_count?: number;
  emails_sent_count?: number;
  replies_count?: number;
  bounces_count?: number;
  // Sequences contain the email templates
  sequences?: InstantlySequence[];
}

// Campaign with full details including sequences
export interface InstantlyCampaignDetails extends InstantlyCampaign {
  sequences: InstantlySequence[];
  email_gap?: number;
  daily_limit?: number;
  stop_on_reply?: boolean;
  link_tracking?: boolean;
  open_tracking?: boolean;
}

// Campaign Schedule for creation
export interface InstantlyCampaignSchedule {
  name?: string;
  timing?: {
    from: string; // e.g., "09:00"
    to: string;   // e.g., "17:00"
  };
  days?: {
    sunday?: boolean;
    monday?: boolean;
    tuesday?: boolean;
    wednesday?: boolean;
    thursday?: boolean;
    friday?: boolean;
    saturday?: boolean;
  };
  timezone?: string; // e.g., "Europe/Berlin"
}

// Campaign Creation Payload
export interface InstantlyCampaignCreatePayload {
  name: string;
  campaign_schedule: {
    schedules: InstantlyCampaignSchedule[];
  };
  // Optional fields
  sequences?: InstantlySequence[];
  email_gap?: number;        // Minutes between emails
  daily_limit?: number;      // Max emails per day
  stop_on_reply?: boolean;
  link_tracking?: boolean;
  open_tracking?: boolean;
  text_only?: boolean;
  email_list?: string[];     // Email accounts to use
}

export interface InstantlyCampaignAnalytics {
  campaign_id: string;
  campaign_name: string;
  campaign_status?: string;
  // Lead counts
  leads_count: number;
  contacted_count: number;
  completed_count: number;
  new_leads_contacted_count: number;
  // Email metrics
  emails_sent_count: number;
  open_count: number;
  open_count_unique: number;
  reply_count: number;
  reply_count_unique: number;
  link_click_count: number;
  link_click_count_unique: number;
  bounced_count: number;
  unsubscribed_count: number;
  // Opportunities
  total_opportunities: number;
  total_opportunity_value: number;
  total_interested?: number;
  total_meeting_booked?: number;
  total_meeting_completed?: number;
  total_closed?: number;
}

export interface InstantlyCampaignDailyAnalytics {
  date: string;
  sent: number;
  contacted: number;
  new_leads_contacted: number;
  opened: number;
  unique_opened: number;
  replies: number;
  unique_replies: number;
  replies_automatic: number;
  unique_replies_automatic: number;
  clicks: number;
  unique_clicks: number;
  opportunities: number;
  unique_opportunities: number;
}

// Lead types
export interface InstantlyLead {
  id: string;
  email: string;
  first_name?: string;
  last_name?: string;
  company_name?: string;
  phone?: string;
  website?: string;
  campaign_id?: string;
  campaign_name?: string;
  status?: string;
  interest_status?: "interested" | "not_interested" | "neutral" | "wrong_person" | "out_of_office" | "meeting_booked" | "meeting_completed" | "closed";
  lead_data?: Record<string, string>;
  created_at?: string;
  updated_at?: string;
}

export interface InstantlyLeadCreatePayload {
  campaign_id: string;
  email: string;
  first_name?: string;
  last_name?: string;
  company_name?: string;
  phone?: string;
  website?: string;
  custom_variables?: Record<string, string>;
  skip_if_in_campaign?: boolean;
  skip_if_in_workspace?: boolean;
}

export interface InstantlyLeadListPayload {
  campaign_id: string;
  limit?: number;
  skip?: number;
  email?: string;
  interest_status?: number | string;  // 1 = positive, 0 = not interested, etc.
}

export interface InstantlyLeadInterestUpdate {
  lead_email: string;
  campaign_id: string;
  interest_status: "interested" | "not_interested" | "neutral";
}

// Account types
export interface InstantlyAccount {
  email: string;
  first_name?: string;
  last_name?: string;
  provider?: string;
  warmup_status?: "enabled" | "disabled" | "paused";
  warmup_reputation?: number;
  daily_limit?: number;
  status?: "active" | "error" | "disconnected";
  error_message?: string;
  created_at?: string;
}

export interface InstantlyAccountWarmupAnalytics {
  email: string;
  warmup_emails_sent: number;
  warmup_emails_received: number;
  warmup_emails_saved_from_spam: number;
  reputation: number;
  warmup_status: string;
}

export interface InstantlyAccountDailyAnalytics {
  date: string;
  email: string;
  emails_sent: number;
  emails_received: number;
  warmup_sent: number;
  warmup_received: number;
}

// Email types (from Unibox API)
export interface InstantlyEmailBody {
  text?: string;
  html?: string;
}

export interface InstantlyEmail {
  id: string;
  from_address_email: string;
  to_address_email_list: string[];
  cc_address_email_list?: string[];
  bcc_address_email_list?: string[];
  subject: string;
  body?: InstantlyEmailBody;
  message_id?: string;
  thread_id?: string;
  i_campaign?: string; // Campaign ID
  lead_email?: string;
  eaccount?: string; // Sender account
  is_reply?: boolean;
  is_unread?: boolean;
  timestamp_email?: string; // When email was actually sent
  timestamp_created?: string; // When added to database
}

// Email list parameters
export interface InstantlyEmailListParams {
  campaign_id?: string;
  lead_email?: string;
  eaccount?: string;
  is_unread?: boolean;
  limit?: number;
  skip?: number;
}

// Simplified email for internal use
export interface InstantlyEmailSimple {
  id: string;
  from_email: string;
  to_email: string;
  subject: string;
  body_text?: string;
  body_html?: string;
  sent_at: string;
  opened_at?: string;
  replied_at?: string;
  campaign_id?: string;
  lead_id?: string;
  thread_id?: string;
  is_reply: boolean;
}

// Workspace types
export interface InstantlyWorkspace {
  id: string;
  name: string;
  owner_email: string;
  created_at: string;
}

// API Response wrappers
export interface InstantlyListResponse<T> {
  data: T[];
  next_starting_after?: string;
  has_more?: boolean;
}

export interface InstantlySingleResponse<T> {
  data: T;
}

// Sync types (for our internal use)
export interface SyncResult {
  success: boolean;
  imported: number;
  updated: number;
  failed: number;
  errors?: string[];
}
</file>

<file path="src/types/database.ts">
// ============================================
// DATABASE TYPES - Schema V2
// ============================================

// Enums
export type LeadStatus = "contacted" | "opened" | "clicked" | "replied" | "booked" | "won" | "lost" | "not_interested";
export type UserRole = "admin" | "client";
export type TeamRole = "owner" | "manager" | "member" | "viewer";
export type ActivityType = "call" | "meeting" | "email" | "note" | "status_change" | "task" | "other";
export type EmailEventType = "sent" | "opened" | "clicked" | "replied" | "bounced" | "unsubscribed" | "spam_complaint";
export type AuditAction = "create" | "update" | "delete";
export type BillingCycle = "monthly" | "yearly" | "quarterly" | "weekly" | "custom";

// ============================================
// CORE TABLES
// ============================================

export interface Profile {
  id: string;
  email: string | null;
  role: UserRole;
  full_name: string | null;
}

export interface Client {
  id: string;
  name: string;
  logo_url?: string | null;
  website?: string | null;
  notes?: string | null;
  product_service?: string | null;
  icp?: string | null;
  acv?: number | null;
  tcv?: number | null;
  verticals?: string[] | null;
  tam?: number | null;
  target_daily_emails?: number | null;
  is_active?: boolean;
  created_at: string;
}

export interface Campaign {
  id: string;
  client_id: string;
  instantly_campaign_id: string | null;
  provider_type: "instantly" | "smartlead" | "lemlist" | "apollo";
  provider_campaign_id: string | null;
  name: string;
  original_name: string | null;
  copy_body: string | null;
  is_active: boolean;
  last_synced_at: string | null;
  // Per-campaign API key fields
  api_key_encrypted: string | null;
  api_key_label: string | null;
  webhook_secret: string | null;
  last_lead_sync_at: string | null;
}

export interface Lead {
  id: string;
  campaign_id: string;
  email: string;
  first_name: string | null;
  last_name: string | null;
  company_name: string | null;
  company_domain: string | null;
  phone: string | null;
  linkedin_url: string | null;
  personalization: string | null;
  status: LeadStatus;
  is_positive_reply: boolean;
  deal_value: number | null;
  next_action: string | null;
  next_action_date: string | null;
  instantly_lead_id: string | null;
  instantly_created_at: string | null;
  last_contacted_at: string | null;
  last_step_info: Record<string, unknown> | null;
  email_open_count: number;
  email_click_count: number;
  email_reply_count: number;
  notes: string | null;
  metadata: Record<string, unknown>;
  created_at: string;
  updated_at: string;
  // Multi-provider support
  provider_type: ProviderType | null;
  provider_lead_id: string | null;
}

export interface ClientUser {
  client_id: string;
  user_id: string;
  role?: TeamRole;
}

// ============================================
// LEAD DATABASE TABLES
// ============================================

export interface LeadSource {
  id: string;
  name: string;
  file_name: string | null;
  industry: string | null;
  region: string | null;
  sub_region: string | null;
  source_type: string | null;
  scrape_date: string | null;
  tags: string[] | null;
  notes: string | null;
  custom_fields: Record<string, unknown>;
  total_records: number;
  imported_records: number;
  duplicate_records: number;
  created_at: string;
  updated_at: string;
}

export interface EnrichedLead {
  id: string;
  source_id: string | null;
  url: string | null;
  domain: string | null;
  email: string | null;
  first_name: string | null;
  last_name: string | null;
  full_name: string | null;
  job_title: string | null;
  linkedin_url: string | null;
  phone: string | null;
  company_name: string | null;
  company_size: string | null;
  company_revenue: string | null;
  company_founded: number | null;
  company_linkedin: string | null;
  country: string | null;
  city: string | null;
  state: string | null;
  industry: string | null;
  sub_industry: string | null;
  extra_data: Record<string, unknown>;
  contacted_at: string | null;
  campaign_id: string | null;
  lead_id: string | null;
  scraped_at: string | null;
  created_at: string;
  updated_at: string;
}

// ============================================
// PROVIDER & EMAIL TABLES
// ============================================

export type ProviderType = "instantly" | "smartlead" | "lemlist" | "apollo";
export type EmailDirection = "outbound" | "inbound";

export interface ApiProvider {
  id: string;
  client_id: string;
  provider_type: ProviderType;
  api_key: string;
  workspace_id: string | null;
  is_active: boolean;
  label: string | null;
  created_at: string;
  updated_at: string;
}

export interface CampaignSequence {
  id: string;
  campaign_id: string;
  sequence_index: number;
  step_number: number;
  variant: string;
  subject: string | null;
  body_text: string | null;
  body_html: string | null;
  delay_days: number;
  delay_hours: number;
  send_time_start: string | null;
  send_time_end: string | null;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface LeadEmail {
  id: string;
  lead_id: string;
  campaign_id: string | null;
  provider_email_id: string | null;
  provider_thread_id: string | null;
  direction: EmailDirection;
  from_email: string;
  to_email: string;
  cc_emails: string[] | null;
  bcc_emails: string[] | null;
  subject: string | null;
  body_text: string | null;
  body_html: string | null;
  sequence_step: number | null;
  is_auto_reply: boolean;
  sent_at: string | null;
  opened_at: string | null;
  clicked_at: string | null;
  replied_at: string | null;
  raw_headers: Record<string, unknown> | null;
  metadata: Record<string, unknown>;
  created_at: string;
}

// ============================================
// NEW TABLES
// ============================================

export interface Activity {
  id: string;
  lead_id: string;
  user_id: string | null;
  type: ActivityType;
  title: string | null;
  description: string | null;
  scheduled_at: string | null;
  completed_at: string | null;
  metadata: Record<string, unknown>;
  created_at: string;
}

export interface EmailEvent {
  id: string;
  lead_id: string | null;
  campaign_id: string | null;
  event_type: EmailEventType;
  instantly_event_id: string | null;
  email_subject: string | null;
  link_clicked: string | null;
  timestamp: string;
  metadata: Record<string, unknown>;
  // Multi-provider support
  provider_type: ProviderType | null;
  provider_event_id: string | null;
}

export interface TeamMember {
  id: string;
  client_id: string;
  user_id: string;
  role: TeamRole;
  invited_by: string | null;
  invited_at: string;
  accepted_at: string | null;
}

export interface AuditLog {
  id: string;
  user_id: string | null;
  user_email: string | null;
  action: AuditAction;
  table_name: string;
  record_id: string;
  old_data: Record<string, unknown> | null;
  new_data: Record<string, unknown> | null;
  changed_fields: string[] | null;
  ip_address: string | null;
  user_agent: string | null;
  created_at: string;
}

export interface Subscription {
  id: string;
  name: string;
  url: string | null;
  username: string | null;
  password: string | null;
  cost: number;
  billing_cycle: BillingCycle;
  renewal_date: string | null;
  credits_balance: number;
  credits_limit: number;
  category: string | null;
  notes: string | null;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

// ============================================
// INFRASTRUCTURE HEALTH TYPES
// ============================================

export type EmailAccountStatus = "active" | "error" | "disconnected" | "paused";
export type EmailAccountProvider = "instantly" | "smartlead";
export type DmarcPolicy = "none" | "quarantine" | "reject";

export interface EmailAccount {
  id: string;
  provider_type: EmailAccountProvider;
  provider_account_id: string | null;
  email: string;
  client_id: string | null;
  first_name: string | null;
  last_name: string | null;
  domain: string;
  status: EmailAccountStatus;
  error_message: string | null;
  warmup_enabled: boolean;
  warmup_reputation: number | null;
  warmup_emails_sent: number;
  warmup_emails_received: number;
  warmup_saved_from_spam: number;
  daily_limit: number | null;
  emails_sent_today: number;
  last_synced_at: string | null;
  created_at: string;
  updated_at: string;
}

export interface EmailAccountHealthHistory {
  id: string;
  email_account_id: string;
  snapshot_date: string;
  status: string | null;
  warmup_reputation: number | null;
  warmup_emails_sent: number | null;
  warmup_emails_received: number | null;
  emails_sent_today: number;
  emails_bounced_today: number;
  created_at: string;
}

export interface DomainHealth {
  id: string;
  domain: string;
  has_spf: boolean;
  spf_record: string | null;
  spf_valid: boolean;
  has_dkim: boolean;
  dkim_selector: string | null;
  dkim_record: string | null;
  dkim_valid: boolean;
  has_dmarc: boolean;
  dmarc_record: string | null;
  dmarc_policy: DmarcPolicy | null;
  dmarc_valid: boolean;
  health_score: number;
  last_checked_at: string | null;
  created_at: string;
  updated_at: string;
}

export interface EmailAccountWithHealth extends EmailAccount {
  client_name: string | null;
  domain_health_score: number | null;
  spf_valid: boolean | null;
  dkim_valid: boolean | null;
  dmarc_valid: boolean | null;
  dmarc_policy: DmarcPolicy | null;
}

export interface DomainSummary extends DomainHealth {
  account_count: number;
  client_count: number;
}

// ============================================
// VIEW TYPES
// ============================================

export interface PositiveReply extends Lead {
  campaign_name: string;
  client_name: string;
  activity_count: number;
  last_activity_at: string | null;
}

export interface CampaignPerformance {
  campaign_id: string;
  campaign_name: string;
  client_name: string;
  total_leads: number;
  opened_count: number;
  clicked_count: number;
  replied_count: number;
  positive_reply_count: number;
  booked_count: number;
  won_count: number;
  total_deal_value: number;
}

// ============================================
// HELPER TYPES
// ============================================

// Lead with related data
export interface LeadWithRelations extends Lead {
  campaign?: Campaign;
  activities?: Activity[];
  email_events?: EmailEvent[];
}

// Activity with user info
export interface ActivityWithUser extends Activity {
  user?: Pick<Profile, "id" | "email" | "full_name">;
}

// Team member with user info
export interface TeamMemberWithUser extends TeamMember {
  user?: Pick<Profile, "id" | "email" | "full_name">;
}

// ============================================
// SUPABASE DATABASE TYPE
// ============================================

export interface Database {
  public: {
    Tables: {
      profiles: {
        Row: Profile;
        Insert: Omit<Profile, "id"> & { id?: string };
        Update: Partial<Profile>;
      };
      clients: {
        Row: Client;
        Insert: Omit<Client, "id" | "created_at"> & { id?: string; created_at?: string };
        Update: Partial<Client>;
      };
      campaigns: {
        Row: Campaign;
        Insert: Omit<Campaign, "id"> & { id?: string };
        Update: Partial<Campaign>;
      };
      leads: {
        Row: Lead;
        Insert: Omit<Lead, "id" | "created_at" | "updated_at"> & {
          id?: string;
          created_at?: string;
          updated_at?: string;
          is_positive_reply?: boolean;
          metadata?: Record<string, unknown>;
        };
        Update: Partial<Lead>;
      };
      client_users: {
        Row: ClientUser;
        Insert: ClientUser;
        Update: Partial<ClientUser>;
      };
      activities: {
        Row: Activity;
        Insert: Omit<Activity, "id" | "created_at"> & {
          id?: string;
          created_at?: string;
          metadata?: Record<string, unknown>;
        };
        Update: Partial<Activity>;
      };
      email_events: {
        Row: EmailEvent;
        Insert: Omit<EmailEvent, "id" | "timestamp"> & {
          id?: string;
          timestamp?: string;
          metadata?: Record<string, unknown>;
        };
        Update: Partial<EmailEvent>;
      };
      team_members: {
        Row: TeamMember;
        Insert: Omit<TeamMember, "id" | "invited_at"> & {
          id?: string;
          invited_at?: string;
        };
        Update: Partial<TeamMember>;
      };
      audit_logs: {
        Row: AuditLog;
        Insert: Omit<AuditLog, "id" | "created_at"> & {
          id?: string;
          created_at?: string;
        };
        Update: never; // Audit logs should never be updated
      };
      subscriptions: {
        Row: Subscription;
        Insert: Omit<Subscription, "id" | "created_at" | "updated_at"> & {
          id?: string;
          created_at?: string;
          updated_at?: string;
        };
        Update: Partial<Omit<Subscription, "id" | "created_at">>;
      };
    };
    Views: {
      positive_replies: {
        Row: PositiveReply;
      };
      campaign_performance: {
        Row: CampaignPerformance;
      };
    };
    Functions: {
      log_audit: {
        Args: {
          p_user_id: string;
          p_action: AuditAction;
          p_table_name: string;
          p_record_id: string;
          p_old_data?: Record<string, unknown>;
          p_new_data?: Record<string, unknown>;
        };
        Returns: string;
      };
    };
    Enums: {
      lead_status: LeadStatus;
      user_role: UserRole;
      team_role: TeamRole;
      activity_type: ActivityType;
      email_event_type: EmailEventType;
      audit_action: AuditAction;
      billing_cycle: BillingCycle;
    };
  };
}
</file>

<file path="src/app/api/instantly/leads/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import {
  fetchAllLeadsForCampaign,
  createInstantlyLead,
  updateLeadInterestStatus,
  getInstantlyClient,
} from "@/lib/instantly";
import type { InstantlyLeadCreatePayload } from "@/lib/instantly";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// GET - List leads from Instantly for a campaign
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const campaignId = searchParams.get("campaign_id");
    const limit = parseInt(searchParams.get("limit") || "100", 10);
    const skip = parseInt(searchParams.get("skip") || "0", 10);

    if (!campaignId) {
      return NextResponse.json(
        { error: "campaign_id is required" },
        { status: 400 }
      );
    }

    const client = getInstantlyClient();
    if (!(await client.isConfiguredAsync())) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    // Support pagination instead of fetching all at once
    const { fetchInstantlyLeads } = await import("@/lib/instantly");
    const leads = await fetchInstantlyLeads({
      campaign_id: campaignId,
      limit,
      skip,
    });

    return NextResponse.json({
      leads,
      pagination: {
        limit,
        skip,
        count: leads.length,
        has_more: leads.length === limit
      }
    });
  } catch (error) {
    console.error("Error fetching leads:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to fetch leads" },
      { status: 500 }
    );
  }
}

// POST - Push leads to Instantly or sync from Instantly to local DB
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { action, campaign_id, leads, instantly_campaign_id } = body as {
      action: "push" | "sync" | "update_status";
      campaign_id?: string;
      instantly_campaign_id?: string;
      leads?: InstantlyLeadCreatePayload[];
      lead_email?: string;
      interest_status?: string;
      limit?: string | number;
      skip?: string | number;
    };

    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    if (action === "push") {
      // Push leads to Instantly
      if (!leads || leads.length === 0) {
        return NextResponse.json(
          { error: "leads array is required for push action" },
          { status: 400 }
        );
      }

      let created = 0;
      let failed = 0;
      const errors: string[] = [];

      for (const lead of leads) {
        try {
          await createInstantlyLead(lead);
          created++;
        } catch (error) {
          failed++;
          errors.push(`Failed to push ${lead.email}: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }

      return NextResponse.json({ success: true, created, failed, errors: errors.length > 0 ? errors : undefined });
    }

    if (action === "sync") {
      // Sync leads from Instantly to local DB (with batch support)
      if (!instantly_campaign_id || !campaign_id) {
        return NextResponse.json(
          { error: "instantly_campaign_id and campaign_id are required for sync action" },
          { status: 400 }
        );
      }

      const { fetchInstantlyLeads } = await import("@/lib/instantly");
      const syncLimit = body.limit ? parseInt(body.limit, 10) : 100;
      const syncSkip = body.skip ? parseInt(body.skip, 10) : 0;

      const supabase = getSupabase();

      // Fetch one batch of leads
      const instantlyLeads = await fetchInstantlyLeads({
        campaign_id: instantly_campaign_id,
        limit: syncLimit,
        skip: syncSkip,
      });

      let imported = 0;
      let updated = 0;
      let failed = 0;

      for (const lead of instantlyLeads) {
        // Extract additional Instantly fields (needed for both insert and update)
        const instantlyData = lead as {
          company_domain?: string;
          personalization?: string;
          timestamp_created?: string;
          timestamp_last_contact?: string;
          status_summary?: { lastStep?: Record<string, unknown> };
          email_open_count?: number;
          email_click_count?: number;
          email_reply_count?: number;
          payload?: Record<string, string>;
        };

        const { data: existingLead } = await supabase
          .from("leads")
          .select("id, status, is_positive_reply, first_name, last_name, company_name, company_domain, phone, personalization, email_open_count, email_click_count, email_reply_count")
          .eq("campaign_id", campaign_id)
          .eq("email", lead.email)
          .single();

        // Build metadata with all extra Instantly data
        const metadata: Record<string, unknown> = {};
        if (lead.website) metadata.website = lead.website;
        if (lead.lead_data) metadata.lead_data = lead.lead_data;
        if (lead.status) metadata.instantly_status = lead.status;
        if (lead.interest_status) metadata.interest_status = lead.interest_status;
        if (lead.campaign_name) metadata.campaign_name = lead.campaign_name;
        if (lead.created_at) metadata.instantly_created_at = lead.created_at;
        if (lead.updated_at) metadata.instantly_updated_at = lead.updated_at;
        if (instantlyData.payload) metadata.lead_data = instantlyData.payload;

        // Check if lead has replied using email_reply_count
        const hasReplied = ((lead as { email_reply_count?: number }).email_reply_count || 0) > 0;

        // Positive reply = manually tagged as interested/booked/etc (NOT just any reply)
        const positiveStatuses = ["interested", "meeting_booked", "meeting_completed", "closed"];
        const isPositiveReply = positiveStatuses.includes(lead.interest_status || "");

        // Map to our lead status: contacted  replied  meeting  closed_won / closed_lost
        let leadStatus: string = "contacted";
        if (lead.interest_status === "closed") {
          leadStatus = "won";
        } else if (lead.interest_status === "not_interested" || lead.interest_status === "wrong_person") {
          leadStatus = "lost";
        } else if (lead.interest_status === "meeting_booked" || lead.interest_status === "meeting_completed") {
          leadStatus = "booked";
        } else if (hasReplied || lead.interest_status === "interested") {
          leadStatus = "replied";
        }

        if (existingLead) {
          // Lead exists - UPDATE Instantly-sourced fields while preserving local-only fields
          // Status priority: won(8) > lost(7) > booked(6) > replied(5) > clicked(4) > opened(3) > contacted(2) > not_interested(1)
          const statusPriority: Record<string, number> = {
            "won": 8, "lost": 7, "booked": 6, "replied": 5,
            "clicked": 4, "opened": 3, "contacted": 2, "not_interested": 1
          };

          const currentPriority = statusPriority[existingLead.status] || 0;
          const newPriority = statusPriority[leadStatus] || 0;

          // Build update object - only update fields that should be updated
          const updateData: Record<string, unknown> = {
            // Always update these from Instantly
            last_contacted_at: instantlyData.timestamp_last_contact || null,
            last_step_info: instantlyData.status_summary?.lastStep || null,
            // Only increment counts, never decrease
            email_open_count: Math.max(instantlyData.email_open_count || 0, existingLead.email_open_count || 0),
            email_click_count: Math.max(instantlyData.email_click_count || 0, existingLead.email_click_count || 0),
            email_reply_count: Math.max(instantlyData.email_reply_count || 0, existingLead.email_reply_count || 0),
          };

          // Only update status if new status has higher priority (never downgrade)
          if (newPriority > currentPriority) {
            updateData.status = leadStatus;
          }

          // Only set is_positive_reply to true, never reset to false via sync
          if (isPositiveReply && !existingLead.is_positive_reply) {
            updateData.is_positive_reply = true;
          }

          // Fill-only fields: only update if local value is empty
          if (!existingLead.first_name && lead.first_name) updateData.first_name = lead.first_name;
          if (!existingLead.last_name && lead.last_name) updateData.last_name = lead.last_name;
          if (!existingLead.company_name && lead.company_name) updateData.company_name = lead.company_name;
          if (!existingLead.company_domain && instantlyData.company_domain) updateData.company_domain = instantlyData.company_domain;
          if (!existingLead.phone && lead.phone) updateData.phone = lead.phone;
          if (!existingLead.personalization && instantlyData.personalization) updateData.personalization = instantlyData.personalization;

          // NOTE: These fields are NEVER touched by sync (preserved):
          // - notes, deal_value, next_action, next_action_date, linkedin_url

          const { error: updateError } = await supabase
            .from("leads")
            .update(updateData)
            .eq("id", existingLead.id);

          if (updateError) {
            failed++;
          } else {
            updated++;
          }
        } else {
          // Create new lead with ALL fields
          const { error } = await supabase.from("leads").insert({
            campaign_id,
            email: lead.email,
            first_name: lead.first_name || null,
            last_name: lead.last_name || null,
            company_name: lead.company_name || null,
            company_domain: instantlyData.company_domain || null,
            phone: lead.phone || null,
            personalization: instantlyData.personalization || null,
            status: leadStatus || "contacted",
            instantly_lead_id: lead.id,
            instantly_created_at: instantlyData.timestamp_created || null,
            last_contacted_at: instantlyData.timestamp_last_contact || null,
            last_step_info: instantlyData.status_summary?.lastStep || null,
            email_reply_count: instantlyData.email_reply_count || 0,
            has_replied: hasReplied,
            is_positive_reply: isPositiveReply,
            metadata: Object.keys(metadata).length > 0 ? metadata : {},
          });

          if (error) {
            failed++;
          } else {
            imported++;
          }
        }
      }

      const hasMore = instantlyLeads.length === syncLimit;

      return NextResponse.json({
        success: true,
        imported,
        updated,
        failed,
        batch: {
          skip: syncSkip,
          limit: syncLimit,
          fetched: instantlyLeads.length,
          has_more: hasMore,
          next_skip: hasMore ? syncSkip + syncLimit : null
        }
      });
    }

    if (action === "update_status") {
      const { lead_email, interest_status } = body;
      if (!lead_email || !instantly_campaign_id || !interest_status) {
        return NextResponse.json(
          { error: "lead_email, instantly_campaign_id, and interest_status are required" },
          { status: 400 }
        );
      }

      await updateLeadInterestStatus({
        lead_email,
        campaign_id: instantly_campaign_id,
        interest_status: interest_status as "interested" | "not_interested" | "neutral",
      });

      return NextResponse.json({ success: true });
    }

    return NextResponse.json(
      { error: "Invalid action. Use 'push', 'sync', or 'update_status'" },
      { status: 400 }
    );
  } catch (error) {
    console.error("Error processing leads:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Failed to process leads" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/admin/clients/[clientId]/campaigns/[campaignId]/page.tsx">
"use client";

import { useEffect, useState, useCallback, useRef, useMemo } from "react";
import { useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import Link from "next/link";
import {
  ArrowLeft,
  Mail,
  MessageSquare,
  Users,
  RefreshCw,
  ExternalLink,
  ThumbsUp,
  AlertCircle,
  FileText,
  Edit2,
  Check,
  X,
  Download,
  Eye,
  Code,
} from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface CampaignAnalytics {
  emails_sent: number;
  emails_opened: number;
  emails_replied: number;
  emails_bounced: number;
  open_rate: number;
  reply_rate: number;
  bounce_rate: number;
  total_opportunities: number;
  leads_count: number;
  contacted_count: number;
}

interface CampaignData {
  id: string;
  name: string;
  original_name: string | null;
  instantly_campaign_id: string | null;
  is_active: boolean;
  created_at: string;
  client_id: string;
}

interface CampaignSequence {
  id: string;
  step_number: number;
  variant: string;
  subject: string | null;
  body_text: string | null;
  body_html: string | null;
  delay_days: number;
}

interface ClientData {
  id: string;
  name: string;
}

interface Lead {
  id: string;
  email: string;
  first_name: string | null;
  last_name: string | null;
  company_name: string | null;
  company_domain: string | null;
  phone: string | null;
  personalization: string | null;
  status: string;
  is_positive_reply: boolean;
  created_at: string;
  updated_at: string;
  metadata?: Record<string, unknown>;
}

export default function CampaignDetailPage() {
  const params = useParams();
  const clientId = params.clientId as string;
  const campaignId = params.campaignId as string;

  const [campaign, setCampaign] = useState<CampaignData | null>(null);
  const [client, setClient] = useState<ClientData | null>(null);
  const [analytics, setAnalytics] = useState<CampaignAnalytics | null>(null);
  const [leads, setLeads] = useState<Lead[]>([]);
  const [sequences, setSequences] = useState<CampaignSequence[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);

  // Editing state
  const [isEditingName, setIsEditingName] = useState(false);
  const [editedName, setEditedName] = useState("");
  const [isSavingName, setIsSavingName] = useState(false);

  // Sequences sync state
  const [isSyncingSequences, setIsSyncingSequences] = useState(false);

  // Leads sync state
  const [isSyncingLeads, setIsSyncingLeads] = useState(false);
  const [syncLeadsResult, setSyncLeadsResult] = useState<string | null>(null);
  const [syncElapsed, setSyncElapsed] = useState(0);
  const syncTimerRef = useRef<NodeJS.Timeout | null>(null);

  // Email history sync state
  const [isSyncingEmails, setIsSyncingEmails] = useState(false);
  const [syncEmailsResult, setSyncEmailsResult] = useState<string | null>(null);

  // Calculate estimated sync time based on lead count
  const estimatedSyncTime = useMemo(() => {
    const leadsCount = analytics?.leads_count || 0;
    if (!leadsCount || leadsCount <= 0) return 30;
    const pages = Math.ceil(leadsCount / 100);
    const batches = Math.ceil(pages / 5);
    const apiTime = batches * 1.2;
    const dbTime = leadsCount / 500;
    return Math.ceil(apiTime + dbTime);
  }, [analytics?.leads_count]);

  // Check if already synced (local count is within 5% of provider count)
  const isAlreadySynced = useMemo(() => {
    const providerCount = analytics?.leads_count || 0;
    const localCount = leads.length;
    return providerCount > 0 && localCount > 0 &&
      Math.abs(localCount - providerCount) / providerCount < 0.05;
  }, [analytics?.leads_count, leads.length]);

  // Timer for sync progress
  useEffect(() => {
    if (isSyncingLeads) {
      setSyncElapsed(0);
      syncTimerRef.current = setInterval(() => {
        setSyncElapsed((prev) => prev + 1);
      }, 1000);
    } else {
      if (syncTimerRef.current) {
        clearInterval(syncTimerRef.current);
        syncTimerRef.current = null;
      }
    }
    return () => {
      if (syncTimerRef.current) clearInterval(syncTimerRef.current);
    };
  }, [isSyncingLeads]);

  // Preview mode state - default to true to show filled-in variables
  const [isPreviewMode, setIsPreviewMode] = useState(true);
  const [previewLeadId, setPreviewLeadId] = useState<string | null>(null);

  // Get 3 sample leads for preview - spread across the list for variety
  const getSampleLeads = () => {
    if (leads.length === 0) return [];
    if (leads.length <= 3) return leads;
    // Pick leads from different positions for variety
    const indices = [
      0, // First lead
      Math.floor(leads.length / 2), // Middle lead
      Math.min(leads.length - 1, Math.floor(leads.length * 0.75)), // Near end
    ];
    return indices.map(i => leads[i]);
  };
  const sampleLeads = getSampleLeads();

  // Get the selected preview lead (if using single preview mode)
  const previewLead = leads.find(l => l.id === previewLeadId) || leads[0];

  // Function to replace template variables with lead data
  const replaceTemplateVariables = (content: string, lead: Lead | undefined): string => {
    if (!content || !lead) return content;

    let result = content;

    // Common curly brace variable replacements {{variable}}
    const curlyReplacements: Record<string, string> = {
      '{{firstName}}': lead.first_name || '',
      '{{first_name}}': lead.first_name || '',
      '{{lastName}}': lead.last_name || '',
      '{{last_name}}': lead.last_name || '',
      '{{email}}': lead.email || '',
      '{{companyName}}': lead.company_name || '',
      '{{company_name}}': lead.company_name || '',
      '{{company}}': lead.company_name || '',
      '{{phone}}': lead.phone || '',
      '{{domain}}': lead.company_domain || '',
      '{{company_domain}}': lead.company_domain || '',
    };

    // Apply curly brace replacements
    Object.entries(curlyReplacements).forEach(([variable, value]) => {
      result = result.replace(new RegExp(variable.replace(/[{}]/g, '\\$&'), 'gi'), value);
    });

    // Handle RANDOM variables - pick the first option for preview
    result = result.replace(/\{\{RANDOM\s*\|\s*([^}]+)\}\}/gi, (match, options) => {
      const firstOption = options.split('|')[0].trim();
      return firstOption;
    });

    // Get lead_data from metadata for custom variables
    const leadData = lead.metadata?.lead_data as Record<string, string> | undefined;

    // Map common template variables to possible payload field names
    const variableMappings: Record<string, string[]> = {
      '1st line': ['1st line', '1stLine', 'Master Line', 'masterLine', 'Icebreaker', 'icebreaker', 'personalization', 'opening_line', 'openingLine'],
      '2nd line': ['2nd line', '2ndLine', 'P.S.', 'PS', 'ps', 'postscript', 'closing_line', 'closingLine'],
      '3rd line': ['3rd line', '3rdLine', 'extra_line', 'extraLine'],
    };

    // Replace remaining curly brace variables
    result = result.replace(/\{\{([^}]+)\}\}/g, (match, varName) => {
      const trimmedVar = varName.trim();

      // Check if there's a mapping for this variable
      const possibleKeys = variableMappings[trimmedVar] || [trimmedVar];

      // Try to find the value in lead_data
      if (leadData) {
        for (const key of possibleKeys) {
          if (leadData[key] && leadData[key].trim() !== '') {
            return leadData[key];
          }
        }
        // Also try exact match with the variable name
        if (leadData[trimmedVar] && leadData[trimmedVar].trim() !== '') {
          return leadData[trimmedVar];
        }
      }
      return '';
    });

    // Handle bracket-style placeholders [variable]
    // These are used for personalization lines and signatures

    // Common bracket-style replacements
    const bracketReplacements: Record<string, string> = {
      '[first_name]': lead.first_name || '',
      '[firstName]': lead.first_name || '',
      '[last_name]': lead.last_name || '',
      '[lastName]': lead.last_name || '',
      '[company]': lead.company_name || '',
      '[companyName]': lead.company_name || '',
      '[company_name]': lead.company_name || '',
      '[email]': lead.email || '',
      '[phone]': lead.phone || '',
      '[domain]': lead.company_domain || '',
      // Personalization - the personalization field contains the opening line
      '[1st line]': lead.personalization || '',
      '[1stLine]': lead.personalization || '',
      '[icebreaker]': lead.personalization || '',
      '[Icebreaker]': lead.personalization || '',
      // Additional lines from lead_data if available
      '[2nd line]': leadData?.['2nd line'] || leadData?.['2ndLine'] || leadData?.secondLine || '',
      '[2ndLine]': leadData?.['2nd line'] || leadData?.['2ndLine'] || leadData?.secondLine || '',
      '[3rd line]': leadData?.['3rd line'] || leadData?.['3rdLine'] || leadData?.thirdLine || '',
      '[3rdLine]': leadData?.['3rd line'] || leadData?.['3rdLine'] || leadData?.thirdLine || '',
      // Signature - remove it in preview as it's added by the email sending system
      '[accountSignature]': '',
      '[signature]': '',
      '[Signature]': '',
    };

    // Apply bracket-style replacements (case-insensitive)
    Object.entries(bracketReplacements).forEach(([variable, value]) => {
      const escapedVar = variable.replace(/[[\]]/g, '\\$&');
      result = result.replace(new RegExp(escapedVar, 'gi'), value);
    });

    // Handle any remaining bracket variables - try to find them in lead_data
    result = result.replace(/\[([^\]]+)\]/g, (match, varName) => {
      const normalizedName = varName.trim();
      // Check metadata.lead_data for custom variables
      if (leadData && leadData[normalizedName]) {
        return leadData[normalizedName];
      }
      // Also try camelCase and snake_case variants
      const camelCase = normalizedName.replace(/\s+(.)/g, (m: string, c: string) => c.toUpperCase());
      const snakeCase = normalizedName.replace(/\s+/g, '_').toLowerCase();
      if (leadData && leadData[camelCase]) {
        return leadData[camelCase];
      }
      if (leadData && leadData[snakeCase]) {
        return leadData[snakeCase];
      }
      // Return empty string instead of showing placeholder
      return '';
    });

    return result;
  };

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      // Fetch campaign details, sequences, and leads
      const [campaignRes, clientRes, leadsRes, sequencesRes] = await Promise.all([
        fetch(`/api/campaigns/${campaignId}/details`),
        fetch(`/api/clients/${clientId}`),
        fetch(`/api/campaigns/${campaignId}/leads`),
        fetch(`/api/campaigns/${campaignId}/sequences`),
      ]);

      if (!campaignRes.ok) {
        throw new Error("Campaign not found");
      }

      const campaignData = await campaignRes.json();
      const clientData = await clientRes.json();
      const leadsData = await leadsRes.json();
      const sequencesData = await sequencesRes.json();

      setCampaign(campaignData.campaign);
      setAnalytics(campaignData.analytics);
      setClient(clientData.client);
      setLeads(leadsData.leads || []);
      setSequences(sequencesData.sequences || []);
      setLastUpdated(new Date());
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load data");
    } finally {
      setLoading(false);
    }
  }, [campaignId, clientId]);

  // Save campaign name
  const handleSaveName = async () => {
    if (!editedName.trim() || editedName === campaign?.name) {
      setIsEditingName(false);
      return;
    }

    setIsSavingName(true);
    try {
      const res = await fetch(`/api/campaigns/${campaignId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: editedName.trim() }),
      });

      if (!res.ok) throw new Error("Failed to update name");

      const data = await res.json();
      setCampaign(data.campaign);
      setIsEditingName(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to save name");
    } finally {
      setIsSavingName(false);
    }
  };

  // Sync leads from provider
  const handleSyncLeads = async () => {
    setIsSyncingLeads(true);
    setSyncLeadsResult(null);
    setError(null);

    try {
      const res = await fetch(`/api/campaigns/${campaignId}/sync-leads`, {
        method: "POST",
      });

      const data = await res.json();

      if (!res.ok || data.error) {
        throw new Error(data.error || "Failed to sync leads");
      }

      setSyncLeadsResult(`Synced ${data.inserted} new, ${data.updated} updated`);
      // Refresh data to show new leads
      await fetchData();
    } catch (err) {
      console.error("Lead sync error:", err);
      setError(err instanceof Error ? err.message : "Failed to sync leads");
    } finally {
      setIsSyncingLeads(false);
    }
  };

  // Sync email history from provider
  const handleSyncEmails = async () => {
    setIsSyncingEmails(true);
    setSyncEmailsResult(null);
    setError(null);

    try {
      const res = await fetch(`/api/campaigns/${campaignId}/sync-emails`, {
        method: "POST",
      });

      const data = await res.json();

      if (!res.ok || data.error) {
        throw new Error(data.error || "Failed to sync emails");
      }

      setSyncEmailsResult(`Synced ${data.emailsSynced} emails for ${data.leadsProcessed} leads`);
    } catch (err) {
      console.error("Email sync error:", err);
      setError(err instanceof Error ? err.message : "Failed to sync emails");
    } finally {
      setIsSyncingEmails(false);
      // Clear result after 5 seconds
      setTimeout(() => setSyncEmailsResult(null), 5000);
    }
  };

  // Sync sequences from Instantly
  const handleSyncSequences = async () => {
    setIsSyncingSequences(true);
    setError(null);
    try {
      const res = await fetch(`/api/campaigns/${campaignId}/sequences`, {
        method: "POST",
      });

      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.error || "Failed to sync sequences");
      }

      // Show message if synced 0 sequences
      if (data.synced === 0 && data.message) {
        console.log("Sync result:", data);
        setError(data.message);
      }

      // Refresh sequences
      const sequencesRes = await fetch(`/api/campaigns/${campaignId}/sequences`);
      const sequencesData = await sequencesRes.json();
      setSequences(sequencesData.sequences || []);
    } catch (err) {
      console.error("Sync error:", err);
      setError(err instanceof Error ? err.message : "Failed to sync sequences");
    } finally {
      setIsSyncingSequences(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  if (loading && !campaign) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <RefreshCw className="h-8 w-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (error && !campaign) {
    return (
      <div className="space-y-4">
        <Link
          href={`/admin/clients/${clientId}`}
          className="text-sm text-blue-600 dark:text-blue-400 hover:underline flex items-center gap-1"
        >
          <ArrowLeft className="h-4 w-4" />
          Back to {client?.name || "Client"}
        </Link>
        <div className="bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-300 px-4 py-3 rounded-lg">
          {error}
        </div>
      </div>
    );
  }

  // contacted_count can exceed leads_count because it includes follow-up emails
  // Use the minimum of contacted vs leads for a sensible progress percentage
  const leadsContacted = analytics
    ? Math.min(analytics.contacted_count, analytics.leads_count)
    : 0;
  const progress = analytics && analytics.leads_count > 0
    ? (leadsContacted / analytics.leads_count) * 100
    : 0;

  // Group leads by status
  const positiveLeads = leads.filter(l => l.is_positive_reply);
  const repliedLeads = leads.filter(l => l.status === 'replied' && !l.is_positive_reply);
  const recentLeads = leads.slice(0, 10);

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4">
        <div>
          <Link
            href={`/admin/clients/${clientId}`}
            className="text-sm text-muted-foreground hover:text-foreground flex items-center gap-1 mb-2"
          >
            <ArrowLeft className="h-4 w-4" />
            Back to {client?.name || "Client"}
          </Link>
          <div className="flex items-center gap-3">
            {isEditingName ? (
              <div className="flex items-center gap-2">
                <Input
                  value={editedName}
                  onChange={(e) => setEditedName(e.target.value)}
                  className="text-xl font-bold h-9 w-80"
                  autoFocus
                  onKeyDown={(e) => {
                    if (e.key === "Enter") handleSaveName();
                    if (e.key === "Escape") setIsEditingName(false);
                  }}
                />
                <Button
                  size="sm"
                  variant="ghost"
                  onClick={handleSaveName}
                  disabled={isSavingName}
                >
                  <Check className="h-4 w-4 text-green-600" />
                </Button>
                <Button
                  size="sm"
                  variant="ghost"
                  onClick={() => setIsEditingName(false)}
                >
                  <X className="h-4 w-4 text-red-500" />
                </Button>
              </div>
            ) : (
              <>
                <h1 className="text-2xl font-bold text-foreground">{campaign?.name}</h1>
                <Button
                  size="sm"
                  variant="ghost"
                  onClick={() => {
                    setEditedName(campaign?.name || "");
                    setIsEditingName(true);
                  }}
                  title="Edit campaign name"
                >
                  <Edit2 className="h-4 w-4 text-muted-foreground" />
                </Button>
              </>
            )}
            <Badge
              variant={campaign?.is_active ? "default" : "secondary"}
              className={
                campaign?.is_active
                  ? "bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300"
                  : progress >= 99.5
                  ? "bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300"
                  : ""
              }
            >
              {campaign?.is_active ? "Active" : progress >= 99.5 ? "Completed" : "Paused"}
            </Badge>
          </div>
          <p className="text-muted-foreground text-sm mt-1">
            Campaign Details
            {campaign?.original_name && campaign.original_name !== campaign.name && (
              <span className="ml-2 text-xs">(Originally: {campaign.original_name})</span>
            )}
          </p>
        </div>
        <div className="flex items-center gap-2">
          {campaign?.instantly_campaign_id && (
            <a
              href={`https://app.instantly.ai/app/campaign/${campaign.instantly_campaign_id}`}
              target="_blank"
              rel="noopener noreferrer"
            >
              <Button variant="outline" size="sm">
                <ExternalLink className="h-4 w-4 mr-2" />
                Open in Instantly
              </Button>
            </a>
          )}
          <div className="flex flex-col gap-1">
            <div className="flex items-center gap-2">
              <Button
                variant="default"
                size="sm"
                onClick={handleSyncLeads}
                disabled={isSyncingLeads}
              >
                <Download className={`h-4 w-4 mr-2 ${isSyncingLeads ? "animate-spin" : ""}`} />
                {isSyncingLeads ? "Syncing Leads..." : "Sync Leads"}
              </Button>
              {!isSyncingLeads && (
                isAlreadySynced ? (
                  <span className="text-xs text-green-600 flex items-center gap-1">
                    <Check className="h-3 w-3" />
                    Synced ({leads.length.toLocaleString()} leads)
                  </span>
                ) : analytics?.leads_count && analytics.leads_count > 0 ? (
                  <span className="text-xs text-muted-foreground">
                    {analytics.leads_count.toLocaleString()} leads (~{estimatedSyncTime}s)
                  </span>
                ) : null
              )}
            </div>
            {isSyncingLeads && (
              <div className="flex items-center gap-2 min-w-[200px]">
                <div className="flex-1 h-1.5 bg-muted rounded-full overflow-hidden">
                  <div
                    className="h-full bg-blue-500 transition-all duration-1000"
                    style={{ width: `${Math.min((syncElapsed / estimatedSyncTime) * 100, 95)}%` }}
                  />
                </div>
                <span className="text-xs text-muted-foreground">
                  {syncElapsed}s / ~{estimatedSyncTime}s
                </span>
              </div>
            )}
          </div>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={handleSyncEmails}
              disabled={isSyncingEmails || leads.length === 0}
              title="Sync email history for leads with replies"
            >
              <Mail className={`h-4 w-4 mr-2 ${isSyncingEmails ? "animate-spin" : ""}`} />
              {isSyncingEmails ? "Syncing..." : "Sync Emails"}
            </Button>
            {syncEmailsResult && (
              <span className="text-xs text-green-600 flex items-center gap-1">
                <Check className="h-3 w-3" />
                {syncEmailsResult}
              </span>
            )}
          </div>
          <Button
            variant="outline"
            size="sm"
            onClick={fetchData}
            disabled={loading}
          >
            <RefreshCw className={`h-4 w-4 mr-2 ${loading ? "animate-spin" : ""}`} />
            Refresh
          </Button>
        </div>
      </div>

      {/* Sync Result Message */}
      {syncLeadsResult && (
        <div className="bg-green-50 dark:bg-green-950 border border-green-200 dark:border-green-800 text-green-700 dark:text-green-300 px-4 py-3 rounded-lg flex items-center gap-2">
          <Check className="h-4 w-4" />
          {syncLeadsResult}
        </div>
      )}

      {/* Campaign Progress */}
      {analytics && analytics.leads_count > 0 && (
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between text-sm text-muted-foreground mb-2">
              <span className="font-medium">Campaign Progress</span>
              <span>
                {leadsContacted.toLocaleString()} / {analytics.leads_count.toLocaleString()} leads contacted ({progress.toFixed(0)}%)
              </span>
            </div>
            <div className="h-3 bg-muted rounded-full overflow-hidden">
              <div
                className="h-full bg-blue-500 rounded-full transition-all"
                style={{ width: `${progress}%` }}
              />
            </div>
          </CardContent>
        </Card>
      )}

      {/* Stats Grid */}
      <div className="grid grid-cols-2 lg:grid-cols-5 gap-4">
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-muted-foreground">Total Leads</span>
              <Users className="h-5 w-5 text-muted-foreground" />
            </div>
            <div className="text-2xl font-bold text-foreground">
              {analytics?.leads_count?.toLocaleString() || 0}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-muted-foreground">Emails Sent</span>
              <Mail className="h-5 w-5 text-blue-500" />
            </div>
            <div className="text-2xl font-bold text-foreground">
              {analytics?.emails_sent?.toLocaleString() || 0}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-muted-foreground">Replies</span>
              <MessageSquare className="h-5 w-5 text-emerald-500" />
            </div>
            <div className="text-2xl font-bold text-foreground">
              {analytics?.emails_replied?.toLocaleString() || 0}
            </div>
            <p className="text-xs text-muted-foreground">
              {((analytics?.reply_rate || 0) * 100).toFixed(1)}% rate
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-muted-foreground">Positive Replies</span>
              <ThumbsUp className="h-5 w-5 text-green-500" />
            </div>
            <div className="text-2xl font-bold text-green-600">
              {analytics?.total_opportunities?.toLocaleString() || 0}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-muted-foreground">Bounced</span>
              <AlertCircle className="h-5 w-5 text-red-500" />
            </div>
            <div className="text-2xl font-bold text-foreground">
              {analytics?.emails_bounced?.toLocaleString() || 0}
            </div>
            <p className="text-xs text-muted-foreground">
              {((analytics?.bounce_rate || 0) * 100).toFixed(1)}% rate
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Email Sequences */}
      <Card>
        <CardHeader className="pb-4">
          <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4">
            <CardTitle className="flex items-center gap-2">
              <FileText className="h-5 w-5" />
              Email Sequences
            </CardTitle>
            <div className="flex items-center gap-2 flex-wrap">
              {/* Preview Mode Toggle */}
              {sequences.length > 0 && leads.length > 0 && (
                <div className="flex items-center gap-2 bg-muted rounded-lg p-1">
                  <button
                    onClick={() => setIsPreviewMode(false)}
                    className={`flex items-center gap-1.5 px-3 py-1.5 rounded-md text-sm font-medium transition-colors ${
                      !isPreviewMode
                        ? "bg-background text-foreground shadow-sm"
                        : "text-muted-foreground hover:text-foreground"
                    }`}
                  >
                    <Code className="h-4 w-4" />
                    Variables
                  </button>
                  <button
                    onClick={() => setIsPreviewMode(true)}
                    className={`flex items-center gap-1.5 px-3 py-1.5 rounded-md text-sm font-medium transition-colors ${
                      isPreviewMode
                        ? "bg-background text-foreground shadow-sm"
                        : "text-muted-foreground hover:text-foreground"
                    }`}
                  >
                    <Eye className="h-4 w-4" />
                    Preview
                  </button>
                </div>
              )}

              {/* Lead Selector for Preview */}
              {isPreviewMode && leads.length > 0 && (
                <Select
                  value={previewLeadId || leads[0]?.id}
                  onValueChange={setPreviewLeadId}
                >
                  <SelectTrigger className="w-[220px]">
                    <SelectValue placeholder="Select a lead" />
                  </SelectTrigger>
                  <SelectContent>
                    {leads.slice(0, 20).map((lead) => (
                      <SelectItem key={lead.id} value={lead.id}>
                        {lead.first_name || lead.email.split('@')[0]} - {lead.company_name || 'No company'}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}

              <Button
                variant="outline"
                size="sm"
                onClick={handleSyncSequences}
                disabled={isSyncingSequences}
              >
                <Download className={`h-4 w-4 mr-2 ${isSyncingSequences ? "animate-spin" : ""}`} />
                {isSyncingSequences ? "Syncing..." : "Sync from Instantly"}
              </Button>
            </div>
          </div>

          {/* Preview Lead Info */}
          {isPreviewMode && previewLead && (
            <div className="mt-3 flex items-center gap-2 text-sm text-muted-foreground bg-blue-50 dark:bg-blue-950 border border-blue-200 dark:border-blue-800 rounded-lg px-3 py-2">
              <Eye className="h-4 w-4 text-blue-600 dark:text-blue-400" />
              <span>
                Previewing as: <strong className="text-foreground">{previewLead.first_name || previewLead.email.split('@')[0]}</strong>
                {previewLead.company_name && <> from <strong className="text-foreground">{previewLead.company_name}</strong></>}
              </span>
            </div>
          )}
        </CardHeader>
        <CardContent>
          {sequences.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              <FileText className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p className="font-medium">No email sequences found</p>
              <p className="text-sm mt-1">Click "Sync from Instantly" to fetch the email copy</p>
            </div>
          ) : (
            <div className="space-y-4">
              {/* Group sequences by variant */}
              {(() => {
                const variants = [...new Set(sequences.map(s => s.variant))].sort();
                return variants.map((variant) => (
                  <div key={variant} className="border border-border rounded-lg overflow-hidden">
                    <div className="bg-muted px-4 py-2 font-medium">
                      Version {variant}
                    </div>
                    <div className="divide-y divide-border">
                      {sequences
                        .filter(s => s.variant === variant)
                        .sort((a, b) => a.step_number - b.step_number)
                        .map((step) => (
                          <div key={step.id} className="p-4">
                            <div className="flex items-center gap-2 mb-2">
                              <Badge variant="outline">Step {step.step_number}</Badge>
                              {step.delay_days > 0 && (
                                <span className="text-xs text-muted-foreground">
                                  +{step.delay_days} day{step.delay_days > 1 ? "s" : ""} delay
                                </span>
                              )}
                            </div>

                            {/* Show email content - either preview mode with lead data, or raw template */}
                            {(() => {
                              const showPreview = isPreviewMode && previewLead;
                              const subject = showPreview
                                ? replaceTemplateVariables(step.subject || "", previewLead)
                                : step.subject;
                              const body = showPreview
                                ? replaceTemplateVariables(step.body_html || step.body_text || "", previewLead)
                                : (step.body_html || step.body_text || "<p>(No content)</p>");

                              return (
                                <>
                                  {subject && (
                                    <p className="font-medium text-sm mb-2">Subject: {subject}</p>
                                  )}
                                  <div
                                    className="bg-muted/50 rounded-lg p-3 text-sm max-h-64 overflow-y-auto [&_div]:mb-1 [&_br]:block [&_a]:text-blue-600 [&_a]:underline"
                                    dangerouslySetInnerHTML={{ __html: body }}
                                  />
                                </>
                              );
                            })()}
                          </div>
                        ))}
                    </div>
                  </div>
                ));
              })()}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Positive Replies */}
      {positiveLeads.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <ThumbsUp className="h-5 w-5 text-green-500" />
              Positive Replies ({positiveLeads.length})
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {positiveLeads.map((lead) => (
                <div
                  key={lead.id}
                  className="flex items-center justify-between p-3 bg-green-50 dark:bg-green-950 rounded-lg border border-green-100 dark:border-green-900"
                >
                  <div>
                    <p className="font-medium text-foreground">
                      {lead.first_name} {lead.last_name}
                    </p>
                    <p className="text-sm text-muted-foreground">{lead.email}</p>
                    {lead.company_name && (
                      <p className="text-xs text-muted-foreground">{lead.company_name}</p>
                    )}
                  </div>
                  <div className="text-right">
                    <Badge className="bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300">Positive</Badge>
                    <p className="text-xs text-muted-foreground mt-1">
                      {new Date(lead.updated_at).toLocaleDateString()}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Recent Leads */}
      {recentLeads.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Users className="h-5 w-5" />
              Recent Leads
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="overflow-x-auto">
              <table className="w-full text-sm">
                <thead>
                  <tr className="border-b">
                    <th className="text-left py-2 font-medium text-muted-foreground">Email</th>
                    <th className="text-left py-2 font-medium text-muted-foreground">Name</th>
                    <th className="text-left py-2 font-medium text-muted-foreground">Company</th>
                    <th className="text-left py-2 font-medium text-muted-foreground">Status</th>
                    <th className="text-left py-2 font-medium text-muted-foreground">Updated</th>
                  </tr>
                </thead>
                <tbody>
                  {recentLeads.map((lead) => (
                    <tr key={lead.id} className="border-b last:border-0">
                      <td className="py-2">{lead.email}</td>
                      <td className="py-2">
                        {lead.first_name} {lead.last_name}
                      </td>
                      <td className="py-2 text-muted-foreground">{lead.company_name || "-"}</td>
                      <td className="py-2">
                        <Badge
                          variant="outline"
                          className={lead.is_positive_reply ? "border-green-500 text-green-600" : ""}
                        >
                          {lead.status}
                        </Badge>
                      </td>
                      <td className="py-2 text-muted-foreground">
                        {new Date(lead.updated_at).toLocaleDateString()}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Footer */}
      {lastUpdated && (
        <p className="text-xs text-muted-foreground text-right">
          Last updated: {lastUpdated.toLocaleTimeString()}
        </p>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/page.tsx">
"use client";

import { useEffect, useState, useRef, useCallback } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { AddCustomerDialog } from "@/components/admin/add-customer-dialog";
import { DeleteCustomerDialog } from "@/components/admin/delete-customer-dialog";
import Link from "next/link";
import Image from "next/image";
import {
  Users,
  TrendingUp,
  RefreshCw,
  Search,
  Plus,
  MoreHorizontal,
  ChevronDown,
  Activity,
  Eye,
  Trash2,
  Archive,
  MessageSquareReply,
  Target,
  Send,
  Settings,
} from "lucide-react";

interface OverviewStats {
  leadsContacted: number;
  emailsSent: number;
  replies: number;
  opportunities: number;
  replyRate: number;
}

interface Customer {
  id: string;
  name: string;
  email?: string;
  logo_url?: string;
  is_active: boolean;
  created_at: string;
  campaigns_count: number;
  total_leads: number;
  total_emails_sent: number;
  reply_rate: number;
}

type TabType = "customers" | "leads";
type CustomerFilter = "active" | "archived";
type TimeRange = "all_time" | "this_week" | "this_month" | "this_quarter";

export default function AdminCommandCenter() {
  const hasFetched = useRef(false);
  const [stats, setStats] = useState<OverviewStats>({
    leadsContacted: 0,
    emailsSent: 0,
    replies: 0,
    opportunities: 0,
    replyRate: 0,
  });
  const [customers, setCustomers] = useState<Customer[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<TabType>("customers");
  const [customerFilter, setCustomerFilter] = useState<CustomerFilter>("active");
  const [searchQuery, setSearchQuery] = useState("");
  const [timeRange, setTimeRange] = useState<TimeRange>("all_time");
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);

  // New customer dialog state
  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);

  const fetchData = useCallback(async (force = false) => {
    if (hasFetched.current && !force) return;
    hasFetched.current = true;
    setLoading(true);
    setError(null);

    try {
      // Fetch customers and analytics in parallel
      const [customersRes, analyticsRes] = await Promise.all([
        fetch("/api/admin/customers"),
        fetch(`/api/admin/analytics?period=${timeRange}`),
      ]);

      const customersData = await customersRes.json();
      const analyticsData = await analyticsRes.json();

      const customersList: Customer[] = customersData.customers || [];

      setStats({
        leadsContacted: analyticsData.leads_contacted || 0,
        emailsSent: analyticsData.emails_sent || 0,
        replies: analyticsData.replies || 0,
        opportunities: analyticsData.opportunities || 0,
        replyRate: analyticsData.reply_rate || 0,
      });

      setCustomers(customersList);
      setLastUpdated(new Date());
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load data");
    } finally {
      setLoading(false);
    }
  }, [timeRange]);

  useEffect(() => {
    // Reset hasFetched when timeRange changes to allow refetch
    hasFetched.current = false;
    fetchData();

    // Auto-refresh every 30 seconds
    const interval = setInterval(() => {
      fetchData(true);
    }, 30000);

    return () => clearInterval(interval);
  }, [fetchData, timeRange]);

  const filteredCustomers = customers.filter((customer) => {
    const matchesFilter =
      customerFilter === "active" ? customer.is_active !== false : customer.is_active === false;
    const matchesSearch = customer.name.toLowerCase().includes(searchQuery.toLowerCase());
    return matchesFilter && matchesSearch;
  });

  const timeRangeLabels: Record<TimeRange, string> = {
    all_time: "All Time",
    this_week: "This Week",
    this_month: "This Month",
    this_quarter: "This Quarter",
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-foreground">Command Center</h1>
          <p className="text-muted-foreground text-sm">
            Manage paying customers, workspaces, and campaigns.
          </p>
        </div>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="outline" className="w-fit">
              {timeRangeLabels[timeRange]}
              <ChevronDown className="ml-2 h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuItem onClick={() => setTimeRange("all_time")}>All Time</DropdownMenuItem>
            <DropdownMenuItem onClick={() => setTimeRange("this_week")}>This Week</DropdownMenuItem>
            <DropdownMenuItem onClick={() => setTimeRange("this_month")}>This Month</DropdownMenuItem>
            <DropdownMenuItem onClick={() => setTimeRange("this_quarter")}>This Quarter</DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </div>

      {/* Overview Dashboard */}
      <Card className="bg-card border-border">
        <CardContent className="p-6">
          <div className="flex items-center justify-between mb-6">
            <div className="flex items-center gap-2">
              <h2 className="text-lg font-semibold text-foreground">Overview Dashboard</h2>
              <Badge variant="outline" className="text-green-600 dark:text-green-400 border-green-200 dark:border-green-800 bg-green-50 dark:bg-green-950">
                <Activity className="h-3 w-3 mr-1" />
                Live
              </Badge>
              <span className="text-xs text-muted-foreground">Updates every 30s</span>
            </div>
            <Button variant="ghost" size="sm" onClick={() => fetchData(true)} disabled={loading}>
              <RefreshCw className={`h-4 w-4 ${loading ? "animate-spin" : ""}`} />
            </Button>
          </div>

          {error && (
            <div className="bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-300 px-4 py-3 rounded-lg mb-6">
              {error}
            </div>
          )}

          <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
            <StatCard
              label="Leads Contacted"
              value={stats.leadsContacted}
              icon={<Users className="h-5 w-5 text-blue-500" />}
              loading={loading}
              href="/admin/leads"
            />
            <StatCard
              label="Emails Sent"
              value={stats.emailsSent}
              icon={<Send className="h-5 w-5 text-emerald-500" />}
              loading={loading}
              href="/admin/leads"
            />
            <StatCard
              label="Replies"
              value={stats.replies}
              icon={<MessageSquareReply className="h-5 w-5 text-purple-500" />}
              loading={loading}
              href="/admin/leads?status=replied"
            />
            <StatCard
              label="Positive Replies"
              value={stats.opportunities}
              icon={<Target className="h-5 w-5 text-green-500" />}
              loading={loading}
              href="/admin/leads?positive=true"
            />
            <StatCard
              label="Reply Rate"
              value={`${stats.replyRate.toFixed(1)}%`}
              icon={<TrendingUp className="h-5 w-5 text-amber-500" />}
              loading={loading}
            />
          </div>
        </CardContent>
      </Card>

      {/* Tabs */}
      <div className="flex gap-2 border-b border-border">
        <button
          onClick={() => setActiveTab("customers")}
          className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${
            activeTab === "customers"
              ? "border-blue-600 text-blue-600 dark:border-blue-400 dark:text-blue-400"
              : "border-transparent text-muted-foreground hover:text-foreground"
          }`}
        >
          All Customers
        </button>
        <Link
          href="/admin/leads"
          className="px-4 py-2 text-sm font-medium border-b-2 border-transparent text-muted-foreground hover:text-foreground transition-colors"
        >
          All Leads
        </Link>
        <Link
          href="/admin/lead-database"
          className="px-4 py-2 text-sm font-medium border-b-2 border-transparent text-muted-foreground hover:text-foreground transition-colors"
        >
          Lead Database
        </Link>
        <Link
          href="/admin/infrastructure"
          className="px-4 py-2 text-sm font-medium border-b-2 border-transparent text-muted-foreground hover:text-foreground transition-colors"
        >
          Infrastructure Health
        </Link>
        <Link
          href="/admin/subscriptions"
          className="px-4 py-2 text-sm font-medium border-b-2 border-transparent text-muted-foreground hover:text-foreground transition-colors"
        >
          Subscriptions
        </Link>
      </div>

      {/* Customers Section */}
      {activeTab === "customers" && (
        <div className="space-y-4">
          {/* Filters and Actions */}
          <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4">
            <div className="flex items-center gap-2">
              <button
                onClick={() => setCustomerFilter("active")}
                className={`px-3 py-1.5 text-sm rounded-lg transition-colors ${
                  customerFilter === "active"
                    ? "bg-primary text-primary-foreground"
                    : "bg-muted text-muted-foreground hover:bg-accent"
                }`}
              >
                Active Customers ({customers.filter((c) => c.is_active !== false).length})
              </button>
              <button
                onClick={() => setCustomerFilter("archived")}
                className={`px-3 py-1.5 text-sm rounded-lg transition-colors ${
                  customerFilter === "archived"
                    ? "bg-primary text-primary-foreground"
                    : "bg-muted text-muted-foreground hover:bg-accent"
                }`}
              >
                Archived ({customers.filter((c) => c.is_active === false).length})
              </button>
            </div>

            <div className="flex items-center gap-2">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Search customers..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="pl-9 w-64"
                />
              </div>
              <Button onClick={() => setIsAddDialogOpen(true)}>
                <Plus className="h-4 w-4 mr-2" />
                New Customer
              </Button>
              <AddCustomerDialog
                open={isAddDialogOpen}
                onOpenChange={setIsAddDialogOpen}
                onSuccess={() => fetchData(true)}
              />
            </div>
          </div>

          {/* Customers List */}
          <Card>
            <CardContent className="p-0">
              {loading && customers.length === 0 ? (
                <div className="flex items-center justify-center py-12">
                  <RefreshCw className="h-6 w-6 animate-spin text-muted-foreground" />
                </div>
              ) : filteredCustomers.length === 0 ? (
                <div className="text-center py-12 text-muted-foreground">
                  {searchQuery ? "No customers match your search." : "No customers found."}
                </div>
              ) : (
                <div className="divide-y divide-border">
                  {filteredCustomers.map((customer) => (
                    <CustomerRow key={customer.id} customer={customer} onRefresh={() => fetchData(true)} />
                  ))}
                </div>
              )}
            </CardContent>
          </Card>
        </div>
      )}

      {/* Footer info */}
      {lastUpdated && (
        <p className="text-xs text-muted-foreground text-right">
          Last updated: {lastUpdated.toLocaleTimeString()}
        </p>
      )}
    </div>
  );
}

function StatCard({
  label,
  value,
  icon,
  loading,
  href,
  onClick,
}: {
  label: string;
  value: string | number;
  icon: React.ReactNode;
  loading: boolean;
  href?: string;
  onClick?: () => void;
}) {
  const isClickable = href || onClick;
  const content = (
    <div className={`bg-muted rounded-xl p-4 ${isClickable ? "cursor-pointer hover:bg-accent hover:shadow-md transition-all" : ""}`}>
      <div className="flex items-center justify-between mb-2">
        <span className="text-sm text-muted-foreground">{label}</span>
        {icon}
      </div>
      <div className="text-2xl font-bold text-foreground">
        {loading ? (
          <div className="h-8 w-16 bg-accent rounded animate-pulse" />
        ) : typeof value === "number" ? (
          value.toLocaleString()
        ) : (
          value
        )}
      </div>
      {isClickable && (
        <p className="text-xs text-blue-500 dark:text-blue-400 mt-2">Click to view details </p>
      )}
    </div>
  );

  if (href) {
    return <Link href={href}>{content}</Link>;
  }

  if (onClick) {
    return <div onClick={onClick}>{content}</div>;
  }

  return content;
}

function CustomerRow({ customer, onRefresh }: { customer: Customer; onRefresh: () => void }) {
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);

  const handleArchive = async () => {
    try {
      await fetch(`/api/admin/customers/${customer.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ is_active: !customer.is_active }),
      });
      onRefresh();
    } catch (error) {
      console.error("Failed to update customer:", error);
    }
  };

  const handleDelete = async () => {
    const res = await fetch(`/api/admin/customers/${customer.id}`, {
      method: "DELETE",
    });

    if (!res.ok) {
      const data = await res.json();
      throw new Error(data.error || "Failed to delete customer");
    }

    onRefresh();
  };

  return (
    <div className="flex items-center justify-between px-6 py-4 hover:bg-accent transition-colors">
      <Link href={`/admin/clients/${customer.id}`} className="flex-1">
        <div className="flex items-center gap-4">
          <div className="w-10 h-10 rounded-full bg-muted flex items-center justify-center overflow-hidden">
            {customer.logo_url ? (
              <Image
                src={customer.logo_url}
                alt={customer.name}
                width={40}
                height={40}
                className="object-cover w-full h-full"
                unoptimized={customer.logo_url.startsWith("data:")}
              />
            ) : (
              <span className="text-sm font-medium text-muted-foreground">
                {customer.name.charAt(0).toUpperCase()}
              </span>
            )}
          </div>
          <div>
            <p className="font-medium text-foreground">{customer.name}</p>
            <p className="text-sm text-muted-foreground">
              {customer.campaigns_count || 0} campaigns
              {customer.total_emails_sent > 0 && `  ${customer.total_emails_sent.toLocaleString()} emails`}
              {customer.reply_rate > 0 && `  ${customer.reply_rate.toFixed(1)}% reply rate`}
            </p>
          </div>
        </div>
      </Link>

      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" size="sm">
            <MoreHorizontal className="h-4 w-4" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem asChild>
            <Link href={`/admin/clients/${customer.id}`} className="flex items-center gap-2">
              <Eye className="h-4 w-4" />
              View Details
            </Link>
          </DropdownMenuItem>
          <DropdownMenuItem asChild>
            <Link href={`/admin/clients/${customer.id}/settings`} className="flex items-center gap-2">
              <Settings className="h-4 w-4" />
              Settings
            </Link>
          </DropdownMenuItem>
          <DropdownMenuItem onClick={handleArchive} className="flex items-center gap-2">
            <Archive className="h-4 w-4" />
            {customer.is_active ? "Archive" : "Restore"}
          </DropdownMenuItem>
          <DropdownMenuItem
            onClick={() => setIsDeleteDialogOpen(true)}
            className="flex items-center gap-2 text-red-600 focus:text-red-600"
          >
            <Trash2 className="h-4 w-4" />
            Delete
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      <DeleteCustomerDialog
        open={isDeleteDialogOpen}
        onOpenChange={setIsDeleteDialogOpen}
        customerName={customer.name}
        onConfirm={handleDelete}
      />
    </div>
  );
}
</file>

<file path="src/app/api/instantly/sync/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import {
  fetchAllInstantlyCampaigns,
  fetchAllLeadsForCampaign,
  getCampaignAnalytics,
  getInstantlyClient,
} from "@/lib/instantly";
import type { SyncResult } from "@/lib/instantly";

function getSupabase() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// POST - Full sync from Instantly to local DB
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { client_id, sync_leads = true } = body as {
      client_id: string;
      sync_leads?: boolean;
    };

    if (!client_id) {
      return NextResponse.json(
        { error: "client_id is required" },
        { status: 400 }
      );
    }

    const client = getInstantlyClient();
    if (!client.isConfigured()) {
      return NextResponse.json(
        { error: "Instantly API not configured" },
        { status: 503 }
      );
    }

    const supabase = getSupabase();

    // Step 1: Sync campaigns
    const instantlyCampaigns = await fetchAllInstantlyCampaigns();

    const campaignResult: SyncResult = {
      success: true,
      imported: 0,
      updated: 0,
      failed: 0,
      errors: [],
    };

    // Get existing campaigns for THIS client only
    const { data: existingCampaigns } = await supabase
      .from("campaigns")
      .select("id, instantly_campaign_id")
      .eq("client_id", client_id);

    const existingMap = new Map(
      existingCampaigns?.map(c => [c.instantly_campaign_id, c.id]) || []
    );

    // Also check which Instantly campaign IDs are already used by OTHER clients
    const { data: allCampaigns } = await supabase
      .from("campaigns")
      .select("instantly_campaign_id")
      .not("instantly_campaign_id", "is", null);

    const allInstantlyIds = new Set(
      allCampaigns?.map(c => c.instantly_campaign_id) || []
    );

    const campaignIdMap = new Map<string, string>(); // instantly_id -> local_id

    for (const campaign of instantlyCampaigns) {
      const existingId = existingMap.get(campaign.id);

      if (existingId) {
        // Update existing campaign (belongs to this client)
        const { error } = await supabase
          .from("campaigns")
          .update({
            name: campaign.name,
            is_active: campaign.status === "active",
          })
          .eq("id", existingId);

        if (error) {
          campaignResult.failed++;
          campaignResult.errors?.push(`Failed to update ${campaign.name}: ${error.message}`);
        } else {
          campaignResult.updated++;
          campaignIdMap.set(campaign.id, existingId);
        }
      } else if (!allInstantlyIds.has(campaign.id)) {
        // Only create if no other client has this campaign
        const { data, error } = await supabase
          .from("campaigns")
          .insert({
            client_id,
            instantly_campaign_id: campaign.id,
            name: campaign.name,
            is_active: campaign.status === "active",
          })
          .select("id")
          .single();

        if (error) {
          campaignResult.failed++;
          campaignResult.errors?.push(`Failed to import ${campaign.name}: ${error.message}`);
        } else {
          campaignResult.imported++;
          campaignIdMap.set(campaign.id, data.id);
        }
      }
      // Skip campaigns that belong to other clients
    }

    // Step 2: Sync campaign analytics (always)
    try {
      const analyticsData = await getCampaignAnalytics();
      for (const a of analyticsData) {
        // Find local campaign by Instantly ID
        const localId = campaignIdMap.get(a.campaign_id) || existingMap.get(a.campaign_id);
        if (localId) {
          await supabase
            .from("campaigns")
            .update({
              cached_emails_sent: a.emails_sent_count || 0,
              cached_emails_bounced: a.bounced_count || 0,
              cached_emails_opened: a.open_count_unique || 0,
              cached_reply_count: a.reply_count || 0,
              cache_updated_at: new Date().toISOString(),
            })
            .eq("id", localId);
        }
      }
    } catch (analyticsError) {
      console.error("Failed to sync analytics:", analyticsError);
    }

    // Step 3: Sync leads (if enabled)
    const leadResult: SyncResult = {
      success: true,
      imported: 0,
      updated: 0,
      failed: 0,
      errors: [],
    };

    if (sync_leads) {
      // Get client name for denormalization
      const { data: clientData } = await supabase
        .from("clients")
        .select("name")
        .eq("id", client_id)
        .single();
      const clientName = clientData?.name || null;

      for (const [instantlyCampaignId, localCampaignId] of campaignIdMap) {
        try {
          const leads = await fetchAllLeadsForCampaign(instantlyCampaignId);

          // Get campaign name for denormalization
          const { data: campaignData } = await supabase
            .from("campaigns")
            .select("name")
            .eq("id", localCampaignId)
            .single();
          const campaignName = campaignData?.name || null;

          for (const lead of leads) {
            // Check if lead has replied using email_reply_count
            const hasReplied = ((lead as { email_reply_count?: number }).email_reply_count || 0) > 0;

            // Positive reply = manually tagged as interested/booked/etc (NOT just any reply)
            const positiveStatuses = ["interested", "meeting_booked", "meeting_completed", "closed"];
            const isPositiveReply = positiveStatuses.includes(lead.interest_status || "");

            // Normalize email for consistent lookup
            const normalizedEmail = lead.email.toLowerCase().trim();

            // Map to our lead status: contacted  replied  booked  won / lost
            let status: string = "contacted";
            if (lead.interest_status === "closed") {
              status = "won";
            } else if (lead.interest_status === "not_interested" || lead.interest_status === "wrong_person") {
              status = "lost";
            } else if (lead.interest_status === "meeting_booked" || lead.interest_status === "meeting_completed") {
              status = "booked";
            } else if (hasReplied || lead.interest_status === "interested") {
              status = "replied";
            }

            // Extract additional Instantly fields (needed for both insert and update)
            const instantlyData = lead as {
              company_domain?: string;
              personalization?: string;
              timestamp_created?: string;
              timestamp_last_contact?: string;
              status_summary?: { lastStep?: Record<string, unknown> };
              email_open_count?: number;
              email_click_count?: number;
              email_reply_count?: number;
              payload?: Record<string, string>;
            };

            const { data: existingLead } = await supabase
              .from("leads")
              .select("id, status, is_positive_reply, first_name, last_name, company_name, company_domain, phone, personalization, email_open_count, email_click_count, email_reply_count, last_contacted_at")
              .eq("campaign_id", localCampaignId)
              .eq("email", normalizedEmail)
              .single();

            if (existingLead) {
              // Lead exists - UPDATE Instantly-sourced fields while preserving local-only fields
              // Status priority: won(8) > lost(7) > booked(6) > replied(5) > clicked(4) > opened(3) > contacted(2) > not_interested(1)
              const statusPriority: Record<string, number> = {
                "won": 8, "lost": 7, "booked": 6, "replied": 5,
                "clicked": 4, "opened": 3, "contacted": 2, "not_interested": 1
              };

              const currentPriority = statusPriority[existingLead.status] || 0;
              const newPriority = statusPriority[status] || 0;

              // Build update object - only update fields that should be updated
              const updateData: Record<string, unknown> = {
                // Always update these from Instantly (they're Instantly-sourced)
                // Use newer timestamp if available
                last_contacted_at: instantlyData.timestamp_last_contact || null,
                last_step_info: instantlyData.status_summary?.lastStep || null,
                // Only increment counts, never decrease
                email_open_count: Math.max(instantlyData.email_open_count || 0, existingLead.email_open_count || 0),
                email_click_count: Math.max(instantlyData.email_click_count || 0, existingLead.email_click_count || 0),
                email_reply_count: Math.max(instantlyData.email_reply_count || 0, existingLead.email_reply_count || 0),
              };

              // Only update status if new status has higher priority (never downgrade)
              if (newPriority > currentPriority) {
                updateData.status = status;
              }

              // Only set is_positive_reply to true, never reset to false via sync
              // (webhooks can reset it based on explicit negative events)
              if (isPositiveReply && !existingLead.is_positive_reply) {
                updateData.is_positive_reply = true;
              }

              // Fill-only fields: only update if local value is empty
              if (!existingLead.first_name && lead.first_name) {
                updateData.first_name = lead.first_name;
              }
              if (!existingLead.last_name && lead.last_name) {
                updateData.last_name = lead.last_name;
              }
              if (!existingLead.company_name && lead.company_name) {
                updateData.company_name = lead.company_name;
              }
              if (!existingLead.company_domain && instantlyData.company_domain) {
                updateData.company_domain = instantlyData.company_domain;
              }
              if (!existingLead.phone && lead.phone) {
                updateData.phone = lead.phone;
              }
              if (!existingLead.personalization && instantlyData.personalization) {
                updateData.personalization = instantlyData.personalization;
              }

              // NOTE: These fields are NEVER touched by sync (preserved):
              // - notes, deal_value, next_action, next_action_date, linkedin_url

              const { error: updateError } = await supabase
                .from("leads")
                .update(updateData)
                .eq("id", existingLead.id);

              if (updateError) {
                leadResult.failed++;
              } else {
                leadResult.updated++;
              }
            } else {
              // New lead - insert with all Instantly data
              // Build metadata with payload for personalization variables
              const metadata: Record<string, unknown> = {};
              if (instantlyData.payload) {
                metadata.lead_data = instantlyData.payload;
              }

              const { error } = await supabase.from("leads").insert({
                campaign_id: localCampaignId,
                client_id: client_id,
                client_name: clientName,
                campaign_name: campaignName,
                email: normalizedEmail,
                first_name: lead.first_name || null,
                last_name: lead.last_name || null,
                company_name: lead.company_name || null,
                company_domain: instantlyData.company_domain || null,
                phone: lead.phone || null,
                personalization: instantlyData.personalization || null,
                status: status,
                is_positive_reply: isPositiveReply,
                instantly_lead_id: lead.id,
                instantly_created_at: instantlyData.timestamp_created || null,
                last_contacted_at: instantlyData.timestamp_last_contact || null,
                last_step_info: instantlyData.status_summary?.lastStep || null,
                email_reply_count: instantlyData.email_reply_count || 0,
                has_replied: hasReplied,
                metadata: Object.keys(metadata).length > 0 ? metadata : {},
              });

              if (error) {
                leadResult.failed++;
              } else {
                leadResult.imported++;
              }
            }
          }
        } catch (error) {
          leadResult.errors?.push(
            `Failed to sync leads for campaign ${instantlyCampaignId}: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }
    }

    return NextResponse.json({
      success: true,
      campaigns: campaignResult,
      leads: sync_leads ? leadResult : null,
    });
  } catch (error) {
    console.error("Error during sync:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Sync failed" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/admin/clients/[clientId]/page.tsx">
"use client";

import { useEffect, useState, useRef, useCallback, useMemo } from "react";
import { useParams } from "next/navigation";
import { createClient } from "@/lib/supabase/client";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import Image from "next/image";
import {
  ArrowLeft,
  Mail,
  MessageSquare,
  TrendingUp,
  Zap,
  RefreshCw,
  Plus,
  ExternalLink,
  Activity,
  BarChart3,
  Users,
  Eye,
  MousePointer,
  ThumbsUp,
  Trash2,
  CheckCircle,
  Calendar,
  Trophy,
  XCircle,
  Clock,
  ChevronDown,
  ChevronUp,
  Target,
  DollarSign,
  Settings,
  Lightbulb,
  Building2,
  MessageSquareText,
  Send,
  Reply,
  Download,
  Webhook,
  Copy,
  Check,
} from "lucide-react";
import { Textarea } from "@/components/ui/textarea";

interface CampaignAnalytics {
  emails_sent: number;
  emails_opened: number;
  emails_replied: number;
  emails_bounced: number;
  open_rate?: number;
  reply_rate: number;
  bounce_rate: number;
  total_opportunities: number;
  leads_count: number;
  contacted_count: number;
}

interface Campaign {
  id: string;
  name: string;
  instantly_campaign_id: string | null;
  is_active: boolean;
  status?: string;
  analytics?: CampaignAnalytics | null;
}

interface ClientData {
  id: string;
  name: string;
  is_active: boolean;
  logo_url?: string;
  website?: string;
  notes?: string;
  product_service?: string;
  icp?: string;
  acv?: number;
  tcv?: number;
  verticals?: string[];
  tam?: number;
  target_daily_emails?: number;
  created_at: string;
}

interface ClientStats {
  totalEmailsSent: number;
  totalOpened: number;
  totalReplies: number;
  totalBounced: number;
  totalPositiveReplies: number;
  totalLeadsCount: number;
  openRate: number;
  replyRate: number;
  bounceRate: number;
  activeCampaigns: number;
  totalCampaigns: number;
}

interface Lead {
  id: string;
  email: string;
  first_name: string | null;
  last_name: string | null;
  company_name: string | null;
  company_domain: string | null;
  status: string;
  has_replied: boolean;
  is_positive_reply: boolean;
  responded_at: string | null;
  meeting_at: string | null;
  closed_at: string | null;
  notes: string | null;
  campaign_name: string | null;
  created_at: string;
  updated_at: string;
}

interface LeadEmail {
  id: string;
  direction: "outbound" | "inbound";
  from_email: string;
  to_email: string;
  subject: string | null;
  body_text: string | null;
  body_html: string | null;
  sent_at: string | null;
}

export default function ClientDashboardPage() {
  const params = useParams();
  const clientId = params.clientId as string;
  const hasFetched = useRef(false);

  const [isAdmin, setIsAdmin] = useState<boolean | null>(null);
  const [client, setClient] = useState<ClientData | null>(null);
  const [campaigns, setCampaigns] = useState<Campaign[]>([]);
  // Client-wide stats from the API (more reliable than summing by campaign)
  const [clientStats, setClientStats] = useState<{ replied: number; positive: number }>({ replied: 0, positive: 0 });

  // Calculate stats reactively whenever campaigns or clientStats change
  const stats = useMemo<ClientStats>(() => {
    let totalEmailsSent = 0;
    let totalOpened = 0;
    let totalBounced = 0;
    let totalLeadsCount = 0;
    let totalRepliesFromCampaigns = 0;
    let totalPositiveFromCampaigns = 0;
    let activeCampaigns = 0;

    campaigns.forEach((campaign) => {
      if (campaign.is_active) {
        activeCampaigns++;
      }
      if (campaign.analytics) {
        totalEmailsSent += campaign.analytics.emails_sent || 0;
        totalOpened += campaign.analytics.emails_opened || 0;
        totalBounced += campaign.analytics.emails_bounced || 0;
        totalLeadsCount += campaign.analytics.leads_count || 0;
        totalRepliesFromCampaigns += campaign.analytics.emails_replied || 0;
        totalPositiveFromCampaigns += campaign.analytics.total_opportunities || 0;
      }
    });

    // Use client-wide stats for replies and positive (more reliable), fallback to aggregated campaign stats
    const totalReplies = clientStats.replied > 0 ? clientStats.replied : totalRepliesFromCampaigns;
    const totalPositiveReplies = clientStats.positive > 0 ? clientStats.positive : totalPositiveFromCampaigns;

    const openRate = totalEmailsSent > 0 ? (totalOpened / totalEmailsSent) * 100 : 0;
    const replyRate = totalEmailsSent > 0 ? (totalReplies / totalEmailsSent) * 100 : 0;
    const bounceRate = totalEmailsSent > 0 ? (totalBounced / totalEmailsSent) * 100 : 0;

    return {
      totalEmailsSent,
      totalOpened,
      totalReplies,
      totalBounced,
      totalPositiveReplies,
      totalLeadsCount,
      openRate,
      replyRate,
      bounceRate,
      activeCampaigns,
      totalCampaigns: campaigns.length,
    };
  }, [campaigns, clientStats]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  const [deletingCampaignId, setDeletingCampaignId] = useState<string | null>(null);
  const [positiveLeads, setPositiveLeads] = useState<Lead[]>([]);
  const [showWorkflow, setShowWorkflow] = useState(true);
  const [loadingLeads, setLoadingLeads] = useState(false);
  const [updatingLeadId, setUpdatingLeadId] = useState<string | null>(null);
  const [editingNotesId, setEditingNotesId] = useState<string | null>(null);
  const [notesInput, setNotesInput] = useState("");

  // Email viewing state
  const [expandedEmailLeadId, setExpandedEmailLeadId] = useState<string | null>(null);
  const [leadEmails, setLeadEmails] = useState<Record<string, LeadEmail[]>>({});
  const [loadingEmailsForLead, setLoadingEmailsForLead] = useState<string | null>(null);
  const [syncingEmailsForLead, setSyncingEmailsForLead] = useState<string | null>(null);
  const [syncingPositiveLeads, setSyncingPositiveLeads] = useState(false);
  const [syncPositiveResult, setSyncPositiveResult] = useState<{ success: boolean; message: string } | null>(null);

  const fetchEmailsForLead = async (leadId: string) => {
    setLoadingEmailsForLead(leadId);
    try {
      const res = await fetch(`/api/leads/${leadId}/emails`);
      if (res.ok) {
        const data = await res.json();
        setLeadEmails((prev) => ({ ...prev, [leadId]: data.emails || [] }));
      }
    } catch (err) {
      console.error("Failed to fetch emails:", err);
    } finally {
      setLoadingEmailsForLead(null);
    }
  };

  const syncEmailsForLead = async (leadId: string) => {
    setSyncingEmailsForLead(leadId);
    try {
      const res = await fetch(`/api/leads/${leadId}/emails`, { method: "POST" });
      if (res.ok) {
        // Refresh emails after sync
        await fetchEmailsForLead(leadId);
      }
    } catch (err) {
      console.error("Failed to sync emails:", err);
    } finally {
      setSyncingEmailsForLead(null);
    }
  };

  const toggleEmailView = async (leadId: string) => {
    if (expandedEmailLeadId === leadId) {
      setExpandedEmailLeadId(null);
    } else {
      setExpandedEmailLeadId(leadId);
      // Fetch emails if we don't have them yet
      if (!leadEmails[leadId]) {
        await fetchEmailsForLead(leadId);
      }
    }
  };

  const syncPositiveLeads = async () => {
    setSyncingPositiveLeads(true);
    setSyncPositiveResult(null);
    try {
      const res = await fetch(`/api/clients/${clientId}/sync-positive`, { method: "POST" });
      const data = await res.json();
      console.log("Sync result:", data);

      if (res.ok && data.success) {
        if (data.synced > 0) {
          setSyncPositiveResult({
            success: true,
            message: `Synced ${data.synced} leads (${data.upserted} updated)`,
          });
        } else {
          setSyncPositiveResult({
            success: false,
            message: data.message || "No positive leads found in Instantly",
          });
        }
        // Refresh leads after sync
        await fetchPositiveLeads();
      } else {
        setSyncPositiveResult({
          success: false,
          message: data.error || "Sync failed",
        });
      }
    } catch (err) {
      console.error("Failed to sync positive leads:", err);
      setSyncPositiveResult({
        success: false,
        message: err instanceof Error ? err.message : "Sync failed",
      });
    } finally {
      setSyncingPositiveLeads(false);
      // Clear result after 5 seconds
      setTimeout(() => setSyncPositiveResult(null), 5000);
    }
  };

  const fetchPositiveLeads = useCallback(async () => {
    setLoadingLeads(true);
    try {
      const res = await fetch(`/api/clients/${clientId}/leads?positive=true&limit=200`);
      if (res.ok) {
        const data = await res.json();
        setPositiveLeads(data.leads || []);
      }
    } catch (err) {
      console.error("Failed to fetch positive leads:", err);
    } finally {
      setLoadingLeads(false);
    }
  }, [clientId]);

  const handleWorkflowAction = async (
    leadId: string,
    action: "mark_responded" | "schedule_meeting" | "close_won" | "close_lost" | "update_notes" | "revert_status",
    extraData?: { meeting_at?: string; notes?: string }
  ) => {
    console.log("Workflow action:", { leadId, action, extraData });
    setUpdatingLeadId(leadId);
    try {
      const res = await fetch(`/api/leads/${leadId}/workflow`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action, ...extraData }),
      });

      const data = await res.json();
      console.log("Workflow response:", data);

      if (res.ok) {
        // Refresh leads after update
        await fetchPositiveLeads();
        setEditingNotesId(null);
        setNotesInput("");
      } else {
        alert(data.error || "Failed to update lead");
      }
    } catch (err) {
      console.error("Workflow error:", err);
      alert("Failed to update lead: " + (err instanceof Error ? err.message : "Unknown error"));
    } finally {
      setUpdatingLeadId(null);
    }
  };

  const handleDeleteCampaign = async (campaignId: string, campaignName: string) => {
    if (!confirm(`Are you sure you want to unlink "${campaignName}"?\n\nThis will remove the campaign from this dashboard. Leads will be preserved.`)) {
      return;
    }

    setDeletingCampaignId(campaignId);
    try {
      const res = await fetch(`/api/campaigns/${campaignId}`, {
        method: "DELETE",
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to delete campaign");
      }

      // Refresh the data
      fetchClientData(true);
    } catch (err) {
      alert(err instanceof Error ? err.message : "Failed to delete campaign");
    } finally {
      setDeletingCampaignId(null);
    }
  };

  const fetchClientData = useCallback(async (force = false) => {
    if (hasFetched.current && !force) return;
    hasFetched.current = true;
    setLoading(true);
    setError(null);

    try {
      // Fetch client details and campaigns from local DB (fast)
      const [clientRes, campaignsRes] = await Promise.all([
        fetch(`/api/clients/${clientId}`),
        fetch(`/api/clients/${clientId}/campaigns`), // Uses local Supabase data by default
      ]);

      if (!clientRes.ok) {
        throw new Error("Client not found");
      }

      const clientData = await clientRes.json();
      const campaignsData = await campaignsRes.json();

      setClient(clientData.client);
      setCampaigns(campaignsData.campaigns || []);
      // Set client-wide stats
      if (campaignsData.clientStats) {
        setClientStats(campaignsData.clientStats);
      }

      setLastUpdated(new Date());
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load data");
      return 0;
    } finally {
      setLoading(false);
    }
  }, [clientId]);

  // Check if user is admin
  useEffect(() => {
    const checkUserRole = async () => {
      const supabase = createClient();
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        const { data: profile } = await supabase
          .from("profiles")
          .select("role")
          .eq("id", user.id)
          .single();
        setIsAdmin(profile?.role === "admin");
      }
    };
    checkUserRole();
  }, []);

  useEffect(() => {
    fetchClientData();
    fetchPositiveLeads();

    // Auto-refresh every 30 seconds
    const interval = setInterval(() => {
      fetchClientData(true);
      fetchPositiveLeads();
    }, 30000);

    return () => clearInterval(interval);
  }, [fetchClientData, fetchPositiveLeads]);

  if (loading && !client) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <RefreshCw className="h-8 w-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (error && !client) {
    return (
      <div className="space-y-4">
        <Link
          href="/admin"
          className="text-sm text-blue-600 dark:text-blue-400 hover:underline flex items-center gap-1"
        >
          <ArrowLeft className="h-4 w-4" />
          Back to Command Center
        </Link>
        <div className="bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-300 px-4 py-3 rounded-lg">
          {error}
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4">
        <div>
          {isAdmin && (
            <Link
              href="/admin"
              className="text-sm text-muted-foreground hover:text-foreground flex items-center gap-1 mb-2"
            >
              <ArrowLeft className="h-4 w-4" />
              Back to Command Center
            </Link>
          )}
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 rounded-xl bg-muted flex items-center justify-center overflow-hidden">
              {client?.logo_url ? (
                <Image
                  src={client.logo_url}
                  alt={`${client.name} logo`}
                  width={48}
                  height={48}
                  className="object-contain w-full h-full"
                  unoptimized={client.logo_url.startsWith("data:")}
                />
              ) : (
                <span className="text-lg font-bold text-muted-foreground">
                  {client?.name?.charAt(0).toUpperCase()}
                </span>
              )}
            </div>
            <div>
              <h1 className="text-2xl font-bold text-foreground">{client?.name}</h1>
              <p className="text-muted-foreground text-sm">Campaign Performance Dashboard</p>
            </div>
          </div>
        </div>
        <div className="flex items-center gap-2">
          <Badge variant="outline" className="text-green-600 dark:text-green-400 border-green-200 dark:border-green-800 bg-green-50 dark:bg-green-950">
            <Activity className="h-3 w-3 mr-1" />
            Live
          </Badge>
          <Button
            variant="outline"
            size="sm"
            onClick={() => fetchClientData(true)}
            disabled={loading}
          >
            <RefreshCw className={`h-4 w-4 mr-2 ${loading ? "animate-spin" : ""}`} />
            Refresh
          </Button>
        </div>
      </div>

      {error && (
        <div className="bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-300 px-4 py-3 rounded-lg">
          {error}
        </div>
      )}

      {/* Client Overview Hero Card */}
      {(client?.tam || client?.product_service || client?.icp) && (
        <Card className="bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-900 dark:to-slate-800 border-slate-200 dark:border-slate-700 overflow-hidden">
          <CardContent className="p-0">
            <div className="grid grid-cols-1 lg:grid-cols-3 divide-y lg:divide-y-0 lg:divide-x divide-slate-200 dark:divide-slate-700">
              {/* TAM Section */}
              <div className="p-6">
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center gap-2">
                    <div className="w-10 h-10 rounded-xl bg-blue-500/10 flex items-center justify-center">
                      <Target className="h-5 w-5 text-blue-500" />
                    </div>
                    <div>
                      <p className="text-xs font-medium text-muted-foreground uppercase tracking-wider">Total Addressable Market</p>
                      <p className="text-2xl font-bold text-foreground">
                        {client?.tam ? client.tam.toLocaleString() : ""}
                      </p>
                    </div>
                  </div>
                </div>
                <p className="text-sm text-muted-foreground">
                  {client?.tam ? "potential leads in target market" : "TAM not defined yet"}
                </p>
              </div>

              {/* Offer Section */}
              <div className="p-6">
                <div className="flex items-center gap-2 mb-4">
                  <div className="w-10 h-10 rounded-xl bg-emerald-500/10 flex items-center justify-center">
                    <Lightbulb className="h-5 w-5 text-emerald-500" />
                  </div>
                  <p className="text-xs font-medium text-muted-foreground uppercase tracking-wider">The Offer</p>
                </div>
                {client?.product_service ? (
                  <p className="text-sm text-foreground leading-relaxed line-clamp-4">
                    {client.product_service}
                  </p>
                ) : (
                  <p className="text-sm text-muted-foreground italic">
                    No offer description defined yet
                  </p>
                )}
              </div>

              {/* ICP Section */}
              <div className="p-6">
                <div className="flex items-center gap-2 mb-4">
                  <div className="w-10 h-10 rounded-xl bg-purple-500/10 flex items-center justify-center">
                    <Users className="h-5 w-5 text-purple-500" />
                  </div>
                  <p className="text-xs font-medium text-muted-foreground uppercase tracking-wider">Ideal Customer Profile</p>
                </div>
                {client?.icp ? (
                  <p className="text-sm text-foreground leading-relaxed line-clamp-4">
                    {client.icp}
                  </p>
                ) : (
                  <p className="text-sm text-muted-foreground italic">
                    No ICP defined yet
                  </p>
                )}
              </div>
            </div>

            {/* Additional Details Bar */}
            {(client?.verticals?.length || client?.acv || client?.tcv || client?.notes) && (
              <div className="border-t border-slate-200 dark:border-slate-700 bg-slate-100/50 dark:bg-slate-800/50 px-6 py-4">
                <div className="flex flex-wrap items-center gap-x-6 gap-y-2">
                  {client?.verticals && client.verticals.length > 0 && (
                    <div className="flex items-center gap-2">
                      <Building2 className="h-4 w-4 text-muted-foreground" />
                      <div className="flex flex-wrap gap-1">
                        {client.verticals.slice(0, 3).map((vertical, index) => (
                          <Badge key={index} variant="secondary" className="text-xs">
                            {vertical}
                          </Badge>
                        ))}
                        {client.verticals.length > 3 && (
                          <Badge variant="outline" className="text-xs">
                            +{client.verticals.length - 3} more
                          </Badge>
                        )}
                      </div>
                    </div>
                  )}
                  {client?.acv && (
                    <div className="flex items-center gap-1.5 text-sm">
                      <DollarSign className="h-4 w-4 text-muted-foreground" />
                      <span className="text-muted-foreground">ACV:</span>
                      <span className="font-medium">${client.acv.toLocaleString()}</span>
                    </div>
                  )}
                  {client?.tcv && (
                    <div className="flex items-center gap-1.5 text-sm">
                      <DollarSign className="h-4 w-4 text-muted-foreground" />
                      <span className="text-muted-foreground">TCV:</span>
                      <span className="font-medium">${client.tcv.toLocaleString()}</span>
                    </div>
                  )}
                  {isAdmin && (
                    <Link href={`/admin/clients/${clientId}/settings`} className="ml-auto">
                      <Button variant="ghost" size="sm" className="text-muted-foreground hover:text-foreground">
                        <Settings className="h-4 w-4 mr-1" />
                        Edit
                      </Button>
                    </Link>
                  )}
                </div>
                {client?.notes && (
                  <div className="mt-3 pt-3 border-t border-slate-200 dark:border-slate-700">
                    <div className="flex items-start gap-2">
                      <MessageSquareText className="h-4 w-4 text-muted-foreground mt-0.5" />
                      <p className="text-sm text-muted-foreground">{client.notes}</p>
                    </div>
                  </div>
                )}
              </div>
            )}
          </CardContent>
        </Card>
      )}

      {/* Stats Overview */}
      <div className="grid grid-cols-2 lg:grid-cols-5 gap-4">
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-muted-foreground">Emails Sent</span>
              <Mail className="h-5 w-5 text-blue-500" />
            </div>
            <div className="text-2xl font-bold text-foreground">
              {stats.totalEmailsSent.toLocaleString()}
            </div>
            <p className="text-xs text-muted-foreground">{stats.totalLeadsCount.toLocaleString()} leads</p>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-muted-foreground">Reply Rate</span>
              <MessageSquare className="h-5 w-5 text-emerald-500" />
            </div>
            <div className="text-2xl font-bold text-foreground">
              {stats.replyRate.toFixed(1)}%
            </div>
            <p className="text-xs text-muted-foreground">{stats.totalReplies.toLocaleString()} replies</p>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-muted-foreground">Positive Replies</span>
              <ThumbsUp className="h-5 w-5 text-green-500" />
            </div>
            <div className="text-2xl font-bold text-green-600">
              {stats.totalPositiveReplies.toLocaleString()}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-muted-foreground">Bounced</span>
              <TrendingUp className="h-5 w-5 text-red-500" />
            </div>
            <div className="text-2xl font-bold text-red-500">
              {stats.bounceRate.toFixed(1)}%
            </div>
            <p className="text-xs text-muted-foreground">{stats.totalBounced.toLocaleString()} bounced</p>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-muted-foreground">Active Campaigns</span>
              <Zap className="h-5 w-5 text-orange-500" />
            </div>
            <div className="text-2xl font-bold text-foreground">{stats.activeCampaigns}</div>
            <p className="text-xs text-muted-foreground">of {stats.totalCampaigns} total</p>
          </CardContent>
        </Card>
      </div>

      {/* Lead Workflow Management */}
      <Card>
        <CardHeader className="pb-4">
          <div className="flex items-center justify-between">
            <CardTitle className="flex items-center gap-2">
              <ThumbsUp className="h-5 w-5 text-green-500" />
              Lead Workflow
              {positiveLeads.length > 0 && (
                <Badge variant="secondary">{positiveLeads.length}</Badge>
              )}
              {stats.totalPositiveReplies > positiveLeads.length && (
                <Badge variant="outline" className="text-amber-600 border-amber-300 bg-amber-50 dark:bg-amber-950">
                  {stats.totalPositiveReplies - positiveLeads.length} missing
                </Badge>
              )}
            </CardTitle>
            <div className="flex items-center gap-2">
              {stats.totalPositiveReplies > positiveLeads.length && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={syncPositiveLeads}
                  disabled={syncingPositiveLeads}
                  className="text-amber-600 hover:text-amber-700 border-amber-300"
                >
                  {syncingPositiveLeads ? (
                    <RefreshCw className="h-4 w-4 animate-spin mr-1" />
                  ) : (
                    <Download className="h-4 w-4 mr-1" />
                  )}
                  Sync from Instantly
                </Button>
              )}
              {syncPositiveResult && (
                <span className={`text-xs flex items-center gap-1 ${syncPositiveResult.success ? "text-green-600" : "text-red-500"}`}>
                  {syncPositiveResult.success ? (
                    <CheckCircle className="h-3 w-3" />
                  ) : (
                    <XCircle className="h-3 w-3" />
                  )}
                  {syncPositiveResult.message}
                </span>
              )}
              <Button
                variant="ghost"
                size="sm"
                onClick={() => fetchPositiveLeads()}
                disabled={loadingLeads}
              >
                <RefreshCw className={`h-4 w-4 ${loadingLeads ? "animate-spin" : ""}`} />
              </Button>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setShowWorkflow(!showWorkflow)}
              >
                {showWorkflow ? (
                  <ChevronUp className="h-4 w-4" />
                ) : (
                  <ChevronDown className="h-4 w-4" />
                )}
              </Button>
            </div>
          </div>
          {/* Stats Summary */}
          {positiveLeads.length > 0 && (
            <div className="flex flex-wrap gap-4 mt-3 text-sm">
              <div className="flex items-center gap-1.5">
                <CheckCircle className="h-4 w-4 text-green-500" />
                <span className="text-muted-foreground">Responded:</span>
                <span className="font-medium">
                  {positiveLeads.filter(l => l.responded_at).length}
                </span>
              </div>
              <div className="flex items-center gap-1.5">
                <Calendar className="h-4 w-4 text-blue-500" />
                <span className="text-muted-foreground">Meetings:</span>
                <span className="font-medium">
                  {positiveLeads.filter(l => l.status === "booked" || l.meeting_at).length}
                </span>
              </div>
              <div className="flex items-center gap-1.5">
                <Trophy className="h-4 w-4 text-green-600" />
                <span className="text-muted-foreground">Won:</span>
                <span className="font-medium text-green-600">
                  {positiveLeads.filter(l => l.status === "won").length}
                </span>
              </div>
              <div className="flex items-center gap-1.5">
                <XCircle className="h-4 w-4 text-red-500" />
                <span className="text-muted-foreground">Lost:</span>
                <span className="font-medium text-red-500">
                  {positiveLeads.filter(l => l.status === "lost").length}
                </span>
              </div>
            </div>
          )}
        </CardHeader>
        {showWorkflow && (
          <CardContent>
            {loadingLeads && positiveLeads.length === 0 ? (
              <div className="flex items-center justify-center py-8">
                <RefreshCw className="h-6 w-6 animate-spin text-muted-foreground" />
              </div>
            ) : positiveLeads.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground">
                <ThumbsUp className="h-12 w-12 mx-auto mb-4 text-muted-foreground/50" />
                <p className="font-medium">No positive replies yet</p>
                <p className="text-sm mt-1">
                  Positive replies will appear here for workflow management.
                </p>
              </div>
            ) : (
              <div className="space-y-4">
                {positiveLeads.map((lead) => (
                  <div
                    key={lead.id}
                    className="border border-border rounded-lg p-4 relative"
                  >
                    {/* Lead Header */}
                    <div className="flex items-start justify-between mb-3">
                      <div>
                        <div className="flex items-center gap-2">
                          <span className="font-medium text-foreground">
                            {/* Show email username if first_name looks like salutation */}
                            {lead.first_name && !lead.first_name.toLowerCase().startsWith("sehr geehrte")
                              ? `${lead.first_name}${lead.last_name ? ` ${lead.last_name}` : ""}`
                              : lead.email.split("@")[0]}
                          </span>
                          <Badge
                            variant={
                              lead.status === "won"
                                ? "default"
                                : lead.status === "lost"
                                ? "destructive"
                                : "secondary"
                            }
                            className={
                              lead.status === "won"
                                ? "bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300"
                                : lead.status === "booked"
                                ? "bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300"
                                : ""
                            }
                          >
                            {lead.status === "won"
                              ? "Won"
                              : lead.status === "lost"
                              ? "Lost"
                              : lead.status === "booked"
                              ? "Meeting Booked"
                              : lead.status === "replied"
                              ? "Replied"
                              : lead.status}
                          </Badge>
                        </div>
                        <p className="text-sm text-muted-foreground">{lead.email}</p>
                        {lead.company_name && (
                          <p className="text-sm text-muted-foreground">{lead.company_name}</p>
                        )}
                        {lead.campaign_name && (
                          <p className="text-xs text-muted-foreground mt-1">
                            Campaign: {lead.campaign_name}
                          </p>
                        )}
                      </div>
                    </div>

                    {/* Timeline indicators */}
                    <div className="flex flex-wrap gap-3 text-xs text-muted-foreground mb-3">
                      {lead.responded_at && (
                        <span className="flex items-center gap-1">
                          <CheckCircle className="h-3 w-3 text-green-500" />
                          Responded: {new Date(lead.responded_at).toLocaleDateString()}
                        </span>
                      )}
                      {lead.meeting_at && (
                        <span className="flex items-center gap-1">
                          <Calendar className="h-3 w-3 text-blue-500" />
                          Meeting: {new Date(lead.meeting_at).toLocaleDateString()}
                        </span>
                      )}
                      {lead.closed_at && (
                        <span className="flex items-center gap-1">
                          {lead.status === "won" ? (
                            <Trophy className="h-3 w-3 text-green-500" />
                          ) : (
                            <XCircle className="h-3 w-3 text-red-500" />
                          )}
                          Closed: {new Date(lead.closed_at).toLocaleDateString()}
                        </span>
                      )}
                    </div>

                    {/* Action Buttons */}
                    <div className="flex flex-wrap gap-2 mb-3">
                      {!lead.responded_at && lead.status !== "won" && lead.status !== "lost" && (
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => handleWorkflowAction(lead.id, "mark_responded")}
                          disabled={updatingLeadId === lead.id}
                        >
                          <CheckCircle className="h-4 w-4 mr-1" />
                          Mark Responded
                        </Button>
                      )}

                      {lead.status !== "booked" && lead.status !== "won" && lead.status !== "lost" && (
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => handleWorkflowAction(lead.id, "schedule_meeting", {
                            meeting_at: new Date().toISOString(),
                          })}
                          disabled={updatingLeadId === lead.id}
                        >
                          <Calendar className="h-4 w-4 mr-1" />
                          Schedule Meeting
                        </Button>
                      )}

                      {lead.status !== "won" && lead.status !== "lost" && (
                        <>
                          <Button
                            size="sm"
                            variant="outline"
                            className="text-green-600 hover:text-green-700 hover:bg-green-50"
                            onClick={() => handleWorkflowAction(lead.id, "close_won")}
                            disabled={updatingLeadId === lead.id}
                          >
                            <Trophy className="h-4 w-4 mr-1" />
                            Close Won
                          </Button>
                          <Button
                            size="sm"
                            variant="outline"
                            className="text-red-600 hover:text-red-700 hover:bg-red-50"
                            onClick={() => handleWorkflowAction(lead.id, "close_lost")}
                            disabled={updatingLeadId === lead.id}
                          >
                            <XCircle className="h-4 w-4 mr-1" />
                            Close Lost
                          </Button>
                        </>
                      )}

                      {(lead.status === "won" || lead.status === "lost" || lead.status === "booked") && (
                        <Button
                          size="sm"
                          variant="ghost"
                          className="text-muted-foreground"
                          onClick={() => handleWorkflowAction(lead.id, "revert_status")}
                          disabled={updatingLeadId === lead.id}
                        >
                          <Clock className="h-4 w-4 mr-1" />
                          Revert
                        </Button>
                      )}
                    </div>

                    {/* View Emails Button */}
                    <div className="mb-3">
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={() => toggleEmailView(lead.id)}
                        disabled={loadingEmailsForLead === lead.id}
                        className="w-full justify-between"
                      >
                        <span className="flex items-center">
                          <MessageSquareText className="h-4 w-4 mr-2" />
                          View Email Exchange
                        </span>
                        {loadingEmailsForLead === lead.id ? (
                          <RefreshCw className="h-4 w-4 animate-spin" />
                        ) : expandedEmailLeadId === lead.id ? (
                          <ChevronUp className="h-4 w-4" />
                        ) : (
                          <ChevronDown className="h-4 w-4" />
                        )}
                      </Button>
                    </div>

                    {/* Email Exchange Section */}
                    {expandedEmailLeadId === lead.id && (
                      <div className="mb-3 border border-border rounded-lg overflow-hidden">
                        <div className="bg-muted/50 px-3 py-2 flex items-center justify-between">
                          <span className="text-sm font-medium">
                            Email Thread
                            {leadEmails[lead.id] && leadEmails[lead.id].length > 0 && (
                              <span className="ml-2 text-xs text-muted-foreground">
                                ({leadEmails[lead.id].length} {leadEmails[lead.id].length === 1 ? "email" : "emails"})
                              </span>
                            )}
                          </span>
                          <div className="flex items-center gap-2">
                            <Button
                              size="sm"
                              variant="ghost"
                              onClick={() => fetchEmailsForLead(lead.id)}
                              disabled={loadingEmailsForLead === lead.id}
                              className="h-7 text-xs"
                              title="Refresh emails"
                            >
                              <RefreshCw className={`h-3 w-3 ${loadingEmailsForLead === lead.id ? "animate-spin" : ""}`} />
                            </Button>
                            <Button
                              size="sm"
                              variant="ghost"
                              onClick={() => syncEmailsForLead(lead.id)}
                              disabled={syncingEmailsForLead === lead.id}
                              className="h-7 text-xs"
                              title="Fetch latest emails from Instantly"
                            >
                              {syncingEmailsForLead === lead.id ? (
                                <RefreshCw className="h-3 w-3 animate-spin mr-1" />
                              ) : (
                                <Download className="h-3 w-3 mr-1" />
                              )}
                              Fetch from Instantly
                            </Button>
                          </div>
                        </div>
                        <div className="p-3 space-y-3 max-h-[400px] overflow-y-auto">
                          {loadingEmailsForLead === lead.id ? (
                            <div className="flex items-center justify-center py-4">
                              <RefreshCw className="h-5 w-5 animate-spin text-muted-foreground" />
                            </div>
                          ) : !leadEmails[lead.id] || leadEmails[lead.id].length === 0 ? (
                            <div className="text-center py-4 text-muted-foreground">
                              <MessageSquareText className="h-8 w-8 mx-auto mb-2 opacity-50" />
                              <p className="text-sm">No emails found</p>
                              <p className="text-xs mt-1">
                                Emails are synced automatically via webhooks.
                              </p>
                              <Button
                                size="sm"
                                variant="outline"
                                onClick={() => syncEmailsForLead(lead.id)}
                                disabled={syncingEmailsForLead === lead.id}
                                className="mt-3"
                              >
                                {syncingEmailsForLead === lead.id ? (
                                  <RefreshCw className="h-4 w-4 animate-spin mr-2" />
                                ) : (
                                  <Download className="h-4 w-4 mr-2" />
                                )}
                                Fetch from Instantly
                              </Button>
                            </div>
                          ) : (
                            leadEmails[lead.id]
                              .filter((email) => email.body_text || email.body_html)
                              .map((email) => {
                                // Extract text content - prefer body_text, fall back to stripped HTML
                                let content = email.body_text;
                                if (!content && email.body_html) {
                                  // Strip HTML tags for display
                                  content = email.body_html
                                    .replace(/<br\s*\/?>/gi, '\n')
                                    .replace(/<\/p>/gi, '\n')
                                    .replace(/<[^>]+>/g, '')
                                    .replace(/&nbsp;/g, ' ')
                                    .replace(/&amp;/g, '&')
                                    .replace(/&lt;/g, '<')
                                    .replace(/&gt;/g, '>')
                                    .replace(/&quot;/g, '"')
                                    .trim();
                                }
                                if (!content) return null;

                                return (
                                  <div
                                    key={email.id}
                                    className={`rounded-lg p-3 ${
                                      email.direction === "outbound"
                                        ? "bg-blue-50 dark:bg-blue-950 border-l-4 border-blue-500"
                                        : "bg-green-50 dark:bg-green-950 border-l-4 border-green-500"
                                    }`}
                                  >
                                    <div className="flex items-center justify-between mb-2">
                                      <div className="flex items-center gap-2">
                                        {email.direction === "outbound" ? (
                                          <Send className="h-3 w-3 text-blue-500" />
                                        ) : (
                                          <Reply className="h-3 w-3 text-green-500" />
                                        )}
                                        <span className="text-xs font-medium text-muted-foreground">
                                          {email.direction === "outbound" ? "You" : lead.email.split("@")[0]}
                                        </span>
                                      </div>
                                      <span className="text-xs text-muted-foreground">
                                        {email.sent_at
                                          ? new Date(email.sent_at).toLocaleDateString()
                                          : ""}
                                      </span>
                                    </div>
                                    <div className="text-sm text-foreground whitespace-pre-wrap">
                                      {content}
                                    </div>
                                  </div>
                                );
                              })
                          )}
                        </div>
                      </div>
                    )}

                    {/* Notes Section */}
                    <div className="border-t border-border pt-3">
                      {editingNotesId === lead.id ? (
                        <div className="space-y-2">
                          <Textarea
                            value={notesInput}
                            onChange={(e) => setNotesInput(e.target.value)}
                            placeholder="Add notes about this lead..."
                            className="text-sm"
                            rows={3}
                          />
                          <div className="flex gap-2">
                            <Button
                              size="sm"
                              onClick={() =>
                                handleWorkflowAction(lead.id, "update_notes", { notes: notesInput })
                              }
                              disabled={updatingLeadId === lead.id}
                            >
                              Save Notes
                            </Button>
                            <Button
                              size="sm"
                              variant="ghost"
                              onClick={() => {
                                setEditingNotesId(null);
                                setNotesInput("");
                              }}
                            >
                              Cancel
                            </Button>
                          </div>
                        </div>
                      ) : (
                        <div
                          className="cursor-pointer group"
                          onClick={() => {
                            setEditingNotesId(lead.id);
                            setNotesInput(lead.notes || "");
                          }}
                        >
                          {lead.notes ? (
                            <p className="text-sm text-muted-foreground group-hover:text-foreground">
                              {lead.notes}
                            </p>
                          ) : (
                            <p className="text-sm text-muted-foreground/50 group-hover:text-muted-foreground">
                              Click to add notes...
                            </p>
                          )}
                        </div>
                      )}
                    </div>

                    {/* Loading overlay */}
                    {updatingLeadId === lead.id && (
                      <div className="absolute inset-0 bg-background/50 flex items-center justify-center rounded-lg">
                        <RefreshCw className="h-6 w-6 animate-spin" />
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
          </CardContent>
        )}
      </Card>

      {/* Campaigns List */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between pb-4">
          <CardTitle className="flex items-center gap-2">
            <BarChart3 className="h-5 w-5" />
            Campaign Performance
          </CardTitle>
          {isAdmin && (
            <Link href={`/admin/clients/${clientId}/campaigns`}>
              <Button size="sm">
                <Plus className="h-4 w-4 mr-2" />
                Link Campaign
              </Button>
            </Link>
          )}
        </CardHeader>
        <CardContent>
          {campaigns.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <BarChart3 className="h-12 w-12 mx-auto mb-4 text-muted-foreground/50" />
              <p className="font-medium">No campaigns linked yet</p>
              <p className="text-sm mt-1">
                {isAdmin
                  ? "Link an Instantly campaign to start tracking performance."
                  : "No campaigns have been linked to your account yet."}
              </p>
              {isAdmin && (
                <Link href={`/admin/clients/${clientId}/campaigns`}>
                  <Button className="mt-4" variant="outline">
                    <Plus className="h-4 w-4 mr-2" />
                    Link Your First Campaign
                  </Button>
                </Link>
              )}
            </div>
          ) : (
            <div className="space-y-3">
              {campaigns.map((campaign) => (
                <CampaignCard
                  key={campaign.id}
                  campaign={campaign}
                  clientId={clientId}
                  onDelete={() => handleDeleteCampaign(campaign.id, campaign.name)}
                  isDeleting={deletingCampaignId === campaign.id}
                  isAdmin={isAdmin === true}
                  onSyncComplete={() => fetchClientData(true)}
                />
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Footer */}
      {lastUpdated && (
        <p className="text-xs text-muted-foreground text-right">
          Last updated: {lastUpdated.toLocaleTimeString()}
        </p>
      )}
    </div>
  );
}

function CampaignCard({
  campaign,
  clientId,
  onDelete,
  isDeleting,
  isAdmin,
  onSyncComplete,
}: {
  campaign: Campaign;
  clientId: string;
  onDelete: () => void;
  isDeleting: boolean;
  isAdmin: boolean;
  onSyncComplete?: () => void;
}) {
  const [showWebhook, setShowWebhook] = useState(false);
  const [copied, setCopied] = useState(false);
  const [showInstantlyDeleteConfirm, setShowInstantlyDeleteConfirm] = useState(false);
  const [deletingFromInstantly, setDeletingFromInstantly] = useState(false);
  const [syncing, setSyncing] = useState(false);
  const [syncResult, setSyncResult] = useState<{ success: boolean; message: string } | null>(null);
  const analytics = campaign.analytics;
  const hasAnalytics = analytics && analytics.emails_sent > 0;

  const handleSync = async () => {
    setSyncing(true);
    setSyncResult(null);
    try {
      const res = await fetch(`/api/campaigns/${campaign.id}/sync-leads`, {
        method: "POST",
      });
      const data = await res.json();
      if (data.error) {
        setSyncResult({ success: false, message: data.error });
      } else {
        setSyncResult({
          success: true,
          message: `Synced ${data.inserted} new, ${data.updated} updated`,
        });
        onSyncComplete?.();
        // Reload page after short delay to show updated stats
        setTimeout(() => window.location.reload(), 1500);
      }
    } catch (error) {
      setSyncResult({
        success: false,
        message: error instanceof Error ? error.message : "Sync failed",
      });
    } finally {
      setSyncing(false);
    }
  };

  const handleDeleteFromInstantly = async () => {
    if (!campaign.instantly_campaign_id) {
      alert("This campaign is not linked to Instantly");
      return;
    }

    setDeletingFromInstantly(true);
    try {
      const res = await fetch(`/api/instantly/campaigns/${campaign.instantly_campaign_id}`, {
        method: "DELETE",
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to delete from Instantly");
      }

      const data = await res.json();
      alert(data.message || "Campaign deleted from Instantly successfully");
      setShowInstantlyDeleteConfirm(false);
    } catch (err) {
      alert(err instanceof Error ? err.message : "Failed to delete campaign from Instantly");
    } finally {
      setDeletingFromInstantly(false);
    }
  };

  // Generate webhook URL
  const webhookUrl = typeof window !== "undefined"
    ? `${window.location.origin}/api/webhooks/instantly/${campaign.id}`
    : `/api/webhooks/instantly/${campaign.id}`;

  const copyWebhookUrl = async () => {
    try {
      await navigator.clipboard.writeText(webhookUrl);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy:", err);
    }
  };

  return (
    <div className="border border-border rounded-lg p-4 hover:border-muted-foreground/50 transition-colors">
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-2">
            <Link
              href={`/admin/clients/${clientId}/campaigns/${campaign.id}`}
              className="font-medium text-foreground hover:text-blue-600 dark:hover:text-blue-400 hover:underline"
            >
              {campaign.name}
            </Link>
            <Badge
              variant={campaign.is_active ? "default" : "secondary"}
              className={campaign.is_active ? "bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300" : ""}
            >
              {campaign.is_active ? "Active" : "Paused"}
            </Badge>
          </div>

          {hasAnalytics ? (
            <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 mt-4">
              <div>
                <p className="text-xs text-muted-foreground uppercase tracking-wide">Sent</p>
                <p className="text-lg font-semibold text-foreground">
                  {analytics.emails_sent.toLocaleString()}
                </p>
              </div>
              <div>
                <p className="text-xs text-muted-foreground uppercase tracking-wide">Replies</p>
                <p className="text-lg font-semibold text-emerald-600">
                  {analytics.emails_replied.toLocaleString()}
                  <span className="text-sm font-normal text-muted-foreground ml-1">
                    ({(analytics.reply_rate * 100).toFixed(1)}%)
                  </span>
                </p>
              </div>
              <div>
                <p className="text-xs text-muted-foreground uppercase tracking-wide">Positive</p>
                <p className="text-lg font-semibold text-green-600">
                  {(analytics.total_opportunities || 0).toLocaleString()}
                </p>
              </div>
              <div>
                <p className="text-xs text-muted-foreground uppercase tracking-wide">Bounced</p>
                <p className="text-lg font-semibold text-red-500">
                  {analytics.emails_bounced.toLocaleString()}
                  <span className="text-sm font-normal text-muted-foreground ml-1">
                    ({(analytics.bounce_rate * 100).toFixed(1)}%)
                  </span>
                </p>
              </div>
            </div>
          ) : (
            <div className="mt-3 flex items-center gap-3">
              <Button
                variant="outline"
                size="sm"
                onClick={handleSync}
                disabled={syncing}
              >
                {syncing ? (
                  <>
                    <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
                    Syncing...
                  </>
                ) : (
                  <>
                    <RefreshCw className="h-4 w-4 mr-2" />
                    Sync Leads
                  </>
                )}
              </Button>
              {syncResult && (
                <span className={`text-xs ${syncResult.success ? "text-green-600" : "text-red-600"}`}>
                  {syncResult.message}
                </span>
              )}
              {!syncResult && !syncing && (
                <span className="text-sm text-muted-foreground">Click to fetch data from Instantly</span>
              )}
            </div>
          )}
        </div>

        {isAdmin && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              onDelete();
            }}
            disabled={isDeleting}
            className="text-muted-foreground hover:text-red-500 disabled:opacity-50"
            title="Unlink campaign"
          >
            {isDeleting ? (
              <RefreshCw className="h-4 w-4 animate-spin" />
            ) : (
              <Trash2 className="h-4 w-4" />
            )}
          </button>
        )}
      </div>

      {/* Progress bar: leads contacted vs total leads */}
      {hasAnalytics && analytics.leads_count > 0 && (() => {
        const leadsContacted = Math.min(analytics.contacted_count, analytics.leads_count);
        const progressPct = (leadsContacted / analytics.leads_count) * 100;
        return (
          <div className="mt-4">
            <div className="flex items-center justify-between text-xs text-muted-foreground mb-1">
              <span>Campaign Progress</span>
              <span>
                {leadsContacted.toLocaleString()} / {analytics.leads_count.toLocaleString()} leads contacted
              </span>
            </div>
            <div className="h-2 bg-muted rounded-full overflow-hidden">
              <div
                className="h-full bg-blue-500 rounded-full transition-all"
                style={{ width: `${progressPct}%` }}
              />
            </div>
          </div>
        );
      })()}

      {/* Webhook Configuration */}
      <div className="mt-4 pt-4 border-t border-border">
        <button
          onClick={() => setShowWebhook(!showWebhook)}
          className="flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors"
        >
          <Webhook className="h-4 w-4" />
          <span>Webhook for Instantly</span>
          {showWebhook ? (
            <ChevronUp className="h-3 w-3" />
          ) : (
            <ChevronDown className="h-3 w-3" />
          )}
        </button>

        {showWebhook && (
          <div className="mt-3 space-y-3">
            <div className="flex items-center gap-2">
              <code className="flex-1 text-xs bg-muted px-3 py-2 rounded font-mono break-all">
                {webhookUrl}
              </code>
              <Button
                variant="outline"
                size="sm"
                onClick={copyWebhookUrl}
                className="shrink-0"
              >
                {copied ? (
                  <Check className="h-4 w-4 text-green-500" />
                ) : (
                  <Copy className="h-4 w-4" />
                )}
              </Button>
            </div>

            <div className="bg-amber-50 dark:bg-amber-950 border border-amber-200 dark:border-amber-800 rounded-lg p-3 text-xs">
              <p className="font-medium text-amber-800 dark:text-amber-200 mb-2">Setup in Instantly:</p>
              <ol className="list-decimal list-inside space-y-1 text-amber-700 dark:text-amber-300">
                <li>Open this campaign in Instantly</li>
                <li>Go to <span className="font-medium">Campaign Settings</span>  <span className="font-medium">Webhooks</span></li>
                <li>Click <span className="font-medium">Add Webhook</span></li>
                <li>Paste the URL above</li>
                <li>Select these events:</li>
              </ol>
              <div className="mt-2 ml-4 space-y-1">
                <p className="text-amber-700 dark:text-amber-300">
                  <span className="font-medium text-green-700 dark:text-green-400">Positive:</span>{" "}
                  <code className="bg-amber-100 dark:bg-amber-900 px-1 rounded">lead_interested</code>,{" "}
                  <code className="bg-amber-100 dark:bg-amber-900 px-1 rounded">lead_meeting_booked</code>,{" "}
                  <code className="bg-amber-100 dark:bg-amber-900 px-1 rounded">lead_meeting_completed</code>,{" "}
                  <code className="bg-amber-100 dark:bg-amber-900 px-1 rounded">lead_closed</code>
                </p>
                <p className="text-amber-700 dark:text-amber-300">
                  <span className="font-medium text-red-700 dark:text-red-400">Negative:</span>{" "}
                  <code className="bg-amber-100 dark:bg-amber-900 px-1 rounded">lead_not_interested</code>,{" "}
                  <code className="bg-amber-100 dark:bg-amber-900 px-1 rounded">lead_neutral</code>
                </p>
              </div>
              <p className="mt-3 text-amber-600 dark:text-amber-400 italic">
                When Instantly fires these events, positive replies will sync automatically in real-time.
              </p>
            </div>

            {/* Delete from Instantly - Admin Only */}
            {isAdmin && campaign.instantly_campaign_id && (
              <div className="mt-4 pt-4 border-t border-border">
                {!showInstantlyDeleteConfirm ? (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setShowInstantlyDeleteConfirm(true)}
                    className="text-red-600 hover:text-red-700 hover:bg-red-50 border-red-200"
                  >
                    <Trash2 className="h-4 w-4 mr-2" />
                    Delete from Instantly
                  </Button>
                ) : (
                  <div className="bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 rounded-lg p-4">
                    <p className="text-sm font-medium text-red-800 dark:text-red-200 mb-2">
                      Are you sure you want to delete this campaign from Instantly?
                    </p>
                    <p className="text-xs text-red-600 dark:text-red-400 mb-3">
                      This will permanently delete the campaign from Instantly. Your local campaign data and leads will NOT be affected.
                    </p>
                    <div className="flex items-center gap-2">
                      <Button
                        variant="destructive"
                        size="sm"
                        onClick={handleDeleteFromInstantly}
                        disabled={deletingFromInstantly}
                      >
                        {deletingFromInstantly ? (
                          <RefreshCw className="h-4 w-4 animate-spin mr-2" />
                        ) : (
                          <Trash2 className="h-4 w-4 mr-2" />
                        )}
                        Yes, Delete from Instantly
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => setShowInstantlyDeleteConfirm(false)}
                        disabled={deletingFromInstantly}
                      >
                        Cancel
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

</files>
